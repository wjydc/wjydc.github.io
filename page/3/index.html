<!DOCTYPE html>


<html lang="en">


<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     薇娇
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  <link rel="stylesheet" href="/dist/main.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css">
  <link rel="stylesheet" href="/css/custom.css">
  
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
  
  

  

</head>

</html>

<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/Shen-Yu/hexo-theme-ayer"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">薇娇</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  <ul class="ads">
    
        <li>
            <a href="https://curl.qcloud.com/ezctH6FU">
                <img src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/ten_1.jpg" width="300" alt="腾讯云限时秒杀">
            </a>
        </li>
    
        <li>
            <a href="https://curl.qcloud.com/kvO7hb43">
                <img src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/ten_2.jpg" width="300" alt="云服务器全球购低至2折">
            </a>
        </li>
    
</ul>
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-深入理解Ajax"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2016/04/26/深入理解Ajax/"
    >深入理解Ajax</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2016/04/26/深入理解Ajax/" class="article-date">
  <time datetime="2016-04-26T01:34:23.000Z" itemprop="datePublished">2016-04-26</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h3 id="深入理解Ajax"><a href="#深入理解Ajax" class="headerlink" title="深入理解Ajax"></a>深入理解Ajax</h3><p>1 什么是AJAX ,AJAX原理</p>
<p>AJAX即“Asynchronous Javascript And XML”(异步JavaScript和XML)通过在后台与服务器进行少量 数据交</p>
<p>换,AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下,对网页的某部分 进行更新。传统的</p>
<p>网页(不使用 AJAX)如果需要更新内容,必须重载整个网页页面。</p>
<p>原理:XMLHttpRequest</p>
<p>2 使用异步加载获取JS数据至少两种方法?<br> post,  get</p>
<p>3 什么是JSON,JSON的格式</p>
<p>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。JSON 语法是 JavaScript 对象表示 语法的子集。</p>
<pre><code>数据在键值对中

   数据由逗号分隔

   花括号保存对象

   方括号保存数组
</code></pre><p>除了AJAX还有jsonp可以与后台交互</p>
<p>4 AJAX中的跨域问题:什么是跨域?如何解决跨域问题?</p>
<p>域不一样的,即为跨域,包括(协议,域名,端又号) </p>
<p>解决跨域问题方法：</p>
<ul>
<li><p>1.// 指定允许其他域名访问</p>
<p>  header(‘Access-Control-Allow-Origin:*’);</p>
</li>
<li>2.使用jsonp</li>
</ul>
<p>5 AJAX的流程是什么?</p>
<ul>
<li><p>1.客户端产生js的事件</p>
</li>
<li><p>2.创建XMLHttpRequest对象 3.对XMLHttpRequest进行配置 4.通过AJAX引擎发送异步请求 5.服务器端接收请</p>
</li>
</ul>
<p>求并且处理请求,返回html或者xml内容 6.XML调用一个callback()处理响应回来的内容 7.页面局部刷新</p>
<p>6 AJAX如何调用JSON数据？  xml.responseText</p>
<p>7 AJAX能够处理哪些格式的文件</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest</a><br>XMLHttpRequest2.0 新增了多种类型 支持txt,json,js,图片,文档等等…</li>
</ul>
<p>8 AJAX实现表单验证用户注册流程</p>
<ul>
<li>用户触发ajax请求,后台接又返回json格式字符串</li>
</ul>
<p>9  JSON数据的解析方法</p>
<pre><code>* 1.JSON.parse(json)

* 2.new Function(“return ” + json) (); 3.eval(“(”+json+”)”)
</code></pre><p>10 如何转化成JSON字符串</p>
<pre><code>JSON.stringify(json)
</code></pre><p>11 说明异步请求的get和post方法的区别</p>
<pre><code>1.使用Get请求时,参数在URL中显示,而使用Post方式,则不会显示出来 

 2.使用Get请求发送数据量小,Post请求发送数据量大
</code></pre><p>12 列举AJAX的优势 </p>
<p>传统的Web应用交互由用户触发一个HTTP请求到服务器,服务器对其进行处理后再返回一个新的 HTHL页到客户端, 每当服务器处理客户端提交的请求时,客户都只能空闲等待,并且哪怕只是一次很小的交互、 只需从服务器端得到很简单的一个数据,都要返回一个完整的HTML页,而用户每次都要浪费时间和带宽去重新 读取整个页面。这个做法浪费了许多带宽,由于每次应用的交互都需要向服务器发送请求,应用的响应时间就 依赖于服务器的响应时间。这导致了用户界面的响应比本地应用慢得多。</p>
<p>与此不同,AJAX应用可以仅向服务器发送并取回必需的数据,它使用SOAP或其它一些基于XML的Web Service接又,并在客户端采用JavaScript处理来自服务器的响应。因为在服务器和浏览器之间交换的数据大量减 少,结果我们就能看到响应更快的应用。同时很多的处理工作可以在发出请求的客户端机器上完成,所以Web 服务器的处理时间也减少了。</p>
<p>13 AJAX中创建请求的兼容性处理</p>
<pre><code>var xmlHttp = window.XMLHttpRequest ? new XMLHttpRequest() : new     ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);
</code></pre><p> 14 对于request.status的http状态码 用于表示网页服务器HTTP响应状态的3位数字代</p>
<p>码。1,2,3,4,5开头的状态码分别代表什么(提示:404页面表示禁止访问等)</p>
<p>1xx(临时响应)表示临时响应并需要请求者继续执行操作的状态代码。</p>
<p>2xx (成功)表示成功处理了请求的状态代码。</p>
<p>3xx (重定向) 表示要完成请求,需要进一步操作。 通常,这些状态代码用来重定向。</p>
<p>4xx(请求错误) 这些状态代码表示请求可能出错,妨碍了服务器的处理。 </p>
<p>5xx(服务器错误)这些状态代码表示服务器在尝试处理请求时发生内部错</p>
<p>误。 这些错误可能是服务器</p>
<p>15  下列对get和post的区别描述错误的是(C )</p>
<p>A、get比post更常用 </p>
<p>B、get发送信息为明文发送,安全性较差</p>
<p>C、get的性能只有post的1/3 </p>
<p>D、get传输数据是通过URL进行的 </p>
<p>16 如何将js对象转化成JSON字符串( D )<br>A、JSON.parseInt() B、JSON.parse() C、JSON.string () D、JSON.stringify ()</p>
<p>17 AJAX流程</p>
<pre><code>var xhr = window.XMLHttpRequest ?
new XMLHttpRequest() : new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;) ;
 /*创建 一个AJAX对象*/

xhr.open(type,url);

//请求方式为post时需要加上
xhr.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);

xhr.send();

xhr.onreadystatechange = function(){

    if(xhr.readyState === 4 &amp;&amp; xhr.status === 200){
        //doSometing

        &lt;!--解析数据--&gt;
        var data = xhr.responseText;

        &lt;!--回调函数--&gt;
        callback(data);
        }
    }
</code></pre><p>18 AJAX的工作原理</p>
<p>Ajax的工作原理相当于在用户和服务器之间加了—个中间层(AJAX引擎),使用户操作与服务器响应异步化。 并不是所有的用户请求都提交给服务器,像—些数据验证和数据处理等都交给Ajax引擎自己来做, 只有确定需要 从服务器读取新数据时再由Ajax引擎代为向服务器提交请求。<br>Ajax其核心有JavaScript、XMLHTTPRequest、DOM对象组成,通过XmlHttpRequest对象来向服务器发异 步请求,从服务器获得数据,然后用JavaScript来操作DOM而更新页面。这其中最关键的一步就是从服务器获 得请求数据。</p>
<p>第一步:创建ajax对象(XMLHttpRequest/ActiveXObject(Microsoft.XMLHttp)) 第二步:判断数据传输方式(GET/POST)</p>
<p>第三步:打开链接 open()</p>
<p>第四步:发送 send() 当ajax对象完成第四步(onreadystatechange)数据接收完成,判断http响应状态(status)200-300之间或</p>
<p>者304(缓存)执行回调函数 注意:检测XMLHttpRequest对象的readyState属性,该属性表示请求/响应过程的当前活动阶段,属</p>
<p>性值如下:</p>
<p>0:未初始化。尚未调用open()方法</p>
<p>1:启动。已经调用open()方法,但尚未调用send()方法 2:发送。已经调用send()方法,但尚未接收到响应</p>
<p>3:接收。已经接收到部分响应数据</p>
<p>4: 完成。已经接收到全部响应数据,而且已经可以在客户端使用了(如果写原生的js ajax请求需要等到<br>readyState==4的时候再做处理)其他的js库已经做好处理了,放心使用</p>
<p>19 . Jsonp的意义,用法,优点和原理<br>JSONP的优点是:它不像XMLHttpRequest对象实现的Ajax请求那样受到同源策略的限制;它的兼容性更 好,在更加古老的浏览器中都 可以运行,不需要XMLHttpRequest或ActiveX的支持;并且在请求完毕后可以通 过调用callback的方式回传结果。<br>JSONP的缺点则是:它只支持GET请求而不支持POST等其它类型的HTTP请求;它只支持跨域HTTP请 求这种情况,不能解决不同域的两个页面之间如何进行JavaScript调用的问题。<br>JSONP原理<br>JSONP的最基本的原理是:动态添加一个<script>标签,而script标签的src属性是没有跨域的限制的。这 样说来,这种跨域方式其实与ajax XmlHttpRequest协议无关了。<br>这样其实”jQuery AJAX跨域问题”就成了个伪命题,jquery $.ajax方法名有误导人之嫌。<br>如果设为dataType: ‘jsonp’,这个$.ajax方法就和ajax XmlHttpRequest没什么关系了,取而代之的则是 JSONP协议。JSONP是一个非官方的协议,它允许在服务器端集成Script tags返回至客户端,通过javascript callback的形式实现跨域访问。<br>JSONP即JSON with Padding。由于同源策略的限制,XmlHttpRequest只允许请求当前源(域名、协议、 端又)的资源。如果要进行跨域请求, 我们可以通过使用html的script标记来进行跨域请求,并在响应中返回 要执行的script代码,其中可以直接使用JSON传递javascript对象。 这种跨域的通讯方式称为JSONP。<br>jsonCallback 函数jsonp1236827957501(….):是浏览器客户端注册的,获取跨域服务器上的json数据后,回 调的函数<br>Jsonp的执行过程如下:<br>首先在客户端注册一个callback (如:’jsoncallback’), 然后把callback的名字(如:jsonp1236827957501)传给服务 器。注意:服务端得到callback的数值后,要用jsonp1236827957501(……)把将要输出的json内容包括起来,此时, 服务器生成 json 数据才能被客户端正确接收。<br>然后以 javascript 语法的方式,生成一个function, function 名字就是传递上来的参数 ‘jsoncallback’的值 jsonp1236827957501 .<br>最后将 json 数据直接以入参的方式,放置到 function 中,这样就生成了一段 js 语法的文档,返回给客户 端。<br>客户端浏览器,解析script标签,并执行返回的 javascript 文档,此时javascript文档数据,作为参数, 传 入到了客户端预先定义好的 callback 函数(如上例中jquery $.ajax()方法封装的的success: function (json))里。<br>可以说jsonp的方式原理上和<script src="http://跨域/...xx.js"></script>是一致的(qq空间就是大量采用这 种方式来实现跨域数据交换的)。JSONP是一种脚本注入(Script Injection)行为,所以有一定的安全隐患。</p>
<p>20  get与post两种方式的优缺点。</p>
<p>get:</p>
<p>get是从服务器上获取数据,post是向服务器传送数据; get传送的数据量较小,不能大于2KB。post传送的数据量较大,一般被默认为不受限制。但理论上,IIS4<br>中最大量为80KB,IIS5中为100KB;<br>get安全性非常低,post安全性较高。但是执行效率却比Post方法好; get是把参数数据队列加到提交表单的ACTION属性所指的URL中,值和表单内各个字段一一对应,在<br>URL中可以看到; 在做数据查询时,建议用Get方式;</p>
<p>post:</p>
<p>post是通过HTTP post机制,将表单内各个字段与其内容放置在HTML HEADER内一起传送到ACTION属 性所指的URL地址,用户看不到这个过程;<br>所以:包含机密信息的话,建议用Post数据提交方式;而在做数据添加、修改或删除时,建议用Post方 式。</p>
<p>21 一次完整的HTTP事务是怎样一个过程?</p>
<p>a.域名解析</p>
<p>b.发起TCP的三次握手 c.建立TCP连接后发起http请求 d.服务器端响应http请求,浏览器得到html码 e.浏览器解析html代码,并请求html代码中的资源 f.浏览器对页面进行渲染并呈现给客户</p>
<p>更多详细参考地址:<a href="http://www.360doc.com/content/14/0725/20/1073512_397054861.shtml" target="_blank" rel="noopener">http://www.360doc.com/content/14/0725/20/1073512_397054861.shtml</a></p>
<p>22  CORS是什么?对于跨域请求,如何将附带凭证(HTTP Cookie及HTTP认证信息) 的请求发送至服务器?</p>
<p>跨域请求一直是网页编程中的一个难题,在过去,绝大多数人都倾向于使用JSONP来解决这一问题。 不过现在,我们可以考虑一下W3C中一项新的特性——CORS(Cross-Origin Resource Sharing)了。CORS是现 代浏览器支持跨域资源请求的一种方式。<br>解决方法:<br>当你使用XMLHttpRequest发送请求时,浏览器发现该请求不符合同源策略,会给该请求加一个请求头: Origin,后台(php或者其它接收数据方)进行一系列处理,如果确定接受请求则在返回结果中加入一个响应 头:Access-Control-Allow-Origin;浏览器判断该相应头中是否包含Origin的值,如果有则浏览器会处理响应,我 们就可以拿到响应数据,如果不包含浏览器直接驳回,这时我们无法拿到响应数据。<br>更多参考地址:<a href="www.cnblogs.com/dojo-lzz/p/4265637.html
http://www.cnblogs.com/rainman/archive/2011/02/20/1959325.html">www.cnblogs.com/dojo-lzz/p/4265637.html<br>http://www.cnblogs.com/rainman/archive/2011/02/20/1959325.html</a></p>
<p>23  浅谈一下如何避免用户多次点击造成的多次请求。</p>
<p>我们在访问有的网站,输入表单完成以后,单击提交按钮进行提交以后,提交按钮就会变为灰色,<br>用户不能再单击第二次,直到重新加载页面或者跳转。这样,可以一定程度上防止用户重复提交导致应用程序<br>上逻辑错误。</p>
<p>还有很多其他的方式进行防止重复点击提交,如<br>1&gt; 定义标志位: 点击触发请求后,标志位为false量;请求(或者包括请求后具体的业务流程处理)后,标志位为true<br>量。通过标志位来判断用户点击是否具备应有的响应。 2&gt; 卸载及重载绑定事件:<br>点击触发请求后,卸载点击事件;请求(或者包括请求后具体的业务流程<br>处理)后,重新载入绑定事</p>
<p>件。<br>3&gt; 替换(移除)按钮DOM 点击触发请求后,将按钮DOM对象替换掉(或者将之移除),自然而然此时不在具备点击事件;请求<br>(或者包括请求后具体的业务流程处理)后,给新的按钮DOM定义点击事件。 更多讲解参考:<a href="http://www.cnblogs.com/jinguangguo/archive/2013/05/20/3086925.html" target="_blank" rel="noopener">http://www.cnblogs.com/jinguangguo/archive/2013/05/20/3086925.html</a></p>
<p>24  异步加载的方式有哪些?</p>
<p>(1)defer,只支持 IE</p>
<p>(2)async:</p>
<p>(3)创建 script,插入到 DOM 中,加载完毕后 callBack </p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-bootstrap轮播图片的设计"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2016/04/05/bootstrap轮播图片的设计/"
    >bootstrap轮播图片的设计</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2016/04/05/bootstrap轮播图片的设计/" class="article-date">
  <time datetime="2016-04-05T07:06:22.000Z" itemprop="datePublished">2016-04-05</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h3 id="bootstrap轮播图片的设计"><a href="#bootstrap轮播图片的设计" class="headerlink" title="bootstrap轮播图片的设计"></a>bootstrap轮播图片的设计</h3><p><img src="http://img1.sc115.com/uploads/sc/jpg/HD/2/45.jpg" alt="http://img1.sc115.com/uploads/sc/jpg/HD/2/45.jpg"></p>
<p>一个轮播图片主要包括三个部分：</p>
<ul>
<li><p>☑ 轮播的图片</p>
</li>
<li><p>☑ 轮播图片的计数器</p>
</li>
<li><p>☑ 轮播图片的控制器</p>
</li>
</ul>
<p>复杂一点的轮播图片，每个轮播区会带有对应的标题和描述内容。那么在 Bootstrap 框架中，轮播图是如何设计的呢？</p>
<p>第一步：设计轮播图片的容器。在 Bootstrap 框架中采用 carousel 样式，并且给这个容器定义一个 ID 值，方</p>
<p>便后面采用 data 属性来声明触发。</p>
<div id="slidershow" class="carousel"></div>

<p>第二步：设计轮播图片计数器。在容器 div.carousel 的内部添加轮播图片计算器，采用 carousel-</p>
<p>indicators 样式，其主要功能是显示当前图片的播放顺序(有几张图片就放置几个li)，一般采用有顺列表来制作：</p>
<pre><code>&lt;div id=&quot;slidershow&quot; class=&quot;carousel&quot;&gt;
&lt;!-- 设置图片轮播的顺序 --&gt;
&lt;ol class=&quot;carousel-indicators&quot;&gt;
    &lt;li class=&quot;active&quot;&gt;1&lt;/li&gt;
    &lt;li&gt;2&lt;/li&gt;
    &lt;li&gt;3&lt;/li&gt;
    &lt;li&gt;4&lt;/li&gt;
    &lt;li&gt;5&lt;/li&gt;
    ...
&lt;/ol&gt;
&lt;/div&gt;
</code></pre><p>在 Bootstrap 框架中，轮播图片计数器，都是以圆点向大家呈现，其具体样式如下：</p>
<pre><code>/*bootstrap.css文件第5835行～第5863行*/
.carousel-indicators {
position: absolute; /*整个计数区域绝对定位*/
bottom: 10px; /*距容器carousel底部10px*/
z-index: 15; /*设置其在Z轴的层级*/
/*让整个计数区水平居中*/
left: 50%;
width: 60%;
padding-left: 0;
margin-left: -30%;
text-align: center;
list-style: none;
}
.carousel-indicators li {
display: inline-block;
width: 10px;
height: 10px;
margin: 1px;
text-indent: -999px;
cursor: pointer;
background-color: #000 \9;
background-color: rgba(0, 0, 0, 0);
border: 1px solid #fff;
border-radius: 10px;
}
/*设置当前状态样式*/
.carousel-indicators .active {
width: 12px;
height: 12px;
margin: 0;
background-color: #fff;
}
</code></pre><p>第三步：设计轮播图片播放区。轮播图整个效果中，播放区是最关键的一个区域，这个区域主要用来放置需要轮播的图片。这个区域使用 carousel-inner 样式来控制，而且其同样放置在 carousel 容器内，并且通过 item 容器来放置每张轮播的图片：</p>
<pre><code>&lt;div id=&quot;slidershow&quot; class=&quot;carousel&quot;&gt;
    &lt;!-- 设置图片轮播的顺序 --&gt;
       &lt;ol class=&quot;carousel-indicators&quot;&gt;
        &lt;li class=&quot;active&quot;&gt;1&lt;/li&gt;
            …
        &lt;/ol&gt;
    &lt;!-- 设置轮播图片 --&gt;
    &lt;div class=&quot;carousel-inner&quot;&gt;
        &lt;div class=&quot;item active&quot;&gt;
            &lt;a href=&quot;##&quot;&gt;&lt;img src=&quot;ll580x145.jpg&quot; alt=&quot;&quot;&gt;&lt;/a&gt;
        &lt;/div&gt;
           &lt;div class=&quot;item&quot;&gt;
            &lt;a href=&quot;##&quot;&gt;&lt;img src=&quot;580145.jpg&quot; alt=&quot;&quot;&gt;&lt;/a&gt;
        &lt;/div&gt;
                …
        &lt;div class=&quot;item&quot;&gt;
            &lt;a href=&quot;##&quot;&gt;&lt;img src=&quot;580145.jpg&quot; alt=&quot;&quot;&gt;&lt;/a&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
</code></pre><p>其主要通过 carousel-inner 来控制其样式呈现。</p>
<p> 第四步：设计轮播图片控制器。很多时候轮播图片还具有一个向前播放和向后播放的控制器。在 Carousel 中通过 carousel-control 样式配合 left 和 right 来实现。其中left表示向前播放，right表示向后播放。其同样放在carousel容器内：</p>
<pre><code> &lt;div id=&quot;slidershow&quot; class=&quot;carousel&quot;&gt;
    &lt;!-- 设置图片轮播的顺序 --&gt;
    &lt;ol class=&quot;carousel-indicators&quot;&gt;
       …
    &lt;/ol&gt;
    &lt;!-- 设置轮播图片 --&gt;
    &lt;div class=&quot;carousel-inner&quot;&gt;
        …
    &lt;/div&gt;
    &lt;!-- 设置轮播图片控制器 --&gt;
       &lt;a class=&quot;left carousel-control&quot; href=&quot;&quot; &gt;
        &lt;span class=&quot;glyphicon glyphicon-chevron-left&quot;&gt;&lt;/span&gt;
        &lt;/a&gt;
    &lt;a class=&quot;right carousel-control&quot; href=&quot;&quot;&gt;
        &lt;span class=&quot;glyphicon glyphicon-chevron-right&quot;&gt;&lt;/span&gt;
    &lt;/a&gt;
&lt;/div&gt;
</code></pre><p>通过两个 a 链接然后在内部定义要显示的小图标，一个是向前，一个是向后。<br>这两个图标都显示在图片容器的上面（z-index的值大于carousel-inner的）。</p>
<p>本文转载自 <a href="http://mp.weixin.qq.com/s?__biz=MjM5MDA2MTI1MA==&amp;mid=2649084355&amp;idx=1&amp;sn=b8f8542961fb22ec79f08d11712c6efb&amp;chksm=be5bf66e892c7f7805bc5798806a4b15e9a21de68a32996b34a37e0ef8b63ff574cef09ae2a2&amp;mpshare=1&amp;scene=23&amp;srcid=1120rw2qKTy789hDAF6IAO5R#rd" target="_blank" rel="noopener">http://mp.weixin.qq.com/s?__biz=MjM5MDA2MTI1MA==&amp;mid=2649084355&amp;idx=1&amp;sn=b8f8542961fb22ec79f08d11712c6efb&amp;chksm=be5bf66e892c7f7805bc5798806a4b15e9a21de68a32996b34a37e0ef8b63ff574cef09ae2a2&amp;mpshare=1&amp;scene=23&amp;srcid=1120rw2qKTy789hDAF6IAO5R#rd</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-正则表达式应用——实例应用"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2016/04/02/正则表达式应用——实例应用/"
    >正则表达式应用——实例应用</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2016/04/02/正则表达式应用——实例应用/" class="article-date">
  <time datetime="2016-04-02T02:14:35.000Z" itemprop="datePublished">2016-04-02</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h3 id="正则表达式应用——实例应用"><a href="#正则表达式应用——实例应用" class="headerlink" title="正则表达式应用——实例应用"></a>正则表达式应用——实例应用</h3><p>1.验证用户名和密码：（”^[a-zA-Z]\w{5,15}$”）正确格式：”[A-Z][a-z]_[0-9]”组成,并且第一个字必须为字母6~16位；</p>
<p>2.验证电话号码：（”^(\d{3,4}-)\d{7,8}$”）正确格式：xxx/xxxx-xxxxxxx/xxxxxxxx；</p>
<p>3.验证手机号码：”^1[3|4|5|7|8][0-9]\d{8}$”；</p>
<p>4.验证身份证号（15位或18位数字）：”^\d{14}[[0-9],0-9xX]”；</p>
<p>5.验证Email地址：(“^\w+([-+.]\w+)<em>@\w+([-.]\w+)</em>.\w+([-.]\w+)*$”)；</p>
<p>6.只能输入由数字和26个英文字母组成的字符串：(“^[A-Za-z0-9]+$”) ;</p>
<p>7.整数或者小数：^[0-9]+([.][0-9]+){0,1}$</p>
<p>8.只能输入数字：”^[0-9]*$”。</p>
<p>9.只能输入n位的数字：”^\d{n}$”。</p>
<p>10.只能输入至少n位的数字：”^\d{n,}$”。</p>
<p>11.只能输入m~n位的数字：”^\d{m,n}$”。</p>
<p>12.只能输入零和非零开头的数字：”^(0|[1-9][0-9]*)$”。</p>
<p>13.只能输入有两位小数的正实数：”^[0-9]+(.[0-9]{2})?$”。</p>
<p>14.只能输入有1~3位小数的正实数：”^[0-9]+(.[0-9]{1,3})?$”。</p>
<p>15.只能输入非零的正整数：”^+?[1-9][0-9]*$”。</p>
<p>16.只能输入非零的负整数：”^-[1-9][0-9]*$”。</p>
<p>17.只能输入长度为3的字符：”^.{3}$”。</p>
<p>18.只能输入由26个英文字母组成的字符串：”^[A-Za-z]+$”。</p>
<p>19.只能输入由26个大写英文字母组成的字符串：”^[A-Z]+$”。</p>
<p>20.只能输入由26个小写英文字母组成的字符串：”^[a-z]+$”。</p>
<p>21.验证是否含有^%&amp;’,;=?$\”等字符：”[%&amp;’,;=?$\^]+”。</p>
<p>22.只能输入汉字：”^[\u4e00-\u9fa5]{0,}$”。</p>
<p>23.验证URL：”^http://([\w-]+.)+[\w-]+(/[\w-./?%&amp;=]*)?$”。</p>
<p>24.验证一年的12个月：”^(0?[1-9]|1[0-2])$”正确格式为：”01”～”09”和”10”～”12”。</p>
<p>25.验证一个月的31天：”^((0?[1-9])|((1|2)[0-9])|30|31)$”正确格式为；”01”～”09”、”10”～”29”和“30”~“31”。</p>
<p>26.获取日期正则表达式：\d{4}[年|-|.]\d{\1-\12}[月|-|.]\d{\1-\31}日?    评注：可用来匹配大多数年月日信息。</p>
<p>27.匹配双字节字符(包括汉字在内)：[^\x00-\xff]      评注：可以用来计算字符串的长度（一个双字节字符长度计2，ASCII字符计1）</p>
<p>28.匹配空白行的正则表达式：\n\s*\r       评注：可以用来删除空白行</p>
<p>29.匹配HTML标记的正则表达式：&lt;(\S<em>?)[^&gt;]</em>&gt;.<em>?&lt;/&gt;|&lt;.</em>? /&gt;   评注：网上流传的版本太糟糕，上面这个也仅仅能匹配部分，对于复杂的嵌套标记依旧无能为力</p>
<p>31.匹配首尾空白字符的正则表达式：^\s<em>|\s</em>$      评注：可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式</p>
<p>33.匹配网址URL的正则表达式：[a-zA-z]+://[^\s]*     评注：网上流传的版本功能很有限，上面这个基本可以满足需求</p>
<p>35.匹配帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$  评注：表单验证时很实用</p>
<p>37.匹配腾讯QQ号：[1-9][0-9]{4,}      评注：腾讯QQ号从10 000 开始</p>
<p>39.匹配中国邮政编码：[1-9]\d{5}(?!\d)     评注：中国邮政编码为6位数字</p>
<p>41.匹配ip地址：([1-9]{1,3}.){3}[1-9]。   评注：提取ip地址时有用</p>
<p>43.匹配MAC地址：([A-Fa-f0-9]{2}\:){5}[A-Fa-f0-9]</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="浅聊:yarn-npm"
  class="article article-type-浅聊:yarn"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2016/03/29/npm/"
    >npm</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2016/03/29/npm/" class="article-date">
  <time datetime="2016-03-29T05:14:18.000Z" itemprop="datePublished">2016-03-29</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h3 id="浅聊-Yarn-vs-npm"><a href="#浅聊-Yarn-vs-npm" class="headerlink" title="浅聊:Yarn vs npm"></a>浅聊:Yarn vs npm</h3><p>原文链接<a href="https://www.sitepoint.com/yarn-vs-npm/?utm_source=javascriptweekly&amp;utm_medium=email" target="_blank" rel="noopener"> https://www.sitepoint.com/yarn-vs-npm/?utm_source=javascriptweekly&amp;utm_medium=email</a></p>
<p>译文    <a href="http://www.zcfy.cc/article/yarn-vs-npm-everything-you-need-to-know-1484.html" target="_blank" rel="noopener">http://www.zcfy.cc/article/yarn-vs-npm-everything-you-need-to-know-1484.html</a></p>
<p>Yarn 是 Facebook, Google, Exponent 和 Tilde 开发的一款新的 JavaScript 包管理工具。就像我们可以从官方文档了解那样，它的目的是解决这些团队使用 npm 面临的少数问题，即：</p>
<ul>
<li>安装的时候无法保证速度/一致性</li>
<li>安全问题，因为 npm 安装时允许运行代码</li>
</ul>
<p>但请不要惊慌！它并没有试图完全取代 npm。Yarn 同样是一个从 npm 注册源获取模块的新的 CLI 客户端。注册的方式不会有任何变化 —— 你同样可以正常获取与发布包。</p>
<p>是否每个人现在都要跳上 Yarn 这辆被大肆宣传的列车？又或者你根本没机会碰到 npm 的这些问题。本篇文章将会比较 npm 与 Yarn，最终你可以决定哪款更适合你。</p>
<h5 id="Yarn-vs-npm-功能差异"><a href="#Yarn-vs-npm-功能差异" class="headerlink" title="Yarn vs npm: 功能差异"></a>Yarn vs npm: 功能差异</h5><p>乍一看 Yarn 与 npm 很类似，但通过引擎的对比就能察觉 Yarn 的不同。</p>
<h6 id="yarn-lock-文件"><a href="#yarn-lock-文件" class="headerlink" title="yarn.lock 文件"></a>yarn.lock 文件</h6><p>npm 和 Yarn 都使用 <code>package.json</code> 来跟踪项目的依赖，版本号并非一直准确，因为你可以定义版本号范围，这样你可以选择一个主版本和次要版本的包，但让 npm 安装最新的补丁也许可以修改一些 bug。</p>
<p>理想状态下使用语义化版本发布补丁不会包含大的变化，但不幸的是这必非真理。npm 的这种策略可能导致两台拥有相同 <code>package.json</code> 文件的机子安装了不同版本的包，这可能导致一些错误。</p>
<p>为了避免包版本的错误匹配，一个确定的安装版本被固定在一个锁文件中。每次模块被添加时，Yarn 就会创建（或更新）<code>yarn.lock</code> 文件，这样你就可以保证其它机子也安装相同版本的包，同时包含了 <code>package.json</code> 中定义的一系列允许的版本。</p>
<p>在 npm 中同样可以使用 <code>npm shrinkwrap</code> 命令来生成一个锁文件，这样在使用 <code>npm install</code> 时会在读取 <code>package.json</code> 前先读取这个文件，就像 Yarn 会先读取<code>yarn.lock</code> 一样。这里的区别是 Yarn 总会自动更新 <code>yarn.lock</code>，而 npm 需要你重新操作。</p>
<h6 id="并行安装"><a href="#并行安装" class="headerlink" title="并行安装"></a>并行安装</h6><p>每当 npm 或 Yarn 需要安装一个包时，它会进行一系列的任务。在 npm 中这些任务是按包的顺序一个个执行，这意味着必须等待上一个包被完整安装才会进入下一个；Yarn 则并行的执行这些任务，提高了性能。</p>
<p>为了比较，我在没有使用 shrinkwrap/yarn.lock 的方式以及清理了缓存下使用 npm 与 Yarn 安装 express，总共安装了 42 个依赖。</p>
<ul>
<li>npm: 9 s</li>
<li>Yarn: 1.37 s</li>
</ul>
<p>我无法相信自己的眼睛，所以重复以上步骤，但得到相同结果。接着我安装 gulp 进行测试，总共安装了 195 个依赖。</p>
<ul>
<li>npm: 11 s</li>
<li>Yarn: 7.81 s</li>
</ul>
<p>似乎根据所需要安装的包的数量而有所不同，但 Yarn 依旧比较快。</p>
<h6 id="清晰的输出"><a href="#清晰的输出" class="headerlink" title="清晰的输出"></a>清晰的输出</h6><p>npm 默认情况下非常冗余，例如使用 <code>npm install</code> 时它会递归列出所有安装的信息；而 Yarn 则一点也不冗余，当可以使用其它命令时，它适当的使用 emojis 表情来减少信息（Windows 除外）。</p>
<h6 id="Yarn-vs-npm-CLI-的差异"><a href="#Yarn-vs-npm-CLI-的差异" class="headerlink" title="Yarn vs npm: CLI 的差异"></a>Yarn vs npm: CLI 的差异</h6><p>除了一些功能差异，Yarn 命令也存在一些区别。例如移除或修改了一些 npm 命令以及添加了几个有趣的命令。</p>
<h6 id="yarn-global"><a href="#yarn-global" class="headerlink" title="yarn global"></a>yarn global</h6><p>不像 npm 添加 <code>-g</code>或 <code>--global</code> 可以进行全局安装，Yarn 使用的是 <code>global</code> 前缀。不过与 npm 类似，项目依赖不推荐全局安装。</p>
<p><code>global</code> 前缀只能用于 <code>yarn add</code>, <code>yarn bin`</code>, yarn ls<code>和</code>yarn remove<code>，除</code>yarn add `外，这些命令都和 npm 等效。</p>
<h6 id="yarn-install"><a href="#yarn-install" class="headerlink" title="yarn install"></a>yarn install</h6><p><code>npm install</code> 命令会根据 <code>package.json</code> 安装依赖以及允许你添加新的模块；<code>yarn install</code> 仅会按 <code>yarn.lock</code> 或 <code>package.json</code> 里面的依赖顺序来安装模块。</p>
<h6 id="yarn-add-–dev"><a href="#yarn-add-–dev" class="headerlink" title="yarn add [–dev]"></a>yarn add [–dev]</h6><p>与 <code>npm install</code> 类似，<code>yarn add</code> 允许你添加与安装模块，就像命令的名称一样，添加依赖意味着也会算定将依赖写入 <code>package.json</code>，类似 <code>npm</code>的 <code>--save</code> 参数；<code>Yar 的--dev `</code>参数则是添加开发依赖，类似 npm 的 <code></code>–save-dev 参数。</p>
<h6 id="yarn-licenses-ls-generate-disclaimer"><a href="#yarn-licenses-ls-generate-disclaimer" class="headerlink" title="yarn licenses [ls|generate-disclaimer]"></a>yarn licenses [ls|generate-disclaimer]</h6><p>npm 没有类似命令来方便编写自己的包。 <code>yarn licenses ls</code>  列出所有已安装包的许可协议。 <code>yarn licenses generate-disclaimer</code> 生成包含已安装包许可协议的免责声明。某些协议要求使用者必须在项目中包含该协议，这时候该命令将变得非常好用。</p>
<h6 id="yarn-why"><a href="#yarn-why" class="headerlink" title="yarn why"></a>yarn why</h6><p>该命令会查找依赖关系并找出为什么会将某些包安装在你的项目中。也许你明确为什么添加，也许它只是你安装包中的一个依赖，<code>yarn why</code> 可以帮你弄找出。</p>
<h6 id="yarn-upgrade"><a href="#yarn-upgrade" class="headerlink" title="yarn upgrade"></a>yarn upgrade</h6><p>该命令会根据符合 <code>package.json</code> 设定的规则而不是 <code>yarn.lock</code> 定义的确切版本来将包更新到最新版本。如果想用 npm 来实现相同目的，可以这样执行：</p>
<pre><code>rm -rf node_modules
npm install
</code></pre><p>不要将该命令与 <code>npm update</code> 混淆，它指的是更新到自己的最新版。</p>
<h6 id="yarn-generate-lock-entry"><a href="#yarn-generate-lock-entry" class="headerlink" title="yarn generate-lock-entry"></a>yarn generate-lock-entry</h6><p><code>yarn generate-lock-entry</code> 会基于 <code>package.json</code> 设置的依赖生成 <code>yarn.lock</code> 文件，该命令与 <code>npm shrinkwrap</code> 类似，但应该小心使用，因为通过 <code>yarn add</code> 和 <code>yarn upgrade</code> 命令添加或更新依赖时会自动更新生成该锁文件。</p>
<h5 id="稳定性与可靠性"><a href="#稳定性与可靠性" class="headerlink" title="稳定性与可靠性"></a>稳定性与可靠性</h5><p>Yarn 被炒得这么火热会不会有问题？它正式发布当天就收到很多问题反馈，但官方处理问题的速度极快。这些表明社区正努力开发并修复bug。查看问题反馈的数量和类型可以发现 Yarn 在大多数用户的机子上表现的很稳定，但可能个别机子会有问题。</p>
<p>请注意虽然一个包管理器可能对你的项目非常重要，但它仅仅只是个工具，如果出了状况，恢复包不会困难，也并非要回归 npm。</p>
<h5 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h5><p>也许你了解 Node.js 与 io.js 之间的历史。简单来说：io.js 是 Node.js 一些核心开发者因为项目管理上的分歧而独立出来创建的分支。不同的是，io.js 选择了开放式管理，在不到一年的时间时，两支团队达成协议，io.js 被合并回 Node.js，无论对错，它为 Node.js 带来了相当多不错的功能。</p>
<p>我看到 npm 与 Yarn 和它们有着类似的模式，不过 Yarn 不是分支，它解决了 npm 的一些缺陷。如果 npm 从中学到东西并邀请 Facebook，Google 或其它 Yarn 的贡献者们来一起提升 npm 不是很酷吗？虽然言之过早，但我期待它会发生。</p>
<p>无论哪种结果，Yarn 前途一片光明。社区得到别人对新工具的赞扬后似乎很兴奋，不幸的是，社区并没有提供路线图，所以我不确定 Yarn 是否为我们准备了其它惊喜。</p>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>相比 npm 的默认配置，Yarn 获得不少赞同。我们可以方便生成锁文件，安装包时非常迅速并且他们会自动添加进 package.json，同时安装与使用 Yarn 的影响也很小，你可以直接在一个项目上尝试看它是否可以工作，这使得 Yarn 可以完美替代 npm。</p>
<p>我绝对推荐在一个项目中尽早使用 Yarn，如果你对安装和使用新软件持谨慎态度，可以等待几个月。毕竟 npm 久经考验，它在软件开发领域也有存在的价值。</p>
<p>使用你正确等待 npm 完成包的安装，也许这是阅读迁移指南的最佳时刻 ;)</p>
<p>你怎么想呢？你是否已经在使用 Yarn？你是否将要尝试？或者这只是一个已经支离破碎的生态系统的进一步破碎？请在下面评论区留下你的观点。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-预加载-懒加载-demo展示"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2016/03/26/预加载-懒加载-demo展示/"
    >预加载+懒加载-demo展示</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2016/03/26/预加载-懒加载-demo展示/" class="article-date">
  <time datetime="2016-03-26T02:33:25.000Z" itemprop="datePublished">2016-03-26</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h3 id="预加载-amp-amp-懒加载-demo展示"><a href="#预加载-amp-amp-懒加载-demo展示" class="headerlink" title="预加载&amp;&amp;懒加载-demo展示"></a>预加载&amp;&amp;懒加载-demo展示</h3><p>一  预加载</p>
<p>html </p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
    &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;预加载&lt;/title&gt;
    &lt;style type=&quot;text/css&quot;&gt;
        #box{
            width: 800px;
            }

    &lt;/style&gt;
    &lt;/head&gt;
    &lt;body&gt;
    &lt;div id=&quot;box&quot;&gt;&lt;/div&gt;
&lt;/body&gt;
</code></pre><p>步骤：</p>
<p>// 步骤：1 存一组图片到数组中</p>
<p>// 2 因为需要先将图片一张张加载，所以需要利用for循环。</p>
<p>// 3 图片加载前，需要先新建一个图片对象，和图片路径</p>
<p>// 4 每次新建一张图片对象，获取一个图片路径，进行加载（在此，利用index++实现每次加载下一张)</p>
<p>// 5 加载后，将图片存到一盒新的空数组中。</p>
<p>// 6 将数组添加到HTML文档的元素中</p>
<p>js:</p>
<pre><code>//图片
var imgarr=[&quot;http://d.hiphotos.baidu.com/image/h%3D200/    sign=2a5a59df74094b36c4921ced93cd7c00/18d8bc3eb13533fa997c342eaad3fd1f40345be3.jpg&quot;,&quot;http://g.hiphotos.baidu.com/image/pic/item/5882b2b7d0a20cf4c7e9bd9973094b36acaf997f.jpg&quot;,&quot;http://e.hiphotos.baidu.com/image/h%3D200/sign=c6fd3ae21d178a82d13c78a0c602737f/4e4a20a4462309f7d4896d3c710e0cf3d7cad63e.jpg&quot;,&quot;http://g.hiphotos.baidu.com/image/pic/item/0eb30f2442a7d9338e2370bcaf4bd11372f00171.jpg&quot;,&quot;http://f.hiphotos.baidu.com/image/pic/item/f11f3a292df5e0fe8429ca47596034a85edf7246.jpg&quot;,&quot;http://g.hiphotos.baidu.com/image/pic/item/08f790529822720e62e61b4e7ecb0a46f21fab5e.jpg&quot;,&quot;http://g.hiphotos.baidu.com/zhidao/pic/item/267f9e2f07082838e161fffabd99a9014d08f1f4.jpg&quot;];



var index=0;
var arr=[];
for (var i = 0; i &lt; imgarr.length; i++) {
var newobj=new Image();
newobj.src=imgarr[i];
newobj.onload=function(){
index++;
arr.push(this); // this指代的是事件的主体，也就是newobj, 而事件的主体我们一般可以用this来指代
// 当index++ 大于我们的imgarr.length时候，也就是加载完成的时候，加载条应该显示100%；
if (index&gt;=imgarr.length) {
box.innerHTML=Math.ceil(index/imgarr.length*100)+&quot;%&quot;;
loadingover(); }  }  }

function loadingover(){
    box.innerHTML=&quot;&quot;;

    for (var i = 0; i &lt; arr.length; i++){
    box.appendChild(arr[i]);   }  }
</code></pre><p>二 懒加载</p>
<p>html </p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;延时加载&lt;/title&gt;
    &lt;style type=&quot;text/css&quot;&gt;
    #div1{border:1px red solid;
               width: 80%;
               position: absolute;
               top: 500px;
               }
    #div2{border:1px red solid;
    width: 80%;
    position: absolute;
    top: 2000px;
    }
    #div3{
    border:1px red solid;
    width: 80%;
    position: absolute;
    top: 3000px;
    }
    img{
    /*img需要给定宽*/
    width: 600px;    
    height: 400px;
    }
    &lt;/style&gt;
    &lt;/head&gt;
    &lt;body&gt;
    &lt;div class=&quot;big&quot; id=&quot;div1&quot;&gt;&lt;img c=&quot;../img/18.jpg&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;big&quot; id=&quot;div2&quot;&gt;&lt;img c=&quot;../img/19.jpg&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;big&quot; id=&quot;div3&quot;&gt;&lt;img c=&quot;../img/20.jpg&quot;&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>js</p>
<pre><code>var img=document.getElementsByTagName(&apos;img&apos;);

// 图片在定位时，要找到元素最外层定位的父元素，并获取这两个元素之间的高度，一个网页会有很多个延时加载的元素，所以，可以用函数传参来封装函数。
function offset(element){
var t=element.offsetTop;
// 因为不知道子元素外有多少父级，利用while循环来获取子元素到最外层元素间的高度
 while(element){
 t+=element.offsetTop;
 element=element.offsetParent; //让参数element一级一级往上，直到element没有定位的父级为止，此时，while里的element条    件为假，循环停止，得到最后的t值
 }
 return {top:t} // 返回t值 这里的top 是一个对象，我们可以随便定义对象名
 }
// 寻找执行条件 并执行要达到的效果
window.onscroll=function(){
var scrolltop=document.body.scrollTop||document.documentElement.scrollTop;
var ch=document.documentElement.clientHeight;
// 循环每一张图片
for (var i = 0; i &lt; img.length; i++) {
//通过传参获取img的offsetHeight
var oh=offset(img[i]).top;
// if 判断条件 来判断图片在什么时候加载
if (oh&lt;scrolltop+ch-200) {
img[i].src=img[i].getAttribute(&quot;c&quot;);
}
}
}
&lt;/script&gt;
</code></pre> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-三分钟学会css3中的flexbox布局"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2016/03/17/三分钟学会css3中的flexbox布局/"
    >三分钟学会css3中的flexbox布局</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2016/03/17/三分钟学会css3中的flexbox布局/" class="article-date">
  <time datetime="2016-03-17T10:44:24.000Z" itemprop="datePublished">2016-03-17</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h3 id="三分钟学会css3中的flexbox布局"><a href="#三分钟学会css3中的flexbox布局" class="headerlink" title="三分钟学会css3中的flexbox布局"></a>三分钟学会css3中的flexbox布局</h3><p>这篇文章里我们将学习CSS里flexbox布局的几个最重要的概念，通过学习flexbox布局，你会发现以往遇到的所有的关于布局的问题，现在都可以轻松解决了。<br>我们将只关注几个核心概念，等这些核心知识掌握之后，你可以再慢慢的学习那些不重要的相关知识。</p>
<ol>
<li><p>容器和容器里的元素<br>flexbox布局的两个最重要的概念是容器(蓝色)和容器里的子元素(红色)。在本文的例子中，容器和它的子元素都是div。<br>横向布局<br>为了实现flex布局，我们需要在容器的CSS里添加如下代码：</p>
<pre><code>.container {
    display: flex;
}
</code></pre></li>
</ol>
<p>对于容器里面的子元素，我们什么都不需要做。它们会自动的按横坐标一字排开。<br>纵向布局<br>在上面的演示中，缺省排列是沿着横坐标方向的，还有一个方向是纵坐标，这个坐标轴的概念在理解flex布局中非常重要。<br>当我们在容器的CSS里添加 flex-direction: column.后，子元素的排列方向就会发生变化。</p>
<pre><code>.container {
display: flex;
flex-direction: column;
}
</code></pre><p>现在，子元素的排列方向是沿着纵坐标的方向了。</p>
<ol start="2">
<li><p>调整子元素的对齐方式<br>现在我们让子元素重新横向布局，这需要将flex-direction属性的值从 column改成 row, 子元素就会重新回到横向布局。<br>调整子元素的对齐方式，我需要使用justify-content 和 align-items 这两个属性，它们控制着子元素的在横向和纵向两方面的定位和对齐方式。<br>下面我们将要使用justify-content属性让所有子元素都居中对齐：</p>
<pre><code>.container {
display: flex;
flex-direction: row;
justify-content: center;
}
</code></pre><p>使用 align-items 属性来控制子元素的竖向对齐方式：</p>
<pre><code>.container {
    display: flex;
flex-direction: row;
justify-content: center;
align-items: center;
}
</code></pre></li>
</ol>
<p>下面的列表中显示了justify-content 和 align-items属性可以使用的属性值：</p>
<pre><code>justify-content:
* flex-start (default)
* flex-end
* center
* space-between
* space-around

align-items:
* flex-start (default)
 * flex-end
* center
* baseline
* stretch
</code></pre><p>建议大家将justify-content 、align-items和flex-direction几个属性混合使用，相互配合，看看都会达到什么样的布局效果。这样你才能正确的理解flexbox布局的布局方式。</p>
<ol start="3">
<li>子元素<br>最后，我们将学习针对子元素的一些应对flexbox布局的CSS属性。<br>比如我们想调整第一个子元素的位置，我们可以给他添加CSS属性 align-self，这个属性的属性值是和align-items是一样的用法:</li>
</ol>
<pre><code>.item1 {
  align-self: flex-end;
}
</code></pre><p>关于flexbox布局的知识远比本文介绍的这些要丰富，这总重要的几个知识点就是这些，掌握了它们，再学些其他的用法就容易多了。</p>
<p>本文转自 <a href="http://mp.weixin.qq.com/s?__biz=MjM5MDA2MTI1MA==&amp;mid=2649084363&amp;idx=1&amp;sn=bf9c5f2440caad7a8b5746894d16f3be&amp;chksm=be5bf666892c7f709a6effe503bceaf82e1fae250f9a34d1ce168c48674f539fbdd077aa2d4d&amp;mpshare=1&amp;scene=23&amp;srcid=1120l3DfEjLOj10JXjmtwnkf#rd" target="_blank" rel="noopener">http://mp.weixin.qq.com/s?__biz=MjM5MDA2MTI1MA==&amp;mid=2649084363&amp;idx=1&amp;sn=bf9c5f2440caad7a8b5746894d16f3be&amp;chksm=be5bf666892c7f709a6effe503bceaf82e1fae250f9a34d1ce168c48674f539fbdd077aa2d4d&amp;mpshare=1&amp;scene=23&amp;srcid=1120l3DfEjLOj10JXjmtwnkf#rd</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="深入理解css3-帧动画"
  class="article article-type-深入理解css3"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2016/03/12/帧动画/"
    >帧动画</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2016/03/12/帧动画/" class="article-date">
  <time datetime="2016-03-12T06:06:22.000Z" itemprop="datePublished">2016-03-12</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h3 id="深入理解CSS3-Animation-帧动画"><a href="#深入理解CSS3-Animation-帧动画" class="headerlink" title="深入理解CSS3 Animation 帧动画"></a>深入理解CSS3 Animation 帧动画</h3><p>我们知道CSS3的Animation有八个属性</p>
<p>animation-name</p>
<p>animation-duration</p>
<p>animation-delay</p>
<p>animation-iteration-count</p>
<p>animation-direction</p>
<p>animation-play-state</p>
<p>animation-fill-mode</p>
<p>animation-timing-function</p>
<p>其中1-7大多都有介绍，但是animation-timing-function是控制时间的属性</p>
<p>在取值中除了常用到的 三次贝塞尔曲线 以外，还有个让人比较困惑的 steps() 函数</p>
<p>animation默认以ease方式过渡，它会在每个关键帧之间插入补间动画，所以动画效果是连贯性的</p>
<p>除了ease，linear、cubic-bezier之类的过渡函数都会为其插入补间。但有些效果不需要补间，只需要关键帧之间的跳跃，这时应该使用steps过渡方式</p>
<p>animation-timing-function 规定动画的速度曲线</p>
<p><img src="http://images0.cnblogs.com/blog/329084/201507/110906325499781.png" alt="http://images0.cnblogs.com/blog/329084/201507/110906325499781.png"></p>
<p>以上w3school网站上给的使用方法，但是漏掉一个很重要的 steps</p>
<p>简单的来说，我们一直使用animation基本都是实现线性渐变的动画</p>
<p>如</p>
<p>位置在固定的时间从起点到终点</p>
<p>尺寸在固定的时间线性变化</p>
<p>颜色的线性改变等等</p>
<p>看效果 线性动画</p>
<p>截取CSS如下</p>
<pre><code>.test1 {
width: 90px;
height: 60px;
-webkit-animation-name: skyset;
-webkit-animation-duration: 2000ms;
-webkit-animation-iteration-count: infinite; /*无限循环*/
-webkit-animation-timing-function: linear;}@-webkit-keyframes skyset {
0% { background: red;}
50%{ background: blue}
100% {background: yellow;}}
</code></pre><p> timing-function:linear 定义的是一个匀速变化的动画，就是在2秒内，从红色过度到蓝色到黄色，是一个很线性的颜色变化</p>
<p>如果要实现帧动画效果而不是线性的变化就需要引入step这个值了，换句话就是没有过渡的效果，而是一帧帧的变化</p>
<p>同样可以看测试 帧动画</p>
<p> 理解steps</p>
<p>steps 函数指定了一个阶跃函数</p>
<p>第一个参数指定了时间函数中的间隔数量（必须是正整数）</p>
<p>第二个参数可选，接受 start 和 end 两个值，指定在每个间隔的起点或是终点发生阶跃变化，默认为 end。</p>
<p>step-start等同于steps(1,start)，动画分成1步，动画执行时为开始左侧端点的部分为开始；</p>
<p>step-end等同于steps(1,end)：动画分成一步，动画执行时以结尾端点为开始，默认值为end。</p>
<p>看看W3C的规范 transition-timing-function</p>
<p> steps第一个参数的错误的理解：</p>
<p>steps(5，start)</p>
<p>steps() 第一个参数 number 为指定的间隔数，即把动画分为 n 步阶段性展示，估计大多数人理解就是keyframes写的变化次数</p>
<p>例如:</p>
<pre><code>@-webkit-keyframes circle {
    0% {}
    25%{}
    50%{}
    75%{}
    100%{}
 }
</code></pre><p>我之前也一直认为steps(5，start）中的5 就是指的keyframes中的0% 25% 50% 75% 100% 分成5个间隔等分</p>
<p>为什么会出现这种理解错误，我们看一个例子</p>
<p>keyframes的关键帧是只有2个规则的时候，假如我们有一张400px长度的雪碧图</p>
<pre><code>@-webkit-keyframes circle {
    0% {background-position-x: 0;}
    100%{background-position-x: -400px;}
 }
</code></pre><p> 此刻设置steps(5，start）那么会发现5张图会出现帧动画的效果，因为steps中的5把 0% – 100%的规则，内部</p>
<p> 分成5个等分</p>
<p>实际内部会执行这样一个关键帧效果</p>
<pre><code>@-webkit-keyframes circle {
    0% {background-position-x: 0;}
    25% {background-position-x: -100px;}
    50% {background-position-x:-200px;}
    75%{background-position-x: -300px;}
    100%{background-position-x: -400px;}
 }
</code></pre><p> 将这个规则稍微修改下，加入一个50%的状态</p>
<pre><code>@-webkit-keyframes circle {
   0% {background-position-x: 0;}
   50% {background-position-x: -200px;}
   100%{background-position-x: -400px;}
}
</code></pre><p>那么同样用steps(5，start）效果就会乱套</p>
<p>此刻你会很迷惑，所以关键要理解第一个参数的针对点，首先引入一个核心点：</p>
<p>timing-function 作用于每两个关键帧之间，而不是整个动画</p>
<p>那么第一个参数很好理解了，steps的设置都是针对两个关键帧之间的，而非是整个keyframes，所以第一个参数对 - 次数对应了每次steps的变化</p>
<p>换句话说也是 0-25 之间变化5次，  25-50之间 变化5次 ，50-75 之间变化5次，以此类推</p>
<p>第二个参数可选，接受 start 和 end 两个值，指定在每个间隔的起点或是终点发生阶跃变化，默认为 end</p>
<p>通过案例看下 step-start，step-end 的区别</p>
<pre><code>@-webkit-keyframes circle {
    0% {background: red}
    50%{background: yellow}
    100% {background: blue}
}
</code></pre><p>step-start ： 黄色与蓝色相互切换</p>
<p>step-end  ： 红色与黄色相互切换</p>
<p>2个参数都会选择性的跳过前后部分，start跳过0%，end跳过100%</p>
<p>step-start在变化过程中，都是以下一帧的显示效果来填充间隔动画，所以0% 到 50%  直接就显示了黄色yellow</p>
<p>step-end与上面相反，都是以上一帧的显示效果来填充间隔动画，所以0% 到 50% 直接就显示了红色red</p>
<p>引用w3c的一张step的工作机制图</p>
<p><img src="http://images.cnitblog.com/i/596159/201406/091121212334792.png" alt="http://images.cnitblog.com/i/596159/201406/091121212334792.png"></p>
<p>总结：</p>
<p>steps函数，它可以传入两个参数，第一个是一个大于0的整数，他是将间隔动画等分成指定数目的小间隔动画，然后根据第二个参数来决定显示效果。</p>
<p>第二个参数设置后其实和step-start，step-end同义，在分成的小间隔动画中判断显示效果。可以看出：steps(1, start) 等于step-start，steps(1,end)等于step-end</p>
<p>最核心的一点就是：timing-function 作用于每两个关键帧之间，而不是整个动画</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-三张图搞懂JavaScript的原型对象与原型链"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2016/02/29/三张图搞懂JavaScript的原型对象与原型链/"
    >三张图搞懂JavaScript的原型对象与原型链</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2016/02/29/三张图搞懂JavaScript的原型对象与原型链/" class="article-date">
  <time datetime="2016-02-29T12:46:35.000Z" itemprop="datePublished">2016-02-29</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h3 id="三张图搞懂JavaScript的原型对象与原型链"><a href="#三张图搞懂JavaScript的原型对象与原型链" class="headerlink" title="三张图搞懂JavaScript的原型对象与原型链"></a>三张图搞懂JavaScript的原型对象与原型链</h3><p>原文地址：<a href="三张图搞懂JavaScript的原型对象与原型链">三张图搞懂JavaScript的原型对象与原型链</a></p>
<p>对于新人来说，JavaScript的原型是一个很让人头疼的事情，一来prototype容易与<strong>proto</strong>混淆，二来它们之间的各种指向实在有些复杂，其实市面上已经有非常多的文章在尝试说清楚，有一张所谓很经典的图，上面画了各种线条，一会连接这个一会连接那个，说实话我自己看得就非常头晕，更谈不上完全理解了。所以我自己也想尝试一下，看看能不能把原型中的重要知识点拆分出来，用最简单的图表形式说清楚。</p>
<p>我们知道原型是一个对象，其他对象可以通过它实现属性继承。但是尼玛除了prototype，又有一个<strong>proto</strong>是用来干嘛的？长那么像，让人怎么区分呢？它们都指向谁，那么混乱怎么记啊？原型链又是什么鬼？相信不少初学者甚至有一定经验的老鸟都不一定能完全说清楚，下面用三张简单的图，配合一些示例代码来理解一下。</p>
<p>1、prototype和<strong>proto</strong>的区别</p>
<p><img src="http://ac-myg6wstv.clouddn.com/2e7817d676e605e54e62.png" alt="http://ac-myg6wstv.clouddn.com/2e7817d676e605e54e62.png"></p>
<pre><code>var a = {};
console.log(a.prototype); //undefined
console.log(a.__proto__);  //Object {}

var b = function(){}
console.log(b.prototype); //b {}
console.log(b.__proto__);  //function() {}
</code></pre><p>2、<strong>proto</strong>属性指向谁</p>
<p><img src="http://ac-myg6wstv.clouddn.com/414693e5821245adeb86.png" alt="http://ac-myg6wstv.clouddn.com/414693e5821245adeb86.png"></p>
<pre><code>/*1、字面量方式*/
var a = {};
console.log(a.constructor); //function Object() { [native code] } (即构造器Object）
console.log(a.__proto__ === a.constructor.prototype); //true

/*2、构造器方式*/
var A = function (){}; var a = new A();
console.log(a.constructor); // function(){}（即构造器function A）
console.log(a.__proto__ === a.constructor.prototype); //true

/*3、Object.create()方式*/
var a1 = {a:1} 
var a2 = Object.create(a1);
console.log(a2.constructor); //function Object() { [native code] } (即构造器Object)
console.log(a2.__proto__ === a1);// true 
console.log(a2.__proto__ === a2.constructor.prototype); //false（此处即为图1中的例外情况）
</code></pre><h3 id="三、什么是原型链"><a href="#三、什么是原型链" class="headerlink" title="三、什么是原型链"></a>三、什么是原型链</h3><p><img src="http://ac-myg6wstv.clouddn.com/e8f4cc45af11650de1f8.png" alt="http://ac-myg6wstv.clouddn.com/e8f4cc45af11650de1f8.png">    </p>
<pre><code>var A = function(){};
var a = new A();
console.log(a.__proto__); //Object {}（即构造器function A 的原型对象）
console.log(a.__proto__.__proto__); //Object {}（即构造器function Object 的原型对象）
console.log(a.__proto__.__proto__.__proto__); //null
</code></pre> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-使用CSS完成元素居中的七种方法"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2016/02/22/使用CSS完成元素居中的七种方法/"
    >使用CSS完成元素居中的七种方法</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2016/02/22/使用CSS完成元素居中的七种方法/" class="article-date">
  <time datetime="2016-02-22T04:53:56.000Z" itemprop="datePublished">2016-02-22</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h3 id="使用CSS完成元素居中的七种方法"><a href="#使用CSS完成元素居中的七种方法" class="headerlink" title="使用CSS完成元素居中的七种方法"></a>使用CSS完成元素居中的七种方法</h3><p>在网页上使 HTML 元素居中看似一件很简单的事情. 至少在某些情况下是这样的，但是复杂的布局往往使一些解决方案不能很好的发挥作用。</p>
<p>在网页布局中元素水平居中比元素垂直居中要简单不少，同时实现水平居中和垂直居中往往是最难的。现在是响应式设计的时代，我们很难确切的知道元素的准确高度和宽度，所以一些方案不大适用。据我所知, 在CSS中至少有六种实现居中的方法。我将使用下面的HTML结构从简单到复杂开始讲解:</p>
<pre><code>&lt;div class=&quot;center&quot;&gt;
      &lt;img src=&quot;jimmy-choo-shoe.jpg&quot; alt&gt;&lt;/div&gt;
</code></pre><h4 id="使用text-align水平居中"><a href="#使用text-align水平居中" class="headerlink" title="使用text-align水平居中"></a>使用text-align水平居中</h4><p><img src="https://gss0.baidu.com/9fo3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/eac4b74543a982268da2a9ac8c82b9014b90ebde.jpg" alt=""></p>
<p>有时显而易见的方案是最佳的选择：</p>
<pre><code>div.center {
  text-align: center;
  background: hsl(0, 100%, 97%);}div.center img {
  width: 33%; height: auto;}
</code></pre><p> 这种方案没有使图片垂直居中：你需要给<div> 添加 padding 或者给内容添加margin-top 和 margin-bottom使容器与内容之间有一定的距离。</div></p>
<h4 id="使用-margin-auto-居中"><a href="#使用-margin-auto-居中" class="headerlink" title="使用 margin: auto 居中"></a>使用 margin: auto 居中</h4><p><img src="http://d06.res.meilishuo.net/picdetail/a/53/82/990dcf4f386c706bbd38a83d3996_715_488_1_1.jpeg" alt=""></p>
<p>这种方式实现水平居中和上面使用text-align的方法有相同局限性。</p>
<pre><code>div.center {
  background: hsl(60, 100%, 97%);}div.center img {
  display: block;
  width: 33%;
  height: auto;
  margin: 0 auto;}
</code></pre><p> 注意： 必须使用display: block使 margin: 0 auto对img元素生效。</p>
<h4 id="使用table-cell居中"><a href="#使用table-cell居中" class="headerlink" title="使用table-cell居中"></a>使用table-cell居中</h4><p><img src="http://d04.res.meilishuo.net/pic/_o/12/b2/fedaa42ff8322d23c7f838706030_500_500.jpeg" alt=""></p>
<p>使用 display: table-cell, 而不是使用table标签; 可以实现水平居中和垂直居中，但是这种方法需要添加额外的元素作为外部容器。</p>
<pre><code>&lt;div class=&quot;center-aligned&quot;&gt;
&lt;div class=&quot;center-core&quot;&gt;
    &lt;img src=&quot;jimmy-choo-shoe.jpg&quot;&gt;
&lt;/div&gt;&lt;/div&gt;
</code></pre><p>CSS:</p>
<pre><code>.center-aligned {
display: table;
background: hsl(120, 100%, 97%);
width: 100%;}.center-core {
display: table-cell;
text-align: center;
vertical-align: middle;}.center-core img {
width: 33%;
height: auto;}
</code></pre><p>注意：为了使div 不折叠必须加上 width: 100%，外部容器元素也需要加上一定高度使得内容垂直居中。给html和body设置高度后，也可以使元素在body垂直居中。此方法在IE8+浏览器上生效。</p>
<h4 id="使用absolute定位居中"><a href="#使用absolute定位居中" class="headerlink" title="使用absolute定位居中"></a>使用absolute定位居中</h4><p><img src="http://d1.tuanimg.com/imagev2/zhaoshang/700x700.fdd06d6fd9aaed1bb1a333be58f1ec72.310x310.jpg" alt=""></p>
<p>这种 方案 有非常好的跨浏览器支持。有一个缺点就是必须显式声明外部容器元素的height：</p>
<pre><code>.absolute-aligned {
position: relative;
min-height: 500px;
background: hsl(200, 100%, 97%);}.absolute-aligned img {
width: 50%;
min-width: 200px;
height: auto;
overflow: auto;
margin: auto;
position: absolute;
top: 0; left: 0;
bottom: 0; right: 0;}
</code></pre><p>Stephen在他的 博客 中演示了这种方案的几种变化。</p>
<h4 id="使用translate居中"><a href="#使用translate居中" class="headerlink" title="使用translate居中"></a>使用translate居中</h4><p><img src="http://d1.tuanimg.com/imagev2/zhaoshang/700x700.fdd06d6fd9aaed1bb1a333be58f1ec72.310x310.jpg" alt=""><br>Chris Coiyer 提出了一个使用 CSS transforms 的新方案。 同样支持水平居中和垂直居中:</p>
<pre><code>.center {
background: hsl(180, 100%, 97%);
position: relative;
min-height: 500px;}.center img {
position: absolute;
top: 50%; left: 50%;
transform: translate(-50%, -50%);
width: 30%; height: auto;}
</code></pre><p>但是有以下几种缺点:</p>
<ul>
<li>CSS transform 在部分就浏览器上需要使用 前缀。</li>
<li>不支持 IE9 以下的浏览器。</li>
<li>外部容器需要设置height （或者用其他方式设置），因为不能获取 绝对定位 的内容的高度。</li>
<li>如果内容包含文字，现在的浏览器合成技术会使文字模糊不清。 </li>
</ul>
<h4 id="使用Flexbox居中"><a href="#使用Flexbox居中" class="headerlink" title="使用Flexbox居中"></a>使用Flexbox居中</h4><p><img src="http://www.qqjia.com/z/07/tu8603_13.jpg" alt=""><br>当新旧语法差异和浏览器前缀消失时，这种方法会成为主流的居中方案。</p>
<pre><code>.center { 
background: hsl(240, 100%, 97%);
display: flex;
justify-content: center;
align-items: center;}.center img { 
width: 30%; height: auto;}
</code></pre><p>在很多方面 flexbox 是一种简单的方案， 但是它有新旧两种语法以及早期版本的IE缺乏支持 （尽管可以使用 display: table-cell作为降级方案）。</p>
<p>现在规范已经最终确定，现代浏览器也大都支持,我写了一篇详细的教程 教程。</p>
<h4 id="使用calc居中"><a href="#使用calc居中" class="headerlink" title="使用calc居中"></a>使用calc居中</h4><p><img src="http://www.qqjia.com/z/07/tu8603_13.jpg" alt=""></p>
<p>在某些情况下比flexbox更全面：</p>
<pre><code>.center {
background: hsl(300, 100%, 97%);
min-height: 600px;
position: relative;}.center img {
width: 40%;
height: auto;
position: absolute;
top: calc(50% - 20%);
left: calc(50% - 20%);}
</code></pre><p>很简单，calc 允许你基于当前的页面布局计算尺寸。在上面的简单计算中， 50% 是容器元素的中心点，但是如果只设置50%会使图片的左上角对齐div的中心位置。 我们需要把图片向左和向上各移动图片宽高的一半。计算公式为：</p>
<pre><code>top: calc(50% - (40% / 2));left: calc(50% - (40% / 2));
</code></pre><p>在现在的浏览其中你会发现，这种方法更适用于当内容的宽高为固定尺寸：</p>
<pre><code>.center img {
width: 500px; height: 500px;
position: absolute;
top: calc(50% - (300px / 2));
left: calc(50% - (300px – 2)); }
</code></pre><p> 这种方案和flex一样有许多相同的缺点： 虽然在现代浏览器中有良好的支持，但是在较早的版本中仍然需要浏览器前缀，并且不支持IE8。</p>
<pre><code> .center img {
width: 40%; height: auto;
position: absolute;
top: calc(50% - 20%);
left: calc(50% - 20%);}
</code></pre><p> 当然还有 其他更多的方案。理解这六种方案之后，web开发人员在面对元素居中的时候会有更多的选择。</p>
<p>来源<a href="http://www.zcfy.cc/article/the-new-code-seven-ways-of-centering-with-css-439.html" target="_blank" rel="noopener">http://www.zcfy.cc/article/the-new-code-seven-ways-of-centering-with-css-439.html</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-高德地图插件使用"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2016/02/02/高德地图插件使用/"
    >高德地图插件使用</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2016/02/02/高德地图插件使用/" class="article-date">
  <time datetime="2016-02-02T01:50:36.000Z" itemprop="datePublished">2016-02-02</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="高德地图"><a href="#高德地图" class="headerlink" title="高德地图"></a>高德地图</h2><h3 id="本文引自高德开放平台"><a href="#本文引自高德开放平台" class="headerlink" title="本文引自高德开放平台"></a>本文引自高德开放平台</h3><h4 id="准备页面"><a href="#准备页面" class="headerlink" title="准备页面"></a>准备页面</h4><p>在正式开始开发地图应用之前,您需要做如下几步:</p>
<p>1 在高德地图官网注册一个账号</p>
<p>2 <strong>申请JSAPI的开发者Key</strong><br>申请地址：</p>
<p><a href="http://lbs.amap.com/dev/key" target="_blank" rel="noopener">http://lbs.amap.com/dev/key</a></p>
<h3 id="引入高德地图JavaScript-API入口脚本"><a href="#引入高德地图JavaScript-API入口脚本" class="headerlink" title="引入高德地图JavaScript API入口脚本:"></a>引入高德地图JavaScript API入口脚本:</h3><pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;http://webapi.amap.com/maps?v=1.3&amp;key=您申请的key值&quot;&gt;&lt;/script&gt;
</code></pre><h3 id="创建地图容器"><a href="#创建地图容器" class="headerlink" title="创建地图容器"></a>创建地图容器</h3><p>在页面body里你想展示地图的地方创建一个div 容器，并指定id标识:</p>
<pre><code>&lt;div id=&quot;container&quot;&gt;&lt;/div&gt;
</code></pre><h3 id="指定容器大小"><a href="#指定容器大小" class="headerlink" title="指定容器大小"></a>指定容器大小</h3><p>使用CSS为地图容器设置合适的大小，比如:</p>
<pre><code>#container {width:300px; height: 180px; } 
</code></pre><h4 id="创建地图"><a href="#创建地图" class="headerlink" title="创建地图"></a>创建地图</h4><p>做完简单的准备工作之后，就可以开始创建地图了.</p>
<h3 id="按照默认属性创建地图"><a href="#按照默认属性创建地图" class="headerlink" title="按照默认属性创建地图"></a>按照默认属性创建地图</h3><p>生成一副简单地图只需要一句代码，将我们刚刚创建的div的id传给Map的构造函数即可，这个时候API将根据用户所在的城市自动进行地图中心点和级别的设定：</p>
<pre><code>var map = new AMap.Map(&apos;container&apos;);
</code></pre><ul>
<li><h3 id="设定地图的中心点和级别"><a href="#设定地图的中心点和级别" class="headerlink" title="设定地图的中心点和级别"></a>设定地图的中心点和级别</h3></li>
</ul>
<p>我们一般需要给地图按需设定中心点和坐标等属性，这里可以通过两种方式，第一种，直接在地图初始化的时候传入相关属性，center属性的值可以使经纬度的二元数组，也可以是AMap.LngLat对象，要求经度值在前，纬度值在后：</p>
<pre><code>var map = new AMap.Map(&apos;container&apos;,{
zoom: 10,
center: [116.39,39.9]});
</code></pre><p> 也可以在地图初始化过后，任何需要的地方通过方法来改变地图的中心点和级别</p>
<pre><code> var map = new AMap.Map(&apos;container&apos;);
map.setZoom(10);
map.setCenter([116.39,39.9]);
</code></pre><h4 id="添加点标记"><a href="#添加点标记" class="headerlink" title="添加点标记"></a>添加点标记</h4><p>创建好地图之后，我们就可以在地图上添加点标记了，用来标注任何用户感兴趣的位置和信息，这里使用到了AMap.Marker这个类。</p>
<ul>
<li><h4 id="点标记的创建与添加"><a href="#点标记的创建与添加" class="headerlink" title="点标记的创建与添加"></a>点标记的创建与添加</h4><p>同地图一样，点标记可以在创建的时候设定位置等属性，如果设定了map属性的话，marker点将被立即添加到地图上：</p>
<pre><code>var marker = new AMap.Marker({
position: [116.480983, 39.989628],
    map:map
});    
</code></pre><p>  也可以在创建之后按需更改这些属性:</p>
<pre><code>var marker = new AMap.Marker();
marker.setMap(map);
</code></pre></li>
<li><h4 id="点标记的移除"><a href="#点标记的移除" class="headerlink" title="点标记的移除"></a>点标记的移除</h4><p>移除的话，同样使用setMap方法,不传参数或者传入空参数：</p>
<pre><code>marker.setMap();
</code></pre></li>
</ul>
<h4 id="添加信息窗体"><a href="#添加信息窗体" class="headerlink" title="添加信息窗体"></a>添加信息窗体</h4><p>我们也可以用信息窗体InfoWindow类来向用户展示一些更详细的信息，比如点击一个点标记后，通过信息窗体来展示这个点标记在哪里</p>
<h5 id="信息窗体的创建与设定"><a href="#信息窗体的创建与设定" class="headerlink" title="信息窗体的创建与设定"></a>信息窗体的创建与设定</h5><p>信息窗体一样可以在创建的时候设定内容、偏移量、大小等属性，offset是信息窗体的锚点以position为基准位置的像素偏移量，content除了使用字符串的形式外也可以直接设定为某个创建好的DOM节点：</p>
<pre><code>var infowindow = new AMap.InfoWindow({
 content: &apos;&lt;h3&gt;高德地图&lt;/h3&gt;&lt;div&gt;高德是中国领先的数字地图内容、导航    和位置服务解决方案提供商。&lt;/div&gt;&apos;,
 offset: new AMap.Pixel(0, -30),
 size:new AMap.Size(230,0)
})
</code></pre><p>也可以在创建之后按需更改这些属性:</p>
<pre><code>infowindow.setSize(new AMap.Size(150,50));
var contentDiv = document.createElement(&apos;div&apos;);
contentDiv.innerText=&apos;我是信息窗体&apos;;
infowindow.setContent(contentDiv);
</code></pre><h5 id="如何打开信息窗体"><a href="#如何打开信息窗体" class="headerlink" title="如何打开信息窗体"></a>如何打开信息窗体</h5><p>我们可以在信息窗体创建之后立即调用其open方法将它显示在需要的位置：</p>
<pre><code>infowindow.open(map,new AMap.LngLat(116.480983, 39.989628));
</code></pre><p>也可以通过事件监听，在需要的时候才将信息窗体显示出来,比如在marker被单击的时候显示</p>
<pre><code>var clickHandle = AMap.event.addListener(marker, &apos;click&apos;,     function() {
    infowindow2.open(map, marker.getPosition())
})
</code></pre><p>当不再需要点击marker显示信息窗体这个功能的时候，可以通过如下方式移除事件绑定</p>
<pre><code>AMap.event.removeListener(clickHandle);
</code></pre><h3 id="使用高级信息窗体"><a href="#使用高级信息窗体" class="headerlink" title="使用高级信息窗体"></a>使用高级信息窗体</h3><p>除了普通的信息窗体，我们还提供了封装了周边搜索和路线规划功能在内的高级信息窗体，要使用高级信息窗体，首先需要通过plugin方法加载该插件，然后就可以和普通信息窗体一样进行创建和打开了。如果为高级信息窗体制定了panel属性，将在以panel的值为id的div上显示周边搜索或者路线规划的结果，如果需要对高级信息窗体和panel内容的样式进行修改，可以对相应classname的css进行重写：</p>
<pre><code>AMap.plugin(&apos;AMap.AdvancedInfoWindow&apos;,function(){
  var infowindow = new AMap.AdvancedInfoWindow({
content: &apos;&lt;h3 class=&quot;title&quot;&gt;高德地图&lt;/h3&gt;&apos;+
         &apos;&lt;div class=&quot;content&quot;&gt;高德是中国领先的数字地图内容、&apos;+
         &apos;导航和位置服务解决方案提供商。&lt;/div&gt;&apos;,
offset: new AMap.Pixel(0, -30),
asOrigin:false
  });
  infowindow.open(map,new AMap.LngLat(116.480983, 39.989628));
})
</code></pre><h5 id="添加工具条和比例尺"><a href="#添加工具条和比例尺" class="headerlink" title="添加工具条和比例尺"></a>添加工具条和比例尺</h5><p>高德地图JSAPI提供了大量丰富的功能控件和服务插件，下面我们来给上面做好的地图添加两个常用的控件，工具条和比例尺。</p>
<h6 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h6><p>添加控件的时候首先需要加载插件,同时需要多个插件的时候第一个参数可以设定为控件名称的数组</p>
<pre><code>AMap.plugin([&apos;AMap.ToolBar&apos;,&apos;AMap.Scale&apos;],function(){
//TODO  创建控件并添加
})
</code></pre><p>在回调函数里我们来进行控件的生成和添加:</p>
<pre><code>AMap.plugin([&apos;AMap.ToolBar&apos;,&apos;AMap.Scale&apos;],function(){
var toolBar = new AMap.ToolBar();
var scale = new AMap.Scale();
map.addControl(toolBar);
map.addControl(scale);
})
</code></pre><h5 id="移除"><a href="#移除" class="headerlink" title="移除"></a>移除</h5><p>要移除控件的时候调用地图的removeControl方法即可</p>
<pre><code>map.removeControl(toolBar);
</code></pre> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">上一页</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2021
        <i class="ri-heart-fill heart_icon"></i> 魏姣
      </li>
    </ul>
    <ul>
      <li>
        
        
        
        Powered by <a href="https://hexo.io" target="_blank">Hexo</a>
        <span class="division">|</span>
        Theme - <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></s>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="薇娇"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/lazyload.min.js"></script>
<!-- Tocbot -->

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>
<script src="/dist/main.js"></script>
<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->

<script src="/js/busuanzi-2.3.pure.min.js"></script>

<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->

<link rel="stylesheet" href="/css/clipboard.css">
<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>


<!-- CanvasBackground -->


    
  </div>
</body>

</html>