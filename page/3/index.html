<!DOCTYPE html>


<html lang="en">


<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     薇娇
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  <link rel="stylesheet" href="/dist/main.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css">
  <link rel="stylesheet" href="/css/custom.css">
  
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
  
  

  

</head>

</html>

<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/Shen-Yu/hexo-theme-ayer"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">薇娇</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-深入浅出JSONP-解决ajax跨域问题"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2016/06/01/深入浅出JSONP-解决ajax跨域问题/"
    >深入浅出JSONP--解决ajax跨域问题</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2016/06/01/深入浅出JSONP-解决ajax跨域问题/" class="article-date">
  <time datetime="2016-06-01T03:53:18.000Z" itemprop="datePublished">2016-06-01</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="JSONP–解决ajax跨域问题"><a href="#JSONP–解决ajax跨域问题" class="headerlink" title="JSONP–解决ajax跨域问题"></a>JSONP–解决ajax跨域问题</h2><h3 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h3><blockquote>
<p>同源策略，它是由Netscape提出的一个著名的安全策略。现在所有支持JavaScript 的浏览器都会使用这个策略。所谓同源是指，域名，协议，端口相同。当一个浏览器的两个tab页中分别打开来 百度和谷歌的页面当一个百度浏览器执行一个脚本的时候会检查这个脚本是属于哪个页面的，即检查是否同源，只有和百度同源的脚本才会被执行。</p>
</blockquote>
<h3 id="JSON和JSONP"><a href="#JSON和JSONP" class="headerlink" title="JSON和JSONP"></a>JSON和JSONP</h3><p>JSONP和JSON好像啊，他们之间有什么联系吗？</p>
<p>　　JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。对于JSON大家应该是很了解了吧，不是很清楚的朋友可以去json.org上了解下，简单易懂。</p>
<p>　　JSONP是JSON with Padding的略称。它是一个非官方的协议，它允许在服务器端集成Script tags返回至客户端，通过javascript callback的形式实现跨域访问（这仅仅是JSONP简单的实现形式）。–来源百度</p>
<p>　　JSONP就像是JSON+Padding一样(Padding这里我们理解为填充)， 我们先看下面的小例子然后再详细介绍。
　　
　　</p>
<h3 id="跨域的简单原理"><a href="#跨域的简单原理" class="headerlink" title="跨域的简单原理"></a>跨域的简单原理</h3><p>光看定义还不是很明白，那首先我们先来手动做个简单易懂的小测试。新建一个asp.net的web程序，添加sample.html网页和一个test.js文件，代码如下：</p>
<p>sample.html的代码：</p>
<pre><code>&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/        TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;
 &lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; &gt;
  &lt;head&gt;
  &lt;title&gt;test&lt;/title&gt;
  &lt;script type=&quot;text/javascript&quot; src=&quot;test.js&quot;&gt;&lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
  &lt;/body&gt;
  &lt;/html&gt;
</code></pre><p>test.js的代码：</p>
<pre><code>alert(&quot;success&quot;);
</code></pre><p>打开sample.html后会跳出”success”这样的这样的信息框，这似乎并不能说明什么， 跨域问题到底怎么解决呢？好，现在我们模拟下非同源的环境，刚才我们不是已经用Visual Studio新建了一个Web程序吗(这里我们叫A程序)，现在我们再打开一个新的Visual Studio再新建一个Web程序(B程序)，将我们的之前的test.js文件从A程序中移除然后拷贝到B程序中。两个程序都运行起来后，Visual Studio会启动内置服务器，假设A程序是localhost:20001,B程序是localhost:20002，这就模拟了一个非同源的环境了(虽然域名相同但端口号不同，所以是非同源的)。</p>
<p>　　OK，我们接下来应该改下sample.html里的代码，因为test.js文件在B程序上了，url也就变成了localhost:20002。</p>
<p>sample.html部分代码：</p>
<pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;http://localhost:20002/test.js&quot;&gt;&lt;/script&gt;
</code></pre><p>请保持AB两个Web程序的运行状态，当你再次刷新localhost:20001/sample.html的时候，和原来一样跳出了”success”的对话框，是的，成功访问到了非同源的localhost:20002/test.js这个所谓的远程服务了。到了这一步，相信大家应该已经大概明白如何跨域访问了的原理了。</p>
<pre><code>&lt;script&gt;标签的src属性并不被同源策略所约束，所以可以获取任何服务器上脚本并执行。
</code></pre><h3 id="JSONP的实现模式–CallBack"><a href="#JSONP的实现模式–CallBack" class="headerlink" title="JSONP的实现模式–CallBack"></a>JSONP的实现模式–CallBack</h3><p>刚才的小例子讲解了跨域的原理，我们回上去再看看JSONP的定义说明中讲到了javascript callback的形式。那我们就来修改下代码，如何实现JSONP的javascript callback的形式。</p>
<p>程序A中sample的部分代码：</p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
//回调函数
function callback(data) {
    alert(data.message);
    }
    &lt;/script&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;http://localhost:20002/test.js&quot;&gt;&lt;/script&gt;
</code></pre><p>程序B中test.js的代码：</p>
<pre><code>//调用callback函数，并以json数据形式作为阐述传递，完成回调
callback({message:&quot;success&quot;}); 
</code></pre><p>这其实就是JSONP的简单实现模式，或者说是JSONP的原型：创建一个回调函数，然后在远程服务上调用这个函数并且将JSON 数据形式作为参数传递，完成回调。</p>
<p>将JSON数据填充进回调函数，这就是JSONP的JSON+Padding的含义吧。</p>
<p>一般情况下，我们希望这个script标签能够动态的调用，而不是像上面因为固定在html里面所以没等页面显示就执行了，很不灵活。我们可以通过javascript动态的创建script标签，这样我们就可以灵活调用远程服务了。</p>
<p>程序A中sample的部分代码：</p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
 function callback(data) {
  alert(data.message);
 }
 //添加&lt;script&gt;标签的方法
 function addScriptTag(src){
var script = document.createElement(&apos;script&apos;);
script.setAttribute(&quot;type&quot;,&quot;text/javascript&quot;);
script.src = src;
document.body.appendChild(script);
}

window.onload = function(){
addScriptTag(&quot;http://localhost:20002/test.js&quot;);
  }
&lt;/script&gt;
</code></pre><p>程序B的test.js代码不变，我们再执行下程序，是不是和原来的一样呢。如果我们再想调用一个远程服务的话，只要添加addScriptTag方法，传入远程服务的src值就可以了。这里说明下为什么要将addScriptTag方法放入到window.onload的方法里，原因是addScriptTag方法中有句document.body.appendChild(script);，这个script标签是被添加到body里的，由于我们写的javascript代码是在head标签中，document.body还没有初始化完毕呢，所以我们要通过window.onload方法先初始化页面，这样才不会出错。</p>
<p>　　上面的例子是最简单的JSONP的实现模型，不过它还算不上一个真正的JSONP服务。我们来看一下真正的JSONP服务是怎么样的，比如Google的ajax搜索接口：<a href="http://ajax.googleapis.com/ajax/services/search/web?v=1.0&amp;q=?&amp;callback=" target="_blank" rel="noopener">http://ajax.googleapis.com/ajax/services/search/web?v=1.0&amp;q=?&amp;callback=</a>? </p>
<p>　　q=?这个问号是表示你要搜索的内容，最重要的是第二个callback=?这个是正如其名表示回调函数的名称，也就是将你自己在客户端定义的回调函数的函数名传送给服务端，服务端则会返回以你定义的回调函数名的方法，将获取的json数据传入这个方法完成回调。有点罗嗦了，还是看看实现代码吧：</p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
 //添加&lt;script&gt;标签的方法
function addScriptTag(src){
 var script = document.createElement(&apos;script&apos;);
 script.setAttribute(&quot;type&quot;,&quot;text/javascript&quot;);
 script.src = src;
 document.body.appendChild(script);
  }

 window.onload = function(){
 //搜索apple，将自定义的回调函数名result传入callback参数中
 addScriptTag(&quot;http://ajax.googleapis.com/ajax/services/search/web?    v=1.0&amp;q=apple&amp;callback=result&quot;);

 }
 //自定义的回调函数result
 function result(data) {
//我们就简单的获取apple搜索结果的第一条记录中url数据
 alert(data.responseData.results[0].unescapedUrl);
}
&lt;/script&gt;    
</code></pre><p>像这样的JSONP服务还有很多(以下信息来自使用 JSONP 实现跨域通信，第 1 部分: 结合 JSONP 和 jQuery 快速构建强大的 mashup)：</p>
<blockquote>
<p>Digg API：来自 Digg 的头条新闻：</p>
</blockquote>
<p>　　<a href="http://services.digg.com/stories/top?appkey=http%3A%2F%2Fmashup.com&amp;type=javascript&amp;callback=" target="_blank" rel="noopener">http://services.digg.com/stories/top?appkey=http%3A%2F%2Fmashup.com&amp;type=javascript&amp;callback=</a>?</p>
<p>Geonames API：邮编的位置信息：</p>
<p>　　<a href="http://www.geonames.org/postalCodeLookupJSON?postalcode=10504&amp;country=US&amp;callback=" target="_blank" rel="noopener">http://www.geonames.org/postalCodeLookupJSON?postalcode=10504&amp;country=US&amp;callback=</a>?</p>
<p>Flickr JSONP API：载入最新猫的图片：</p>
<p>　　<a href="http://api.flickr.com/services/feeds/photos_public.gne?tags=cat&amp;tagmode=any&amp;format=json&amp;jsoncallback=" target="_blank" rel="noopener">http://api.flickr.com/services/feeds/photos_public.gne?tags=cat&amp;tagmode=any&amp;format=json&amp;jsoncallback=</a>?</p>
<p>Yahoo Local Search API：在邮编为 10504 的地区搜索比萨：</p>
<p>　　<a href="http://local.yahooapis.com/LocalSearchService/V3/localSearch?appid=YahooDemo&amp;query=pizza&amp;zip=10504&amp;results=2&amp;output=json&amp;callback=" target="_blank" rel="noopener">http://local.yahooapis.com/LocalSearchService/V3/localSearch?appid=YahooDemo&amp;query=pizza&amp;zip=10504&amp;results=2&amp;output=json&amp;callback=</a>?</p>
<p>接下来我们自己来创建一个简单的远程服务，实现和上面一样的JSONP服务。还是利用Web程序A和程序B来做演示，这次我们在程序B上创建一个MyService.ashx文件。</p>
<p>程序B的MyService.ashx代码：</p>
<pre><code>public class MyService : IHttpHandler
 {
 public void ProcessRequest(HttpContext context)
 {
 //获取回调函数名
 string callback = context.Request.QueryString[&quot;callback&quot;];
 //json数据
 string json = &quot;{\&quot;name\&quot;:\&quot;chopper\&quot;,\&quot;sex\&quot;:\&quot;man\&quot;}&quot;;

 context.Response.ContentType = &quot;application/json&quot;;
  //输出：回调函数名(json数据)
  context.Response.Write(callback + &quot;(&quot; + json + &quot;)&quot;);
  }

  public bool IsReusable
   {
  get
 {
 return false;
 }
 }
}
</code></pre><p>程序A的sample代码中的调用：</p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
 function addScriptTag(src){
  var script = document.createElement(&apos;script&apos;);
  script.setAttribute(&quot;type&quot;,&quot;text/javascript&quot;);
  script.src = src;
  document.body.appendChild(script);
  }
  window.onload = function(){
   //调用远程服务
   addScriptTag(&quot;http://localhost:20002/MyService.ashx?callback=person&quot;);

  }
  //回调函数person
     function person(data) {
  alert(data.name + &quot; is a &quot; + data.sex);
   }
 &lt;/script&gt;　　
</code></pre><p>这就完成了一个最基本的JSONP服务调用了</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="swiper-Animation使用"
  class="article article-type-swiper"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2016/05/12/Animation使用/"
    >Animation使用</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2016/05/12/Animation使用/" class="article-date">
  <time datetime="2016-05-12T07:12:11.000Z" itemprop="datePublished">2016-05-12</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h3 id="Swiper-Animate使用方法"><a href="#Swiper-Animate使用方法" class="headerlink" title="Swiper Animate使用方法"></a>Swiper Animate使用方法</h3><p><strong> Swiper Animate</strong>，是Swiper中文网提供的用于在Swiper内快速制作CSS3动画效果的小插件，适用于Swiper2.x和Swiper3.x 。<br><strong> 此插件不适用于loop模式</strong></p>
<ol>
<li>使用Swiper Animate需要先加载swiper.animate.min.js和animate.min.css。code:<br> &lt;!DOCTYPE html&gt;<pre><code>&lt;html&gt;
&lt;head&gt;
...
&lt;link rel=&quot;stylesheet&quot; href=&quot;path/to/swiper.min.css&quot;&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;path/to/animate.min.css&quot;&gt;
</code></pre> <br> <body><pre><code>...
&lt;script src=&quot;path/to/swiper.min.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;path/to/swiper.animate.min.js&quot;&gt;&lt;/script&gt;
</code></pre> </body><br> </li>
<li>初始化时隐藏元素并在需要的时刻开始动画。<br>code:<br> <script><br>   var mySwiper = new Swiper (‘.swiper-container’, {<br>   onInit: function(swiper){ //Swiper2.x的初始化是onFirstInit<pre><code>swiperAnimateCache(swiper); //隐藏动画元素 
swiperAnimate(swiper); //初始化完成开始动画
</code></pre>   },<br>   onSlideChangeEnd: function(swiper){ <pre><code>swiperAnimate(swiper); //每个slide切换结束时也运行当前slide动画
</code></pre>   }<br>   })<br>   </script><br> </li>
<li>在需要运动的元素上面增加类名  ani   ，和其他的类似插件相同，Swiper         Animate需要指定几个参数：<br>swiper-animate-effect：切换效果，例如 fadeInUp<br>swiper-animate-duration：可选，动画持续时间（单位秒），例如 0.5s<br>swiper-animate-delay：可选，动画延迟时间（单位秒），例如 0.3s code:<br>div class=”swiper-slide”&gt;<br><p class="ani" swiper-animate-effect="fadeInUp" swiper-animate-duration="0.5s" swiper-animate-delay="0.3s">内容</p><br><br>如果以上这些效果不能满足你的需求，你可以仿照animate.css的格式制作一些其他效果，加到你自己的css文件。其他参数：transition-timing-function </li>
</ol>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-常见兼容性问题（一）"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2016/05/09/常见兼容性问题（一）/"
    >常见兼容性问题（一）</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2016/05/09/常见兼容性问题（一）/" class="article-date">
  <time datetime="2016-05-09T10:57:49.000Z" itemprop="datePublished">2016-05-09</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h3 id="常见兼容性问题"><a href="#常见兼容性问题" class="headerlink" title="常见兼容性问题"></a>常见兼容性问题</h3><p>关于各主流浏览器之间的兼容性问题，有时候确实让人头疼，为了提高工作效率，在网上搜集了有关此问题 简单整理了一下，时常来看看<br>出处：<img src="http://www.cnblogs.com/duanhuajian/archive/2012/09/23/2699119.html" alt="http://www.cnblogs.com/duanhuajian/archive/2012/09/23/2699119.html"></p>
<h5 id="ie6-0横向margin加倍"><a href="#ie6-0横向margin加倍" class="headerlink" title="ie6.0横向margin加倍"></a>ie6.0横向margin加倍</h5><p>产生因素：块属性、float、有横向margin。<br>解决方法：display：inline；</p>
<h5 id="2-ie6-0下默认有行高"><a href="#2-ie6-0下默认有行高" class="headerlink" title="2 ie6.0下默认有行高"></a>2 ie6.0下默认有行高</h5><p>解决方法：overflow:hidden;或font-size:0;或line-height：xx px；</p>
<p>#####3 在各个浏览器下img有空隙(原因是：回车。)</p>
<p>解决方法:让图片浮动。</p>
<h5 id="4-一个父标签与几个子标签嵌套，父标签不浮动，子标签float，子标签不撑开父的高度。"><a href="#4-一个父标签与几个子标签嵌套，父标签不浮动，子标签float，子标签不撑开父的高度。" class="headerlink" title="4 一个父标签与几个子标签嵌套，父标签不浮动，子标签float，子标签不撑开父的高度。"></a>4 一个父标签与几个子标签嵌套，父标签不浮动，子标签float，子标签不撑开父的高度。</h5><p>解决方法：    </p>
<p>a 在子标签最后清浮动{<div style="height:0;clear:both;">&nbsp;</div>}</p>
<p> b 父标签添加{overflow：hidden；}</p>
<p> c 给父标签设置高度</p>
<h5 id="5-Ie6下，不识别最大宽、高度和最小宽高度，意即min-width-height和-Max-width-height在ie6中没效果，"><a href="#5-Ie6下，不识别最大宽、高度和最小宽高度，意即min-width-height和-Max-width-height在ie6中没效果，" class="headerlink" title="5 Ie6下，不识别最大宽、高度和最小宽高度，意即min-width/height和 Max-width/height在ie6中没效果，"></a>5 Ie6下，不识别最大宽、高度和最小宽高度，意即min-width/height和 Max-width/height在ie6中没效果，</h5><p>解决方法：</p>
<pre><code>(1)：.abc{border:1px blue solid;width:200px;height:200px;}
                  html&gt;body .abc{width:auto;height:auto;min-width:200px;min-        height:200px;}

(2)：.abc{width:200px;height:200px;_width:200px;_height:200px;}（因为ie6有一个特征，当定义一个高度时，如果内容超过高度，元素会自动调整高度。）
</code></pre><h5 id="6-Ie6里面：如li设宽、高，并且li里面的标签浮动，那么li之间会有间距"><a href="#6-Ie6里面：如li设宽、高，并且li里面的标签浮动，那么li之间会有间距" class="headerlink" title="6 Ie6里面：如li设宽、高，并且li里面的标签浮动，那么li之间会有间距"></a>6 Ie6里面：如li设宽、高，并且li里面的标签浮动，那么li之间会有间距</h5><p>解决方法：li不设宽、高或者li内的标签不浮动</p>
<h5 id="7-li之间有间距"><a href="#7-li之间有间距" class="headerlink" title="7  li之间有间距"></a>7  li之间有间距</h5><p>解决方法：li 设置vertical-align:middle;</p>
<h5 id="8-3像素问题：ie6下，当浮动元素与流动元素并列显示时，他们之间会存在三像素问题。"><a href="#8-3像素问题：ie6下，当浮动元素与流动元素并列显示时，他们之间会存在三像素问题。" class="headerlink" title="8 3像素问题：ie6下，当浮动元素与流动元素并列显示时，他们之间会存在三像素问题。"></a>8 3像素问题：ie6下，当浮动元素与流动元素并列显示时，他们之间会存在三像素问题。</h5><p>   解决方法：用hack技术， 例如：</p>
<pre><code>   所有浏览器通用 height:100px;

ie6专用_height:100px;

ie7专用*+height:100px; 

ie6/ie7共用*height:100px;
</code></pre><h5 id="9-当定义行内元素为包含框时，且包含框包含的绝对定位元素以百分比为单位进行定位时，会出现混乱。"><a href="#9-当定义行内元素为包含框时，且包含框包含的绝对定位元素以百分比为单位进行定位时，会出现混乱。" class="headerlink" title="9 当定义行内元素为包含框时，且包含框包含的绝对定位元素以百分比为单位进行定位时，会出现混乱。"></a>9 当定义行内元素为包含框时，且包含框包含的绝对定位元素以百分比为单位进行定位时，会出现混乱。</h5><p> 解决方法：在行内元素里加入{zoom：1；}</p>
<h5 id="10-当多个浮动元素中间夹杂着HTML注释语句时，如果浮动元素宽度为100-，则在下一行多显示一个上一行最后一个字符。"><a href="#10-当多个浮动元素中间夹杂着HTML注释语句时，如果浮动元素宽度为100-，则在下一行多显示一个上一行最后一个字符。" class="headerlink" title="10 当多个浮动元素中间夹杂着HTML注释语句时，如果浮动元素宽度为100%，则在下一行多显示一个上一行最后一个字符。"></a>10 当多个浮动元素中间夹杂着HTML注释语句时，如果浮动元素宽度为100%，则在下一行多显示一个上一行最后一个字符。</h5><p>解决办法：给浮动元素添加display:inline;。</p>
<h5 id="11-opacity-定义元素的不透明度"><a href="#11-opacity-定义元素的不透明度" class="headerlink" title="11 opacity 定义元素的不透明度"></a>11 opacity 定义元素的不透明度</h5><p>  filter：alpha（opacity=80）；/<em>ie支持该属性</em>/</p>
<p>  opacity：0.8；/<em>支持css3的浏览器</em>/</p>
<h5 id="12-两个块元素，竖向的margin值不增加，会重叠，其间距为最大margin值。"><a href="#12-两个块元素，竖向的margin值不增加，会重叠，其间距为最大margin值。" class="headerlink" title="12 两个块元素，竖向的margin值不增加，会重叠，其间距为最大margin值。"></a>12 两个块元素，竖向的margin值不增加，会重叠，其间距为最大margin值。</h5><p>#####13 优先级：被!important 注明的css属性具有最高优先级(.abc{color:red !important;})。但在ie6中!important具有一个bug:在同一组css属性中，!important不起作用。</p>
<h5 id="14-火狐不识别background-position-y-或background-position-x"><a href="#14-火狐不识别background-position-y-或background-position-x" class="headerlink" title="14 火狐不识别background-position-y 或background-position-x;"></a>14 火狐不识别background-position-y 或background-position-x;</h5><h5 id="15-ie6-不支持-fixed"><a href="#15-ie6-不支持-fixed" class="headerlink" title="15 ie6 不支持 fixed"></a>15 ie6 不支持 fixed</h5><pre><code>/*对于非IE6可以这样写*/
#top{  
position:fixed;  
bottom:0;  
right:20px;  
}  

/*但是IE6是不支持fixed定位的，需要另外重写*/
#top{  
position:fixed;  
_position:absolute;  
top:0;  
right:20px;  
_bottom:auto;  
_top:expression(eval(document.documentElement.scrollTop));
}  

/*使用hack使IE6实现该效果，但这个东东会闪烁，需要以下代码*/
*html{  
background-image:url(about:blank);  
background-attachment:fixed;  
}  

/*使固定在顶部*/
#top{  
_position:absolute;  
_bottom:auto;  
_top:expression(eval(document.documentElement.scrollTop));  
}  

/*固定在底部*/
#top{  
_position:absolute;  
_bottom:auto;  
_top:expression(eval(document.documentElement.scrollTop    +document.documentElement.clientHeight-this.offsetHeight-    (parseInt(this.currentStyle.marginTop)||0)-    (parseInt(this.currentStyle.marginBottom)||0)));  
}  
/*垂直居中*/
#top{
position:fixed;
top:50%;
margin-top:-50px;
_position:absolute;
_top:expression(eval(document.documentElement.scrollTop    +document.documentElement.clientHeight/2)); 
}
</code></pre><h5 id="16解决-ie6-最大、最小宽高-hack方法"><a href="#16解决-ie6-最大、最小宽高-hack方法" class="headerlink" title="16解决 ie6 最大、最小宽高 hack方法"></a>16解决 ie6 最大、最小宽高 hack方法</h5><pre><code>/* 最小宽度 */
.min_width{
min-width:300px;
_width:expression(parseInt(this.clientWidth) &lt; 300 ? &quot;300px&quot; : this.clientWidth);
}

/* 最大宽度 */
.max_width{
       max-width:600px;
       _width:expression(parseInt(this.clientWidth) &gt; 600 ? &quot;600px&quot; :         this.clientWidth);
    }
/* 最小高度 */
.min_height{
   min-height:200px;
   _height:expression(parseInt(this.clientHeight) &lt; 200 ? &quot;200px&quot; :     this.clientHeight);
}

/* 最大高度 */
max_height{
   max-height:400px;
   _height:expression(parseInt(this.clientHeight) &gt; 400 ? &quot;400px&quot; :     this.clientHeight);
}
</code></pre><h5 id="17-z-index不起作用的-bug"><a href="#17-z-index不起作用的-bug" class="headerlink" title="17 z-index不起作用的 bug"></a>17 z-index不起作用的 bug</h5><p>1）ie6下 首先讲讲第一种z-index无论设置多高都不起作用情况。这种情况发生的条件有三个：1、父标签position属性为relative；2、问题标签含有浮动(float)属性。</p>
<p>2）所有浏览器：它只认第一个爸爸<br>层级的高低不仅要看自己，还要看自己的老爸这个后台是否够硬。用术语具体描述为：<br>父标签position属性为relative或absolute时，子标签的absolute属性是相对于父标签而言的。而在IE6下，层级的表现有时候不是看子标签的z-index多高，而要看它们的父标签的z-index谁高谁低。</p>
<h5 id="18-ie各个版本hack"><a href="#18-ie各个版本hack" class="headerlink" title="18 ie各个版本hack"></a>18 ie各个版本hack</h5><pre><code>/*类内部hack：*/
.header {_width:100px;}            /* IE6专用*/
.header {*+width:100px;}        /* IE7专用*/
.header {*width:100px;}            /* IE6、IE7共用*/
.header {width:100px\0;}        /* IE8、IE9共用*/
.header {width:100px\9;}        /* IE6、IE7、IE8、IE9共用*/
.header {width:330px\9\0;}    /* IE9专用*/

/*选择器Hack：*/
*html .header{}        /*IE6*/ 
*+html .header{}    /*IE7*/ 
</code></pre> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-JavaScript使用小技巧"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2016/05/05/JavaScript使用小技巧/"
    >JavaScript使用小技巧</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2016/05/05/JavaScript使用小技巧/" class="article-date">
  <time datetime="2016-05-05T01:20:06.000Z" itemprop="datePublished">2016-05-05</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="JavaScript-小知识点使用"><a href="#JavaScript-小知识点使用" class="headerlink" title="JavaScript 小知识点使用"></a>JavaScript 小知识点使用</h1><p>本文是一篇翻译文章，原文信息如下：</p>
<ul>
<li>原文：<45 useful="" javascript="" tips,="" tricks="" and="" best="" practices=""></45></li>
<li>作者：<saad mousliki=""><br>JavaScript还是很多新手踏入编程世界的第一个语言。既可以用来显示浏览器中的简单提示框，也可以通过nodebot或nodruino来控制机器人。能够编写结构清晰、性能高效的JavaScript代码的开发人员，现如今已成了招聘市场最受追捧的人<h2 id="1-用JSON来序列化与反序列化"><a href="#1-用JSON来序列化与反序列化" class="headerlink" title="1 用JSON来序列化与反序列化"></a>1 用JSON来序列化与反序列化</h2>var person = {name :’Saad’, age : 26, department : {ID : 15, name : “R&amp;D”} };<br>var stringFromPerson = JSON.stringify(person);<br>/<em> stringFromPerson 结果为 “{“name”:”Saad”,”age”:26,”department”:{“ID”:15,”name”:”R&amp;D”}}”   </em>/<br>var personFromString = JSON.parse(stringFromPerson);<br>/<em> personFromString 的值与 person 对象相同  </em>/</saad></li>
</ul>
<h2 id="2-避免使用with"><a href="#2-避免使用with" class="headerlink" title="2 避免使用with()"></a>2 避免使用with()</h2><p>使用with()可以把变量加入到全局作用域中，因此，如果有其它的同名变量，一来容易混淆，二来值也会被覆盖。</p>
<h2 id="3-传给setInterval-和setTimeout-时使用函数而不是字符串"><a href="#3-传给setInterval-和setTimeout-时使用函数而不是字符串" class="headerlink" title="3 传给setInterval()和setTimeout()时使用函数而不是字符串"></a>3 传给setInterval()和setTimeout()时使用函数而不是字符串</h2><p>如果传给setTimeout()和setInterval()一个字符串，他们将会用类似于eval方式进行转换，这肯定会要慢些，因此不要使用：<br>1 setInterval(‘doSomethingPeriodically()’, 1000);<br>2 setTimeout(‘doSomethingAfterFiveSeconds()’, 5000);<br>而是用：<br>1 setInterval(doSomethingPeriodically, 1000);<br>2 setTimeout(doSomethingAfterFiveSeconds, 5000);</p>
<h2 id="4-使用switch-case代替一大叠的if-else"><a href="#4-使用switch-case代替一大叠的if-else" class="headerlink" title="4 使用switch/case代替一大叠的if/else"></a>4 使用switch/case代替一大叠的if/else</h2><p>其实，switch/case中的case条件，还可以这样写：<br>function getCategory(age) {<br>    var category = “”;<br>    switch (true) {<br>        case isNaN(age):<br>            category = “not an age”;<br>            break;<br>        case (age &gt;= 50):<br>            category = “Old”;<br>            break;<br>        case (age &lt;= 20):<br>            category = “Baby”;<br>            break;<br>        default:<br>            category = “Young”;<br>            break;<br>    };<br>    return category;<br>}<br>getCategory(5);  // 将返回 “Baby”</p>
<h2 id="5-HTML字段转换函数"><a href="#5-HTML字段转换函数" class="headerlink" title="5 HTML字段转换函数"></a>5 HTML字段转换函数</h2><pre><code>function escapeHTML(text) {  
var replacements= {&quot;&lt;&quot;: &quot;&amp;lt;&quot;, &quot;&gt;&quot;: &quot;&amp;gt;&quot;,&quot;&amp;&quot;: &quot;&amp;amp;&quot;, &quot;\&quot;&quot;: &quot;&amp;quot;&quot;};                      
return text.replace(/[&lt;&gt;&amp;&quot;]/g, function(character) {  
    return replacements[character];  
}); 
</code></pre><p>}</p>
<h2 id="6-开发时注意代码结构，上线前检查并压缩JavaScript代码"><a href="#6-开发时注意代码结构，上线前检查并压缩JavaScript代码" class="headerlink" title="6 开发时注意代码结构，上线前检查并压缩JavaScript代码"></a>6 开发时注意代码结构，上线前检查并压缩JavaScript代码</h2><p>可以使用JSLint或JSMin等工具来检查并压缩代码。</p>
<h2 id="7-临时存储用于计算和查询的变量"><a href="#7-临时存储用于计算和查询的变量" class="headerlink" title="7 临时存储用于计算和查询的变量"></a>7 临时存储用于计算和查询的变量</h2><p>在jQuery选择器中，可以临时存储整个DOM元素。<br>var navright = document.querySelector(‘#right’);<br>var navleft = document.querySelector(‘#left’);<br>var navup = document.querySelector(‘#up’);<br>var navdown = document.querySelector(‘#down’);</p>
<h2 id="8-通过for-in循环检查对象的属性"><a href="#8-通过for-in循环检查对象的属性" class="headerlink" title="8 通过for-in循环检查对象的属性"></a>8 通过for-in循环检查对象的属性</h2><p>下面这样的用法，可以防止迭代的时候进入到对象的原型属性中。<br>for (var name in object) {<br>    if (object.hasOwnProperty(name)) {<br>        // do something with name<br>    }<br>}</p>
<h2 id="9-浮点计算的问题"><a href="#9-浮点计算的问题" class="headerlink" title="9 浮点计算的问题"></a>9 浮点计算的问题</h2><p>1 0.1 + 0.2 === 0.3 // is false<br>2 9007199254740992 + 1 // is equal to 9007199254740992<br>3 9007199254740992 + 2 // is equal to 9007199254740994</p>
<p>为什么呢？因为0.1+0.2等于0.30000000000000004。JavaScript的数字都遵循IEEE 754标准构建，在内部都是64位浮点小数表示，具体可以参见JavaScript中的数字是如何编码的.</p>
<p>可以通过使用toFixed()和toPrecision()来解决这个问题。</p>
<h2 id="10-在条件中使用逻辑与或"><a href="#10-在条件中使用逻辑与或" class="headerlink" title="10 在条件中使用逻辑与或"></a>10 在条件中使用逻辑与或</h2><p>1 var foo = 10;<br>2 foo == 10 &amp;&amp; doSomething(); // is the same thing as if (foo == 10) doSomething();<br>3 foo == 5 || doSomething(); // is the same thing as if (foo != 5) doSomething();</p>
<h2 id="11-使用length属性截断数组"><a href="#11-使用length属性截断数组" class="headerlink" title="11 使用length属性截断数组"></a>11 使用length属性截断数组</h2><p>前面的例子中用length属性清空数组，同样还可用它来截断数组：<br>1 var myArray = [12 , 222 , 1000 , 124 , 98 , 10 ];<br>2 myArray.length = 4; // myArray will be equal to [12 , 222 , 1000 , 124].<br>与此同时，如果把length属性变大，数组的长度值变会增加，会使用undefined来作为新的元素填充。length是一个可写的属性。<br>1 myArray.length = 10; // the new array length is 10<br>2 myArray[myArray.length - 1] ; // undefined</p>
<h2 id="12-获取数组中的最大值和最小值"><a href="#12-获取数组中的最大值和最小值" class="headerlink" title="12 获取数组中的最大值和最小值"></a>12 获取数组中的最大值和最小值</h2><p>1 var  numbers = [5, 458 , 120 , -215 , 228 , 400 , 122205, -85411];<br>2 var maxInNumbers = Math.max.apply(Math, numbers);<br>3 var minInNumbers = Math.min.apply(Math, numbers);</p>
<h2 id="13-清空数组"><a href="#13-清空数组" class="headerlink" title="13 清空数组"></a>13 清空数组</h2><p>var myArray = [12 , 222 , 1000 ];<br>myArray.length = 0; // myArray will be equal to [].</p>
<h2 id="14-数组之间追加"><a href="#14-数组之间追加" class="headerlink" title="14 数组之间追加"></a>14 数组之间追加</h2><p>1 var array1 = [12 , “foo” , {name “Joe”} , -2458];<br>2 var array2 = [“Doe” , 555 , 100];<br>3 Array.prototype.push.apply(array1, array2);<br>4 /<em> array1 值为  [12 , “foo” , {name “Joe”} , -2458 , “Doe” , 555 , 100] </em>/</p>
<h2 id="15-字符串去空格"><a href="#15-字符串去空格" class="headerlink" title="15 字符串去空格"></a>15 字符串去空格</h2><p>Java、C#和PHP等语言都实现了专门的字符串去空格函数，但JavaScript中是没有的，可以通过下面的代码来为String对象函数一个trim函数：<br>1 String.prototype.trim = function(){return this.replace(/^\s+|\s+$/g, “”);};</p>
<h2 id="16-javascript-amp-amp-Jquery-获取各种高度"><a href="#16-javascript-amp-amp-Jquery-获取各种高度" class="headerlink" title="16 javascript &amp;&amp; Jquery 获取各种高度"></a>16 javascript &amp;&amp; Jquery 获取各种高度</h2><p>IE中：<br>document.body.clientWidth ==&gt; BODY对象宽度<br>document.body.clientHeight ==&gt; BODY对象高度<br>document.documentElement.clientWidth ==&gt; 可见区域宽度<br>document.documentElement.clientHeight ==&gt; 可见区域高度<br>FireFox中：<br>document.body.clientWidth ==&gt; BODY对象宽度<br>document.body.clientHeight ==&gt; BODY对象高度<br>document.documentElement.clientWidth ==&gt; 可见区域宽度<br>document.documentElement.clientHeight ==&gt; 可见区域高度<br>Opera中：<br>document.body.clientWidth ==&gt; 可见区域宽度<br>document.body.clientHeight ==&gt; 可见区域高度<br>document.documentElement.clientWidth ==&gt; 页面对象宽度（即BODY对象宽度加上Margin宽）<br>document.documentElement.clientHeight ==&gt; 页面对象高度（即BODY对象高度加上Margin高）</p>
<p>alert(document.body.clientWidth);  //网页可见区域宽(body)<br>alert(document.body.clientHeight);  //网页可见区域高(body)<br>alert(document.body.offsetWidth);    //网页可见区域宽(body)，包括border、margin等<br>alert(document.body.offsetHeight);   //网页可见区域宽(body)，包括border、margin等<br>alert(document.body.scrollWidth);    //网页正文全文宽，包括有滚动条时的未见区域<br>alert(document.body.scrollHeight);  //网页正文全文高，包括有滚动条时的未见区域<br>alert(document.body.scrollTop);           //网页被卷去的Top(滚动条)<br>alert(document.body.scrollLeft);           //网页被卷去的Left(滚动条)<br>alert(window.screenTop);                     //浏览器距离Top<br>alert(window.screenLeft);                     //浏览器距离Left<br>alert(window.screen.height);                //屏幕分辨率的高<br>alert(window.screen.width);                 //屏幕分辨率的宽<br>alert(window.screen.availHeight);          //屏幕可用工作区的高<br>alert(window.screen.availWidth);           //屏幕可用工作区的宽</p>
<p>Jquery<br>alert($(window).height());       //浏览器当前窗口可视区域高度<br>alert($(document).height());     //浏览器当前窗口文档的高度<br>alert($(document.body).height());//浏览器当前窗口文档body的高度<br>alert($(document.body).outerHeight(true));//浏览器当前窗口文档body的总高度 包括border padding margin<br>alert($(window).width());      //浏览器当前窗口可视区域宽度<br>alert($(document).width());    //浏览器当前窗口文档对象宽度<br>alert($(document.body).width()); //浏览器当前窗口文档body的宽度<br>alert($(document.body).outerWidth(true));//浏览器当前窗口文档body的总宽度 包括border padding margin</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-深入理解Ajax"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2016/04/26/深入理解Ajax/"
    >深入理解Ajax</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2016/04/26/深入理解Ajax/" class="article-date">
  <time datetime="2016-04-26T01:34:23.000Z" itemprop="datePublished">2016-04-26</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h3 id="深入理解Ajax"><a href="#深入理解Ajax" class="headerlink" title="深入理解Ajax"></a>深入理解Ajax</h3><p>1 什么是AJAX ,AJAX原理</p>
<p>AJAX即“Asynchronous Javascript And XML”(异步JavaScript和XML)通过在后台与服务器进行少量 数据交</p>
<p>换,AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下,对网页的某部分 进行更新。传统的</p>
<p>网页(不使用 AJAX)如果需要更新内容,必须重载整个网页页面。</p>
<p>原理:XMLHttpRequest</p>
<p>2 使用异步加载获取JS数据至少两种方法?<br> post,  get</p>
<p>3 什么是JSON,JSON的格式</p>
<p>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。JSON 语法是 JavaScript 对象表示 语法的子集。</p>
<pre><code>数据在键值对中

   数据由逗号分隔

   花括号保存对象

   方括号保存数组
</code></pre><p>除了AJAX还有jsonp可以与后台交互</p>
<p>4 AJAX中的跨域问题:什么是跨域?如何解决跨域问题?</p>
<p>域不一样的,即为跨域,包括(协议,域名,端又号) </p>
<p>解决跨域问题方法：</p>
<ul>
<li><p>1.// 指定允许其他域名访问</p>
<p>  header(‘Access-Control-Allow-Origin:*’);</p>
</li>
<li>2.使用jsonp</li>
</ul>
<p>5 AJAX的流程是什么?</p>
<ul>
<li><p>1.客户端产生js的事件</p>
</li>
<li><p>2.创建XMLHttpRequest对象 3.对XMLHttpRequest进行配置 4.通过AJAX引擎发送异步请求 5.服务器端接收请</p>
</li>
</ul>
<p>求并且处理请求,返回html或者xml内容 6.XML调用一个callback()处理响应回来的内容 7.页面局部刷新</p>
<p>6 AJAX如何调用JSON数据？  xml.responseText</p>
<p>7 AJAX能够处理哪些格式的文件</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest</a><br>XMLHttpRequest2.0 新增了多种类型 支持txt,json,js,图片,文档等等…</li>
</ul>
<p>8 AJAX实现表单验证用户注册流程</p>
<ul>
<li>用户触发ajax请求,后台接又返回json格式字符串</li>
</ul>
<p>9  JSON数据的解析方法</p>
<pre><code>* 1.JSON.parse(json)

* 2.new Function(“return ” + json) (); 3.eval(“(”+json+”)”)
</code></pre><p>10 如何转化成JSON字符串</p>
<pre><code>JSON.stringify(json)
</code></pre><p>11 说明异步请求的get和post方法的区别</p>
<pre><code>1.使用Get请求时,参数在URL中显示,而使用Post方式,则不会显示出来 

 2.使用Get请求发送数据量小,Post请求发送数据量大
</code></pre><p>12 列举AJAX的优势 </p>
<p>传统的Web应用交互由用户触发一个HTTP请求到服务器,服务器对其进行处理后再返回一个新的 HTHL页到客户端, 每当服务器处理客户端提交的请求时,客户都只能空闲等待,并且哪怕只是一次很小的交互、 只需从服务器端得到很简单的一个数据,都要返回一个完整的HTML页,而用户每次都要浪费时间和带宽去重新 读取整个页面。这个做法浪费了许多带宽,由于每次应用的交互都需要向服务器发送请求,应用的响应时间就 依赖于服务器的响应时间。这导致了用户界面的响应比本地应用慢得多。</p>
<p>与此不同,AJAX应用可以仅向服务器发送并取回必需的数据,它使用SOAP或其它一些基于XML的Web Service接又,并在客户端采用JavaScript处理来自服务器的响应。因为在服务器和浏览器之间交换的数据大量减 少,结果我们就能看到响应更快的应用。同时很多的处理工作可以在发出请求的客户端机器上完成,所以Web 服务器的处理时间也减少了。</p>
<p>13 AJAX中创建请求的兼容性处理</p>
<pre><code>var xmlHttp = window.XMLHttpRequest ? new XMLHttpRequest() : new     ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);
</code></pre><p> 14 对于request.status的http状态码 用于表示网页服务器HTTP响应状态的3位数字代</p>
<p>码。1,2,3,4,5开头的状态码分别代表什么(提示:404页面表示禁止访问等)</p>
<p>1xx(临时响应)表示临时响应并需要请求者继续执行操作的状态代码。</p>
<p>2xx (成功)表示成功处理了请求的状态代码。</p>
<p>3xx (重定向) 表示要完成请求,需要进一步操作。 通常,这些状态代码用来重定向。</p>
<p>4xx(请求错误) 这些状态代码表示请求可能出错,妨碍了服务器的处理。 </p>
<p>5xx(服务器错误)这些状态代码表示服务器在尝试处理请求时发生内部错</p>
<p>误。 这些错误可能是服务器</p>
<p>15  下列对get和post的区别描述错误的是(C )</p>
<p>A、get比post更常用 </p>
<p>B、get发送信息为明文发送,安全性较差</p>
<p>C、get的性能只有post的1/3 </p>
<p>D、get传输数据是通过URL进行的 </p>
<p>16 如何将js对象转化成JSON字符串( D )<br>A、JSON.parseInt() B、JSON.parse() C、JSON.string () D、JSON.stringify ()</p>
<p>17 AJAX流程</p>
<pre><code>var xhr = window.XMLHttpRequest ?
new XMLHttpRequest() : new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;) ;
 /*创建 一个AJAX对象*/

xhr.open(type,url);

//请求方式为post时需要加上
xhr.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);

xhr.send();

xhr.onreadystatechange = function(){

    if(xhr.readyState === 4 &amp;&amp; xhr.status === 200){
        //doSometing

        &lt;!--解析数据--&gt;
        var data = xhr.responseText;

        &lt;!--回调函数--&gt;
        callback(data);
        }
    }
</code></pre><p>18 AJAX的工作原理</p>
<p>Ajax的工作原理相当于在用户和服务器之间加了—个中间层(AJAX引擎),使用户操作与服务器响应异步化。 并不是所有的用户请求都提交给服务器,像—些数据验证和数据处理等都交给Ajax引擎自己来做, 只有确定需要 从服务器读取新数据时再由Ajax引擎代为向服务器提交请求。<br>Ajax其核心有JavaScript、XMLHTTPRequest、DOM对象组成,通过XmlHttpRequest对象来向服务器发异 步请求,从服务器获得数据,然后用JavaScript来操作DOM而更新页面。这其中最关键的一步就是从服务器获 得请求数据。</p>
<p>第一步:创建ajax对象(XMLHttpRequest/ActiveXObject(Microsoft.XMLHttp)) 第二步:判断数据传输方式(GET/POST)</p>
<p>第三步:打开链接 open()</p>
<p>第四步:发送 send() 当ajax对象完成第四步(onreadystatechange)数据接收完成,判断http响应状态(status)200-300之间或</p>
<p>者304(缓存)执行回调函数 注意:检测XMLHttpRequest对象的readyState属性,该属性表示请求/响应过程的当前活动阶段,属</p>
<p>性值如下:</p>
<p>0:未初始化。尚未调用open()方法</p>
<p>1:启动。已经调用open()方法,但尚未调用send()方法 2:发送。已经调用send()方法,但尚未接收到响应</p>
<p>3:接收。已经接收到部分响应数据</p>
<p>4: 完成。已经接收到全部响应数据,而且已经可以在客户端使用了(如果写原生的js ajax请求需要等到<br>readyState==4的时候再做处理)其他的js库已经做好处理了,放心使用</p>
<p>19 . Jsonp的意义,用法,优点和原理<br>JSONP的优点是:它不像XMLHttpRequest对象实现的Ajax请求那样受到同源策略的限制;它的兼容性更 好,在更加古老的浏览器中都 可以运行,不需要XMLHttpRequest或ActiveX的支持;并且在请求完毕后可以通 过调用callback的方式回传结果。<br>JSONP的缺点则是:它只支持GET请求而不支持POST等其它类型的HTTP请求;它只支持跨域HTTP请 求这种情况,不能解决不同域的两个页面之间如何进行JavaScript调用的问题。<br>JSONP原理<br>JSONP的最基本的原理是:动态添加一个<script>标签,而script标签的src属性是没有跨域的限制的。这 样说来,这种跨域方式其实与ajax XmlHttpRequest协议无关了。<br>这样其实”jQuery AJAX跨域问题”就成了个伪命题,jquery $.ajax方法名有误导人之嫌。<br>如果设为dataType: ‘jsonp’,这个$.ajax方法就和ajax XmlHttpRequest没什么关系了,取而代之的则是 JSONP协议。JSONP是一个非官方的协议,它允许在服务器端集成Script tags返回至客户端,通过javascript callback的形式实现跨域访问。<br>JSONP即JSON with Padding。由于同源策略的限制,XmlHttpRequest只允许请求当前源(域名、协议、 端又)的资源。如果要进行跨域请求, 我们可以通过使用html的script标记来进行跨域请求,并在响应中返回 要执行的script代码,其中可以直接使用JSON传递javascript对象。 这种跨域的通讯方式称为JSONP。<br>jsonCallback 函数jsonp1236827957501(….):是浏览器客户端注册的,获取跨域服务器上的json数据后,回 调的函数<br>Jsonp的执行过程如下:<br>首先在客户端注册一个callback (如:’jsoncallback’), 然后把callback的名字(如:jsonp1236827957501)传给服务 器。注意:服务端得到callback的数值后,要用jsonp1236827957501(……)把将要输出的json内容包括起来,此时, 服务器生成 json 数据才能被客户端正确接收。<br>然后以 javascript 语法的方式,生成一个function, function 名字就是传递上来的参数 ‘jsoncallback’的值 jsonp1236827957501 .<br>最后将 json 数据直接以入参的方式,放置到 function 中,这样就生成了一段 js 语法的文档,返回给客户 端。<br>客户端浏览器,解析script标签,并执行返回的 javascript 文档,此时javascript文档数据,作为参数, 传 入到了客户端预先定义好的 callback 函数(如上例中jquery $.ajax()方法封装的的success: function (json))里。<br>可以说jsonp的方式原理上和<script src="http://跨域/...xx.js"></script>是一致的(qq空间就是大量采用这 种方式来实现跨域数据交换的)。JSONP是一种脚本注入(Script Injection)行为,所以有一定的安全隐患。</p>
<p>20  get与post两种方式的优缺点。</p>
<p>get:</p>
<p>get是从服务器上获取数据,post是向服务器传送数据; get传送的数据量较小,不能大于2KB。post传送的数据量较大,一般被默认为不受限制。但理论上,IIS4<br>中最大量为80KB,IIS5中为100KB;<br>get安全性非常低,post安全性较高。但是执行效率却比Post方法好; get是把参数数据队列加到提交表单的ACTION属性所指的URL中,值和表单内各个字段一一对应,在<br>URL中可以看到; 在做数据查询时,建议用Get方式;</p>
<p>post:</p>
<p>post是通过HTTP post机制,将表单内各个字段与其内容放置在HTML HEADER内一起传送到ACTION属 性所指的URL地址,用户看不到这个过程;<br>所以:包含机密信息的话,建议用Post数据提交方式;而在做数据添加、修改或删除时,建议用Post方 式。</p>
<p>21 一次完整的HTTP事务是怎样一个过程?</p>
<p>a.域名解析</p>
<p>b.发起TCP的三次握手 c.建立TCP连接后发起http请求 d.服务器端响应http请求,浏览器得到html码 e.浏览器解析html代码,并请求html代码中的资源 f.浏览器对页面进行渲染并呈现给客户</p>
<p>更多详细参考地址:<a href="http://www.360doc.com/content/14/0725/20/1073512_397054861.shtml" target="_blank" rel="noopener">http://www.360doc.com/content/14/0725/20/1073512_397054861.shtml</a></p>
<p>22  CORS是什么?对于跨域请求,如何将附带凭证(HTTP Cookie及HTTP认证信息) 的请求发送至服务器?</p>
<p>跨域请求一直是网页编程中的一个难题,在过去,绝大多数人都倾向于使用JSONP来解决这一问题。 不过现在,我们可以考虑一下W3C中一项新的特性——CORS(Cross-Origin Resource Sharing)了。CORS是现 代浏览器支持跨域资源请求的一种方式。<br>解决方法:<br>当你使用XMLHttpRequest发送请求时,浏览器发现该请求不符合同源策略,会给该请求加一个请求头: Origin,后台(php或者其它接收数据方)进行一系列处理,如果确定接受请求则在返回结果中加入一个响应 头:Access-Control-Allow-Origin;浏览器判断该相应头中是否包含Origin的值,如果有则浏览器会处理响应,我 们就可以拿到响应数据,如果不包含浏览器直接驳回,这时我们无法拿到响应数据。<br>更多参考地址:<a href="www.cnblogs.com/dojo-lzz/p/4265637.html
http://www.cnblogs.com/rainman/archive/2011/02/20/1959325.html">www.cnblogs.com/dojo-lzz/p/4265637.html<br>http://www.cnblogs.com/rainman/archive/2011/02/20/1959325.html</a></p>
<p>23  浅谈一下如何避免用户多次点击造成的多次请求。</p>
<p>我们在访问有的网站,输入表单完成以后,单击提交按钮进行提交以后,提交按钮就会变为灰色,<br>用户不能再单击第二次,直到重新加载页面或者跳转。这样,可以一定程度上防止用户重复提交导致应用程序<br>上逻辑错误。</p>
<p>还有很多其他的方式进行防止重复点击提交,如<br>1&gt; 定义标志位: 点击触发请求后,标志位为false量;请求(或者包括请求后具体的业务流程处理)后,标志位为true<br>量。通过标志位来判断用户点击是否具备应有的响应。 2&gt; 卸载及重载绑定事件:<br>点击触发请求后,卸载点击事件;请求(或者包括请求后具体的业务流程<br>处理)后,重新载入绑定事</p>
<p>件。<br>3&gt; 替换(移除)按钮DOM 点击触发请求后,将按钮DOM对象替换掉(或者将之移除),自然而然此时不在具备点击事件;请求<br>(或者包括请求后具体的业务流程处理)后,给新的按钮DOM定义点击事件。 更多讲解参考:<a href="http://www.cnblogs.com/jinguangguo/archive/2013/05/20/3086925.html" target="_blank" rel="noopener">http://www.cnblogs.com/jinguangguo/archive/2013/05/20/3086925.html</a></p>
<p>24  异步加载的方式有哪些?</p>
<p>(1)defer,只支持 IE</p>
<p>(2)async:</p>
<p>(3)创建 script,插入到 DOM 中,加载完毕后 callBack </p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-bootstrap轮播图片的设计"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2016/04/05/bootstrap轮播图片的设计/"
    >bootstrap轮播图片的设计</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2016/04/05/bootstrap轮播图片的设计/" class="article-date">
  <time datetime="2016-04-05T07:06:22.000Z" itemprop="datePublished">2016-04-05</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h3 id="bootstrap轮播图片的设计"><a href="#bootstrap轮播图片的设计" class="headerlink" title="bootstrap轮播图片的设计"></a>bootstrap轮播图片的设计</h3><p><img src="http://img1.sc115.com/uploads/sc/jpg/HD/2/45.jpg" alt="http://img1.sc115.com/uploads/sc/jpg/HD/2/45.jpg"></p>
<p>一个轮播图片主要包括三个部分：</p>
<ul>
<li><p>☑ 轮播的图片</p>
</li>
<li><p>☑ 轮播图片的计数器</p>
</li>
<li><p>☑ 轮播图片的控制器</p>
</li>
</ul>
<p>复杂一点的轮播图片，每个轮播区会带有对应的标题和描述内容。那么在 Bootstrap 框架中，轮播图是如何设计的呢？</p>
<p>第一步：设计轮播图片的容器。在 Bootstrap 框架中采用 carousel 样式，并且给这个容器定义一个 ID 值，方</p>
<p>便后面采用 data 属性来声明触发。</p>
<div id="slidershow" class="carousel"></div>

<p>第二步：设计轮播图片计数器。在容器 div.carousel 的内部添加轮播图片计算器，采用 carousel-</p>
<p>indicators 样式，其主要功能是显示当前图片的播放顺序(有几张图片就放置几个li)，一般采用有顺列表来制作：</p>
<pre><code>&lt;div id=&quot;slidershow&quot; class=&quot;carousel&quot;&gt;
&lt;!-- 设置图片轮播的顺序 --&gt;
&lt;ol class=&quot;carousel-indicators&quot;&gt;
    &lt;li class=&quot;active&quot;&gt;1&lt;/li&gt;
    &lt;li&gt;2&lt;/li&gt;
    &lt;li&gt;3&lt;/li&gt;
    &lt;li&gt;4&lt;/li&gt;
    &lt;li&gt;5&lt;/li&gt;
    ...
&lt;/ol&gt;
&lt;/div&gt;
</code></pre><p>在 Bootstrap 框架中，轮播图片计数器，都是以圆点向大家呈现，其具体样式如下：</p>
<pre><code>/*bootstrap.css文件第5835行～第5863行*/
.carousel-indicators {
position: absolute; /*整个计数区域绝对定位*/
bottom: 10px; /*距容器carousel底部10px*/
z-index: 15; /*设置其在Z轴的层级*/
/*让整个计数区水平居中*/
left: 50%;
width: 60%;
padding-left: 0;
margin-left: -30%;
text-align: center;
list-style: none;
}
.carousel-indicators li {
display: inline-block;
width: 10px;
height: 10px;
margin: 1px;
text-indent: -999px;
cursor: pointer;
background-color: #000 \9;
background-color: rgba(0, 0, 0, 0);
border: 1px solid #fff;
border-radius: 10px;
}
/*设置当前状态样式*/
.carousel-indicators .active {
width: 12px;
height: 12px;
margin: 0;
background-color: #fff;
}
</code></pre><p>第三步：设计轮播图片播放区。轮播图整个效果中，播放区是最关键的一个区域，这个区域主要用来放置需要轮播的图片。这个区域使用 carousel-inner 样式来控制，而且其同样放置在 carousel 容器内，并且通过 item 容器来放置每张轮播的图片：</p>
<pre><code>&lt;div id=&quot;slidershow&quot; class=&quot;carousel&quot;&gt;
    &lt;!-- 设置图片轮播的顺序 --&gt;
       &lt;ol class=&quot;carousel-indicators&quot;&gt;
        &lt;li class=&quot;active&quot;&gt;1&lt;/li&gt;
            …
        &lt;/ol&gt;
    &lt;!-- 设置轮播图片 --&gt;
    &lt;div class=&quot;carousel-inner&quot;&gt;
        &lt;div class=&quot;item active&quot;&gt;
            &lt;a href=&quot;##&quot;&gt;&lt;img src=&quot;ll580x145.jpg&quot; alt=&quot;&quot;&gt;&lt;/a&gt;
        &lt;/div&gt;
           &lt;div class=&quot;item&quot;&gt;
            &lt;a href=&quot;##&quot;&gt;&lt;img src=&quot;580145.jpg&quot; alt=&quot;&quot;&gt;&lt;/a&gt;
        &lt;/div&gt;
                …
        &lt;div class=&quot;item&quot;&gt;
            &lt;a href=&quot;##&quot;&gt;&lt;img src=&quot;580145.jpg&quot; alt=&quot;&quot;&gt;&lt;/a&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
</code></pre><p>其主要通过 carousel-inner 来控制其样式呈现。</p>
<p> 第四步：设计轮播图片控制器。很多时候轮播图片还具有一个向前播放和向后播放的控制器。在 Carousel 中通过 carousel-control 样式配合 left 和 right 来实现。其中left表示向前播放，right表示向后播放。其同样放在carousel容器内：</p>
<pre><code> &lt;div id=&quot;slidershow&quot; class=&quot;carousel&quot;&gt;
    &lt;!-- 设置图片轮播的顺序 --&gt;
    &lt;ol class=&quot;carousel-indicators&quot;&gt;
       …
    &lt;/ol&gt;
    &lt;!-- 设置轮播图片 --&gt;
    &lt;div class=&quot;carousel-inner&quot;&gt;
        …
    &lt;/div&gt;
    &lt;!-- 设置轮播图片控制器 --&gt;
       &lt;a class=&quot;left carousel-control&quot; href=&quot;&quot; &gt;
        &lt;span class=&quot;glyphicon glyphicon-chevron-left&quot;&gt;&lt;/span&gt;
        &lt;/a&gt;
    &lt;a class=&quot;right carousel-control&quot; href=&quot;&quot;&gt;
        &lt;span class=&quot;glyphicon glyphicon-chevron-right&quot;&gt;&lt;/span&gt;
    &lt;/a&gt;
&lt;/div&gt;
</code></pre><p>通过两个 a 链接然后在内部定义要显示的小图标，一个是向前，一个是向后。<br>这两个图标都显示在图片容器的上面（z-index的值大于carousel-inner的）。</p>
<p>本文转载自 <a href="http://mp.weixin.qq.com/s?__biz=MjM5MDA2MTI1MA==&amp;mid=2649084355&amp;idx=1&amp;sn=b8f8542961fb22ec79f08d11712c6efb&amp;chksm=be5bf66e892c7f7805bc5798806a4b15e9a21de68a32996b34a37e0ef8b63ff574cef09ae2a2&amp;mpshare=1&amp;scene=23&amp;srcid=1120rw2qKTy789hDAF6IAO5R#rd" target="_blank" rel="noopener">http://mp.weixin.qq.com/s?__biz=MjM5MDA2MTI1MA==&amp;mid=2649084355&amp;idx=1&amp;sn=b8f8542961fb22ec79f08d11712c6efb&amp;chksm=be5bf66e892c7f7805bc5798806a4b15e9a21de68a32996b34a37e0ef8b63ff574cef09ae2a2&amp;mpshare=1&amp;scene=23&amp;srcid=1120rw2qKTy789hDAF6IAO5R#rd</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-正则表达式应用——实例应用"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2016/04/02/正则表达式应用——实例应用/"
    >正则表达式应用——实例应用</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2016/04/02/正则表达式应用——实例应用/" class="article-date">
  <time datetime="2016-04-02T02:14:35.000Z" itemprop="datePublished">2016-04-02</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h3 id="正则表达式应用——实例应用"><a href="#正则表达式应用——实例应用" class="headerlink" title="正则表达式应用——实例应用"></a>正则表达式应用——实例应用</h3><p>1.验证用户名和密码：（”^[a-zA-Z]\w{5,15}$”）正确格式：”[A-Z][a-z]_[0-9]”组成,并且第一个字必须为字母6~16位；</p>
<p>2.验证电话号码：（”^(\d{3,4}-)\d{7,8}$”）正确格式：xxx/xxxx-xxxxxxx/xxxxxxxx；</p>
<p>3.验证手机号码：”^1[3|4|5|7|8][0-9]\d{8}$”；</p>
<p>4.验证身份证号（15位或18位数字）：”^\d{14}[[0-9],0-9xX]”；</p>
<p>5.验证Email地址：(“^\w+([-+.]\w+)<em>@\w+([-.]\w+)</em>.\w+([-.]\w+)*$”)；</p>
<p>6.只能输入由数字和26个英文字母组成的字符串：(“^[A-Za-z0-9]+$”) ;</p>
<p>7.整数或者小数：^[0-9]+([.][0-9]+){0,1}$</p>
<p>8.只能输入数字：”^[0-9]*$”。</p>
<p>9.只能输入n位的数字：”^\d{n}$”。</p>
<p>10.只能输入至少n位的数字：”^\d{n,}$”。</p>
<p>11.只能输入m~n位的数字：”^\d{m,n}$”。</p>
<p>12.只能输入零和非零开头的数字：”^(0|[1-9][0-9]*)$”。</p>
<p>13.只能输入有两位小数的正实数：”^[0-9]+(.[0-9]{2})?$”。</p>
<p>14.只能输入有1~3位小数的正实数：”^[0-9]+(.[0-9]{1,3})?$”。</p>
<p>15.只能输入非零的正整数：”^+?[1-9][0-9]*$”。</p>
<p>16.只能输入非零的负整数：”^-[1-9][0-9]*$”。</p>
<p>17.只能输入长度为3的字符：”^.{3}$”。</p>
<p>18.只能输入由26个英文字母组成的字符串：”^[A-Za-z]+$”。</p>
<p>19.只能输入由26个大写英文字母组成的字符串：”^[A-Z]+$”。</p>
<p>20.只能输入由26个小写英文字母组成的字符串：”^[a-z]+$”。</p>
<p>21.验证是否含有^%&amp;’,;=?$\”等字符：”[%&amp;’,;=?$\^]+”。</p>
<p>22.只能输入汉字：”^[\u4e00-\u9fa5]{0,}$”。</p>
<p>23.验证URL：”^http://([\w-]+.)+[\w-]+(/[\w-./?%&amp;=]*)?$”。</p>
<p>24.验证一年的12个月：”^(0?[1-9]|1[0-2])$”正确格式为：”01”～”09”和”10”～”12”。</p>
<p>25.验证一个月的31天：”^((0?[1-9])|((1|2)[0-9])|30|31)$”正确格式为；”01”～”09”、”10”～”29”和“30”~“31”。</p>
<p>26.获取日期正则表达式：\d{4}[年|-|.]\d{\1-\12}[月|-|.]\d{\1-\31}日?    评注：可用来匹配大多数年月日信息。</p>
<p>27.匹配双字节字符(包括汉字在内)：[^\x00-\xff]      评注：可以用来计算字符串的长度（一个双字节字符长度计2，ASCII字符计1）</p>
<p>28.匹配空白行的正则表达式：\n\s*\r       评注：可以用来删除空白行</p>
<p>29.匹配HTML标记的正则表达式：&lt;(\S<em>?)[^&gt;]</em>&gt;.<em>?&lt;/&gt;|&lt;.</em>? /&gt;   评注：网上流传的版本太糟糕，上面这个也仅仅能匹配部分，对于复杂的嵌套标记依旧无能为力</p>
<p>31.匹配首尾空白字符的正则表达式：^\s<em>|\s</em>$      评注：可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式</p>
<p>33.匹配网址URL的正则表达式：[a-zA-z]+://[^\s]*     评注：网上流传的版本功能很有限，上面这个基本可以满足需求</p>
<p>35.匹配帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$  评注：表单验证时很实用</p>
<p>37.匹配腾讯QQ号：[1-9][0-9]{4,}      评注：腾讯QQ号从10 000 开始</p>
<p>39.匹配中国邮政编码：[1-9]\d{5}(?!\d)     评注：中国邮政编码为6位数字</p>
<p>41.匹配ip地址：([1-9]{1,3}.){3}[1-9]。   评注：提取ip地址时有用</p>
<p>43.匹配MAC地址：([A-Fa-f0-9]{2}\:){5}[A-Fa-f0-9]</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="浅聊:yarn-npm"
  class="article article-type-浅聊:yarn"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2016/03/29/npm/"
    >npm</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2016/03/29/npm/" class="article-date">
  <time datetime="2016-03-29T05:14:18.000Z" itemprop="datePublished">2016-03-29</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h3 id="浅聊-Yarn-vs-npm"><a href="#浅聊-Yarn-vs-npm" class="headerlink" title="浅聊:Yarn vs npm"></a>浅聊:Yarn vs npm</h3><p>原文链接<a href="https://www.sitepoint.com/yarn-vs-npm/?utm_source=javascriptweekly&amp;utm_medium=email" target="_blank" rel="noopener"> https://www.sitepoint.com/yarn-vs-npm/?utm_source=javascriptweekly&amp;utm_medium=email</a></p>
<p>译文    <a href="http://www.zcfy.cc/article/yarn-vs-npm-everything-you-need-to-know-1484.html" target="_blank" rel="noopener">http://www.zcfy.cc/article/yarn-vs-npm-everything-you-need-to-know-1484.html</a></p>
<p>Yarn 是 Facebook, Google, Exponent 和 Tilde 开发的一款新的 JavaScript 包管理工具。就像我们可以从官方文档了解那样，它的目的是解决这些团队使用 npm 面临的少数问题，即：</p>
<ul>
<li>安装的时候无法保证速度/一致性</li>
<li>安全问题，因为 npm 安装时允许运行代码</li>
</ul>
<p>但请不要惊慌！它并没有试图完全取代 npm。Yarn 同样是一个从 npm 注册源获取模块的新的 CLI 客户端。注册的方式不会有任何变化 —— 你同样可以正常获取与发布包。</p>
<p>是否每个人现在都要跳上 Yarn 这辆被大肆宣传的列车？又或者你根本没机会碰到 npm 的这些问题。本篇文章将会比较 npm 与 Yarn，最终你可以决定哪款更适合你。</p>
<h5 id="Yarn-vs-npm-功能差异"><a href="#Yarn-vs-npm-功能差异" class="headerlink" title="Yarn vs npm: 功能差异"></a>Yarn vs npm: 功能差异</h5><p>乍一看 Yarn 与 npm 很类似，但通过引擎的对比就能察觉 Yarn 的不同。</p>
<h6 id="yarn-lock-文件"><a href="#yarn-lock-文件" class="headerlink" title="yarn.lock 文件"></a>yarn.lock 文件</h6><p>npm 和 Yarn 都使用 <code>package.json</code> 来跟踪项目的依赖，版本号并非一直准确，因为你可以定义版本号范围，这样你可以选择一个主版本和次要版本的包，但让 npm 安装最新的补丁也许可以修改一些 bug。</p>
<p>理想状态下使用语义化版本发布补丁不会包含大的变化，但不幸的是这必非真理。npm 的这种策略可能导致两台拥有相同 <code>package.json</code> 文件的机子安装了不同版本的包，这可能导致一些错误。</p>
<p>为了避免包版本的错误匹配，一个确定的安装版本被固定在一个锁文件中。每次模块被添加时，Yarn 就会创建（或更新）<code>yarn.lock</code> 文件，这样你就可以保证其它机子也安装相同版本的包，同时包含了 <code>package.json</code> 中定义的一系列允许的版本。</p>
<p>在 npm 中同样可以使用 <code>npm shrinkwrap</code> 命令来生成一个锁文件，这样在使用 <code>npm install</code> 时会在读取 <code>package.json</code> 前先读取这个文件，就像 Yarn 会先读取<code>yarn.lock</code> 一样。这里的区别是 Yarn 总会自动更新 <code>yarn.lock</code>，而 npm 需要你重新操作。</p>
<h6 id="并行安装"><a href="#并行安装" class="headerlink" title="并行安装"></a>并行安装</h6><p>每当 npm 或 Yarn 需要安装一个包时，它会进行一系列的任务。在 npm 中这些任务是按包的顺序一个个执行，这意味着必须等待上一个包被完整安装才会进入下一个；Yarn 则并行的执行这些任务，提高了性能。</p>
<p>为了比较，我在没有使用 shrinkwrap/yarn.lock 的方式以及清理了缓存下使用 npm 与 Yarn 安装 express，总共安装了 42 个依赖。</p>
<ul>
<li>npm: 9 s</li>
<li>Yarn: 1.37 s</li>
</ul>
<p>我无法相信自己的眼睛，所以重复以上步骤，但得到相同结果。接着我安装 gulp 进行测试，总共安装了 195 个依赖。</p>
<ul>
<li>npm: 11 s</li>
<li>Yarn: 7.81 s</li>
</ul>
<p>似乎根据所需要安装的包的数量而有所不同，但 Yarn 依旧比较快。</p>
<h6 id="清晰的输出"><a href="#清晰的输出" class="headerlink" title="清晰的输出"></a>清晰的输出</h6><p>npm 默认情况下非常冗余，例如使用 <code>npm install</code> 时它会递归列出所有安装的信息；而 Yarn 则一点也不冗余，当可以使用其它命令时，它适当的使用 emojis 表情来减少信息（Windows 除外）。</p>
<h6 id="Yarn-vs-npm-CLI-的差异"><a href="#Yarn-vs-npm-CLI-的差异" class="headerlink" title="Yarn vs npm: CLI 的差异"></a>Yarn vs npm: CLI 的差异</h6><p>除了一些功能差异，Yarn 命令也存在一些区别。例如移除或修改了一些 npm 命令以及添加了几个有趣的命令。</p>
<h6 id="yarn-global"><a href="#yarn-global" class="headerlink" title="yarn global"></a>yarn global</h6><p>不像 npm 添加 <code>-g</code>或 <code>--global</code> 可以进行全局安装，Yarn 使用的是 <code>global</code> 前缀。不过与 npm 类似，项目依赖不推荐全局安装。</p>
<p><code>global</code> 前缀只能用于 <code>yarn add</code>, <code>yarn bin`</code>, yarn ls<code>和</code>yarn remove<code>，除</code>yarn add `外，这些命令都和 npm 等效。</p>
<h6 id="yarn-install"><a href="#yarn-install" class="headerlink" title="yarn install"></a>yarn install</h6><p><code>npm install</code> 命令会根据 <code>package.json</code> 安装依赖以及允许你添加新的模块；<code>yarn install</code> 仅会按 <code>yarn.lock</code> 或 <code>package.json</code> 里面的依赖顺序来安装模块。</p>
<h6 id="yarn-add-–dev"><a href="#yarn-add-–dev" class="headerlink" title="yarn add [–dev]"></a>yarn add [–dev]</h6><p>与 <code>npm install</code> 类似，<code>yarn add</code> 允许你添加与安装模块，就像命令的名称一样，添加依赖意味着也会算定将依赖写入 <code>package.json</code>，类似 <code>npm</code>的 <code>--save</code> 参数；<code>Yar 的--dev `</code>参数则是添加开发依赖，类似 npm 的 <code></code>–save-dev 参数。</p>
<h6 id="yarn-licenses-ls-generate-disclaimer"><a href="#yarn-licenses-ls-generate-disclaimer" class="headerlink" title="yarn licenses [ls|generate-disclaimer]"></a>yarn licenses [ls|generate-disclaimer]</h6><p>npm 没有类似命令来方便编写自己的包。 <code>yarn licenses ls</code>  列出所有已安装包的许可协议。 <code>yarn licenses generate-disclaimer</code> 生成包含已安装包许可协议的免责声明。某些协议要求使用者必须在项目中包含该协议，这时候该命令将变得非常好用。</p>
<h6 id="yarn-why"><a href="#yarn-why" class="headerlink" title="yarn why"></a>yarn why</h6><p>该命令会查找依赖关系并找出为什么会将某些包安装在你的项目中。也许你明确为什么添加，也许它只是你安装包中的一个依赖，<code>yarn why</code> 可以帮你弄找出。</p>
<h6 id="yarn-upgrade"><a href="#yarn-upgrade" class="headerlink" title="yarn upgrade"></a>yarn upgrade</h6><p>该命令会根据符合 <code>package.json</code> 设定的规则而不是 <code>yarn.lock</code> 定义的确切版本来将包更新到最新版本。如果想用 npm 来实现相同目的，可以这样执行：</p>
<pre><code>rm -rf node_modules
npm install
</code></pre><p>不要将该命令与 <code>npm update</code> 混淆，它指的是更新到自己的最新版。</p>
<h6 id="yarn-generate-lock-entry"><a href="#yarn-generate-lock-entry" class="headerlink" title="yarn generate-lock-entry"></a>yarn generate-lock-entry</h6><p><code>yarn generate-lock-entry</code> 会基于 <code>package.json</code> 设置的依赖生成 <code>yarn.lock</code> 文件，该命令与 <code>npm shrinkwrap</code> 类似，但应该小心使用，因为通过 <code>yarn add</code> 和 <code>yarn upgrade</code> 命令添加或更新依赖时会自动更新生成该锁文件。</p>
<h5 id="稳定性与可靠性"><a href="#稳定性与可靠性" class="headerlink" title="稳定性与可靠性"></a>稳定性与可靠性</h5><p>Yarn 被炒得这么火热会不会有问题？它正式发布当天就收到很多问题反馈，但官方处理问题的速度极快。这些表明社区正努力开发并修复bug。查看问题反馈的数量和类型可以发现 Yarn 在大多数用户的机子上表现的很稳定，但可能个别机子会有问题。</p>
<p>请注意虽然一个包管理器可能对你的项目非常重要，但它仅仅只是个工具，如果出了状况，恢复包不会困难，也并非要回归 npm。</p>
<h5 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h5><p>也许你了解 Node.js 与 io.js 之间的历史。简单来说：io.js 是 Node.js 一些核心开发者因为项目管理上的分歧而独立出来创建的分支。不同的是，io.js 选择了开放式管理，在不到一年的时间时，两支团队达成协议，io.js 被合并回 Node.js，无论对错，它为 Node.js 带来了相当多不错的功能。</p>
<p>我看到 npm 与 Yarn 和它们有着类似的模式，不过 Yarn 不是分支，它解决了 npm 的一些缺陷。如果 npm 从中学到东西并邀请 Facebook，Google 或其它 Yarn 的贡献者们来一起提升 npm 不是很酷吗？虽然言之过早，但我期待它会发生。</p>
<p>无论哪种结果，Yarn 前途一片光明。社区得到别人对新工具的赞扬后似乎很兴奋，不幸的是，社区并没有提供路线图，所以我不确定 Yarn 是否为我们准备了其它惊喜。</p>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>相比 npm 的默认配置，Yarn 获得不少赞同。我们可以方便生成锁文件，安装包时非常迅速并且他们会自动添加进 package.json，同时安装与使用 Yarn 的影响也很小，你可以直接在一个项目上尝试看它是否可以工作，这使得 Yarn 可以完美替代 npm。</p>
<p>我绝对推荐在一个项目中尽早使用 Yarn，如果你对安装和使用新软件持谨慎态度，可以等待几个月。毕竟 npm 久经考验，它在软件开发领域也有存在的价值。</p>
<p>使用你正确等待 npm 完成包的安装，也许这是阅读迁移指南的最佳时刻 ;)</p>
<p>你怎么想呢？你是否已经在使用 Yarn？你是否将要尝试？或者这只是一个已经支离破碎的生态系统的进一步破碎？请在下面评论区留下你的观点。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-预加载-懒加载-demo展示"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2016/03/26/预加载-懒加载-demo展示/"
    >预加载+懒加载-demo展示</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2016/03/26/预加载-懒加载-demo展示/" class="article-date">
  <time datetime="2016-03-26T02:33:25.000Z" itemprop="datePublished">2016-03-26</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h3 id="预加载-amp-amp-懒加载-demo展示"><a href="#预加载-amp-amp-懒加载-demo展示" class="headerlink" title="预加载&amp;&amp;懒加载-demo展示"></a>预加载&amp;&amp;懒加载-demo展示</h3><p>一  预加载</p>
<p>html </p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
    &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;预加载&lt;/title&gt;
    &lt;style type=&quot;text/css&quot;&gt;
        #box{
            width: 800px;
            }

    &lt;/style&gt;
    &lt;/head&gt;
    &lt;body&gt;
    &lt;div id=&quot;box&quot;&gt;&lt;/div&gt;
&lt;/body&gt;
</code></pre><p>步骤：</p>
<p>// 步骤：1 存一组图片到数组中</p>
<p>// 2 因为需要先将图片一张张加载，所以需要利用for循环。</p>
<p>// 3 图片加载前，需要先新建一个图片对象，和图片路径</p>
<p>// 4 每次新建一张图片对象，获取一个图片路径，进行加载（在此，利用index++实现每次加载下一张)</p>
<p>// 5 加载后，将图片存到一盒新的空数组中。</p>
<p>// 6 将数组添加到HTML文档的元素中</p>
<p>js:</p>
<pre><code>//图片
var imgarr=[&quot;http://d.hiphotos.baidu.com/image/h%3D200/    sign=2a5a59df74094b36c4921ced93cd7c00/18d8bc3eb13533fa997c342eaad3fd1f40345be3.jpg&quot;,&quot;http://g.hiphotos.baidu.com/image/pic/item/5882b2b7d0a20cf4c7e9bd9973094b36acaf997f.jpg&quot;,&quot;http://e.hiphotos.baidu.com/image/h%3D200/sign=c6fd3ae21d178a82d13c78a0c602737f/4e4a20a4462309f7d4896d3c710e0cf3d7cad63e.jpg&quot;,&quot;http://g.hiphotos.baidu.com/image/pic/item/0eb30f2442a7d9338e2370bcaf4bd11372f00171.jpg&quot;,&quot;http://f.hiphotos.baidu.com/image/pic/item/f11f3a292df5e0fe8429ca47596034a85edf7246.jpg&quot;,&quot;http://g.hiphotos.baidu.com/image/pic/item/08f790529822720e62e61b4e7ecb0a46f21fab5e.jpg&quot;,&quot;http://g.hiphotos.baidu.com/zhidao/pic/item/267f9e2f07082838e161fffabd99a9014d08f1f4.jpg&quot;];



var index=0;
var arr=[];
for (var i = 0; i &lt; imgarr.length; i++) {
var newobj=new Image();
newobj.src=imgarr[i];
newobj.onload=function(){
index++;
arr.push(this); // this指代的是事件的主体，也就是newobj, 而事件的主体我们一般可以用this来指代
// 当index++ 大于我们的imgarr.length时候，也就是加载完成的时候，加载条应该显示100%；
if (index&gt;=imgarr.length) {
box.innerHTML=Math.ceil(index/imgarr.length*100)+&quot;%&quot;;
loadingover(); }  }  }

function loadingover(){
    box.innerHTML=&quot;&quot;;

    for (var i = 0; i &lt; arr.length; i++){
    box.appendChild(arr[i]);   }  }
</code></pre><p>二 懒加载</p>
<p>html </p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;延时加载&lt;/title&gt;
    &lt;style type=&quot;text/css&quot;&gt;
    #div1{border:1px red solid;
               width: 80%;
               position: absolute;
               top: 500px;
               }
    #div2{border:1px red solid;
    width: 80%;
    position: absolute;
    top: 2000px;
    }
    #div3{
    border:1px red solid;
    width: 80%;
    position: absolute;
    top: 3000px;
    }
    img{
    /*img需要给定宽*/
    width: 600px;    
    height: 400px;
    }
    &lt;/style&gt;
    &lt;/head&gt;
    &lt;body&gt;
    &lt;div class=&quot;big&quot; id=&quot;div1&quot;&gt;&lt;img c=&quot;../img/18.jpg&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;big&quot; id=&quot;div2&quot;&gt;&lt;img c=&quot;../img/19.jpg&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;big&quot; id=&quot;div3&quot;&gt;&lt;img c=&quot;../img/20.jpg&quot;&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>js</p>
<pre><code>var img=document.getElementsByTagName(&apos;img&apos;);

// 图片在定位时，要找到元素最外层定位的父元素，并获取这两个元素之间的高度，一个网页会有很多个延时加载的元素，所以，可以用函数传参来封装函数。
function offset(element){
var t=element.offsetTop;
// 因为不知道子元素外有多少父级，利用while循环来获取子元素到最外层元素间的高度
 while(element){
 t+=element.offsetTop;
 element=element.offsetParent; //让参数element一级一级往上，直到element没有定位的父级为止，此时，while里的element条    件为假，循环停止，得到最后的t值
 }
 return {top:t} // 返回t值 这里的top 是一个对象，我们可以随便定义对象名
 }
// 寻找执行条件 并执行要达到的效果
window.onscroll=function(){
var scrolltop=document.body.scrollTop||document.documentElement.scrollTop;
var ch=document.documentElement.clientHeight;
// 循环每一张图片
for (var i = 0; i &lt; img.length; i++) {
//通过传参获取img的offsetHeight
var oh=offset(img[i]).top;
// if 判断条件 来判断图片在什么时候加载
if (oh&lt;scrolltop+ch-200) {
img[i].src=img[i].getAttribute(&quot;c&quot;);
}
}
}
&lt;/script&gt;
</code></pre> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-三分钟学会css3中的flexbox布局"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2016/03/17/三分钟学会css3中的flexbox布局/"
    >三分钟学会css3中的flexbox布局</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2016/03/17/三分钟学会css3中的flexbox布局/" class="article-date">
  <time datetime="2016-03-17T10:44:24.000Z" itemprop="datePublished">2016-03-17</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h3 id="三分钟学会css3中的flexbox布局"><a href="#三分钟学会css3中的flexbox布局" class="headerlink" title="三分钟学会css3中的flexbox布局"></a>三分钟学会css3中的flexbox布局</h3><p>这篇文章里我们将学习CSS里flexbox布局的几个最重要的概念，通过学习flexbox布局，你会发现以往遇到的所有的关于布局的问题，现在都可以轻松解决了。<br>我们将只关注几个核心概念，等这些核心知识掌握之后，你可以再慢慢的学习那些不重要的相关知识。</p>
<ol>
<li><p>容器和容器里的元素<br>flexbox布局的两个最重要的概念是容器(蓝色)和容器里的子元素(红色)。在本文的例子中，容器和它的子元素都是div。<br>横向布局<br>为了实现flex布局，我们需要在容器的CSS里添加如下代码：</p>
<pre><code>.container {
    display: flex;
}
</code></pre></li>
</ol>
<p>对于容器里面的子元素，我们什么都不需要做。它们会自动的按横坐标一字排开。<br>纵向布局<br>在上面的演示中，缺省排列是沿着横坐标方向的，还有一个方向是纵坐标，这个坐标轴的概念在理解flex布局中非常重要。<br>当我们在容器的CSS里添加 flex-direction: column.后，子元素的排列方向就会发生变化。</p>
<pre><code>.container {
display: flex;
flex-direction: column;
}
</code></pre><p>现在，子元素的排列方向是沿着纵坐标的方向了。</p>
<ol start="2">
<li><p>调整子元素的对齐方式<br>现在我们让子元素重新横向布局，这需要将flex-direction属性的值从 column改成 row, 子元素就会重新回到横向布局。<br>调整子元素的对齐方式，我需要使用justify-content 和 align-items 这两个属性，它们控制着子元素的在横向和纵向两方面的定位和对齐方式。<br>下面我们将要使用justify-content属性让所有子元素都居中对齐：</p>
<pre><code>.container {
display: flex;
flex-direction: row;
justify-content: center;
}
</code></pre><p>使用 align-items 属性来控制子元素的竖向对齐方式：</p>
<pre><code>.container {
    display: flex;
flex-direction: row;
justify-content: center;
align-items: center;
}
</code></pre></li>
</ol>
<p>下面的列表中显示了justify-content 和 align-items属性可以使用的属性值：</p>
<pre><code>justify-content:
* flex-start (default)
* flex-end
* center
* space-between
* space-around

align-items:
* flex-start (default)
 * flex-end
* center
* baseline
* stretch
</code></pre><p>建议大家将justify-content 、align-items和flex-direction几个属性混合使用，相互配合，看看都会达到什么样的布局效果。这样你才能正确的理解flexbox布局的布局方式。</p>
<ol start="3">
<li>子元素<br>最后，我们将学习针对子元素的一些应对flexbox布局的CSS属性。<br>比如我们想调整第一个子元素的位置，我们可以给他添加CSS属性 align-self，这个属性的属性值是和align-items是一样的用法:</li>
</ol>
<pre><code>.item1 {
  align-self: flex-end;
}
</code></pre><p>关于flexbox布局的知识远比本文介绍的这些要丰富，这总重要的几个知识点就是这些，掌握了它们，再学些其他的用法就容易多了。</p>
<p>本文转自 <a href="http://mp.weixin.qq.com/s?__biz=MjM5MDA2MTI1MA==&amp;mid=2649084363&amp;idx=1&amp;sn=bf9c5f2440caad7a8b5746894d16f3be&amp;chksm=be5bf666892c7f709a6effe503bceaf82e1fae250f9a34d1ce168c48674f539fbdd077aa2d4d&amp;mpshare=1&amp;scene=23&amp;srcid=1120l3DfEjLOj10JXjmtwnkf#rd" target="_blank" rel="noopener">http://mp.weixin.qq.com/s?__biz=MjM5MDA2MTI1MA==&amp;mid=2649084363&amp;idx=1&amp;sn=bf9c5f2440caad7a8b5746894d16f3be&amp;chksm=be5bf666892c7f709a6effe503bceaf82e1fae250f9a34d1ce168c48674f539fbdd077aa2d4d&amp;mpshare=1&amp;scene=23&amp;srcid=1120l3DfEjLOj10JXjmtwnkf#rd</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">上一页</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2021
        <i class="ri-heart-fill heart_icon"></i> 魏姣
      </li>
    </ul>
    <ul>
      <li>
        
        
        
        Powered by <a href="https://hexo.io" target="_blank">Hexo</a>
        <span class="division">|</span>
        Theme - <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></s>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="薇娇"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i></p>
  <div class="reward-box">
    
    
  </div>
</div>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/lazyload.min.js"></script>
<!-- Tocbot -->

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>
<script src="/dist/main.js"></script>
<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->

<script src="/js/busuanzi-2.3.pure.min.js"></script>

<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->

<link rel="stylesheet" href="/css/clipboard.css">
<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>


<!-- CanvasBackground -->


    
  </div>
</body>

</html>