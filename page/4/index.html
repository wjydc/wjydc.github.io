<!DOCTYPE html>


<html lang="en">


<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     薇娇
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  <link rel="stylesheet" href="/dist/main.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css">
  <link rel="stylesheet" href="/css/custom.css">
  
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
  
  

  

</head>

</html>

<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/Shen-Yu/hexo-theme-ayer"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">薇娇</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  <ul class="ads">
    
        <li>
            <a href="https://curl.qcloud.com/ezctH6FU">
                <img src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/ten_1.jpg" width="300" alt="腾讯云限时秒杀">
            </a>
        </li>
    
        <li>
            <a href="https://curl.qcloud.com/kvO7hb43">
                <img src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/ten_2.jpg" width="300" alt="云服务器全球购低至2折">
            </a>
        </li>
    
</ul>
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-原生JavaScript事件详解"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2016/01/29/原生JavaScript事件详解/"
    >原生JavaScript事件详解</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2016/01/29/原生JavaScript事件详解/" class="article-date">
  <time datetime="2016-01-29T12:18:25.000Z" itemprop="datePublished">2016-01-29</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h3 id="原生JavaScript事件详解"><a href="#原生JavaScript事件详解" class="headerlink" title="原生JavaScript事件详解"></a>原生JavaScript事件详解</h3><p>JQuery这种Write Less Do More的框架，用多了难免会对原生js眼高手低。</p>
<p>小菜其实不想写这篇博客，貌似很初级的样子，但是看到网络上连原生js事件绑定和解除都说不明白，还是决定科普一下了。</p>
<p>首先声明，小菜懂的也不是很多，只是把我的思路和大家分享一下。</p>
<h4 id="DOM0事件模型"><a href="#DOM0事件模型" class="headerlink" title="DOM0事件模型"></a>DOM0事件模型</h4><p>事件模型在不断发展，早期的事件模型称为DOM0级别。</p>
<p>DOM0事件模型，所有的浏览器都支持。</p>
<p>直接在dom对象上注册事件名称，就是DOM0写法，比如：</p>
<pre><code>document.getElementById(&quot;test&quot;).onclick = function(e){};
</code></pre><p>意思就是注册一个onclick事件。当然，它和这种写法是一个意思：</p>
<pre><code>document.getElementById(&quot;test&quot;)[&quot;onmousemove&quot;] = function(e){};
</code></pre><p>这没什么，只不过是两种访问js对象属性的方法，[]的形式主要是为了解决属性名不是合法的标识符，比如：object.123肯定报错，但是object[“123”]就避免了这个问题，与此同时，[]的写法，也把js写活了，用字符串表示属性名称，可以在运行时动态绑定事件。</p>
<p>言归正传，事件被触发时，会默认传入一个参数e，表示事件对象，通过e，我们可以获取很多有用的信息，比如点击的坐标、具体触发该事件的dom元素等等。</p>
<p>基于DOM0的事件，对于同一个dom节点而言，只能注册一个，后边注册的同种事件会覆盖之前注册的。例如：</p>
<pre><code>var btn = document.getElementById(&quot;test&quot;);
btn.onmousemove = function(e){
 alert(&quot;ok&quot;);
 };

 btn[&quot;onmousemove&quot;] = function(e){
  alert(&quot;ok1&quot;);
 };
</code></pre><p>结果会输出ok1。</p>
<p>接下来再说说this。事件触发时，this就是指该事件在哪个dom对象上触发。例如：</p>
<pre><code>var btn = document.getElementById(&quot;test&quot;);

btn.onmousemove = function(e){
  alert(this.id);
  };
</code></pre><p>结果输出test。因为事件就是在id为test的dom节点上注册的，事件触发时，this当然代表这个dom节点，可以理解为事件是被这个dom节点调用的。</p>
<p>所以，想解除事件就相当简单了，只需要再注册一次事件，把值设成null，例如：</p>
<pre><code>var btn = document.getElementById(&quot;test&quot;);
btn.onclick = function(e){
 alert(&quot;ok&quot;);
 };

  btn.onclick = null;
</code></pre><p>原理就是最后注册的事件要覆盖之前的，最后一次注册事件设置成null，也就解除了事件绑定。</p>
<p>事情还没结束，DOM0事件模型还涉及到直接写在html中的事件。例如：</p>
<pre><code>&lt;div id=&quot;test&quot; class=&quot;test&quot; onclick=&quot;exec();&quot; &gt;&lt;/div&gt;
</code></pre><p>通过这种方式注册的事件，同样遵循覆盖原则，同样只能注册一个，最后一个生效。</p>
<p>区别就是，这样注册的事件，相当于动态调用函数(有点eval的意思)，因此不会传入event对象，同时，this指向的是window，不再是触发事件的dom对象。     </p>
<h4 id="DOM2事件模型"><a href="#DOM2事件模型" class="headerlink" title="DOM2事件模型"></a>DOM2事件模型</h4><p>  DOM2事件模型相对于DOM0，小菜仅仅了解如下两点：</p>
<p> ·  DOM2支持同一dom元素注册多个同种事件。</p>
<p> ·  DOM2新增了捕获和冒泡的概念。</p>
<p> DOM2事件通过addEventListener和removeEventListener管理，当然，这是标准。</p>
<p> 但IE8及其以下版本浏览器，自娱自乐，搞出了对应的attachEvent和detachEvent，由于小菜才疏学浅，本文不做讨论。</p>
<p>addEventListener当然就是注册事件，她有三个参数，分别为：”事件名称”, “事件回调”, “捕获/冒泡”。举个例子：     </p>
<pre><code>var btn = document.getElementById(&quot;test&quot;);
btn.addEventListener(&quot;click&quot;, function(e){
 alert(&quot;ok&quot;);
 }, false);
</code></pre><p> 事件名称就不用多说了，相比DOM0，去掉了前边的on而已。</p>
<p>事件回调也很好理解，事件触发了总得通知你吧！回调时和DOM0一样，也会默认传入一个event参数，同时this是指触发该事件的dom节点。</p>
<p>最后一个参数是布尔型，true代表捕获事件，false代表冒泡事件。其实很好理解，先来个示意图：<br><img src="http://images.cnitblog.com/blog/471788/201412/282221104503701.gif" alt="http://images.cnitblog.com/blog/471788/201412/282221104503701.gif"></p>
<p> 意思就是说，某个元素触发了某个事件，最先得到通知的是window，然后是document，依次而入，直到真正触发事件的那个元素(目标元素)为止，这个过程就是捕获。接下来，事件会从目标元素开始起泡，再依次而出，直到window对象为止，这个过程就是冒泡。</p>
<p>为什么要这样设计呢？这貌似是由于深厚的历史渊源，小菜也不怎么了解，就不乱说了。</p>
<p> 由此可以看出，捕获事件要比冒泡事件先触发.</p>
<p>假设有这样的html结构：</p>
<pre><code>&lt;div id=&quot;test&quot; class=&quot;test&quot;&gt;
    &lt;div id=&quot;testInner&quot; class=&quot;test-inner&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre><p>然后我们在外层div上注册两个click事件，分别是捕获事件和冒泡事件，代码如下：</p>
<pre><code>var btn = document.getElementById(&quot;test&quot;);
//捕获事件
btn.addEventListener(&quot;click&quot;, function(e){
alert(&quot;ok1&quot;);
}, true);

//冒泡事件
btn.addEventListener(&quot;click&quot;, function(e){
 alert(&quot;ok&quot;);
 }, false);
</code></pre><p>最后，点击内层的div，先弹出ok1，后弹出ok。结合上边的原理图，外层div相当于图中的body，内层div相当于图中最下边的div，证明了捕获事件先执行，然后执行冒泡事件。</p>
<p>为什么要强调点击内层的div呢？因为真正触发事件的dom元素，必须是内层的，外层dom元素才有机会模拟捕获事件和冒泡事件，从原理图上就看出了。</p>
<p>如果在真正触发事件的dom元素上注册捕获事件和冒泡事件呢？</p>
<p>html结构同上，js代码如下：</p>
<pre><code>var btnInner = document.getElementById(&quot;testInner&quot;);
 3 //冒泡事件
 btnInner.addEventListener(&quot;click&quot;, function(e){
  alert(&quot;ok&quot;);
  }, false);
  //捕获事件
  btnInner.addEventListener(&quot;click&quot;, function(e){
  alert(&quot;ok1&quot;);
  }, true);
</code></pre><p>当然还是点击内层div，结果是先弹出ok，再弹出ok1。理论上应该先触发捕获事件，也就是先弹出ok1，但是这里比较特殊，因为我们是在真正触发事件的dom元素上注册的事件，相当于在图中的div上注册，由图可以看出真正触发事件的dom元素，是捕获事件的终点，是冒泡事件的起点，所以这里就不区分事件了，哪个先注册，就先执行哪个。本例中，冒泡事件先注册，所以先执行。</p>
<p> 这个道理适用于多个同种事件，比如说一下子注册了3个冒泡事件，那么执行顺序就按照注册的顺序来，先注册先执行。例如：</p>
<pre><code>var btnInner = document.getElementById(&quot;testInner&quot;);
btnInner.addEventListener(&quot;click&quot;, function(e){
 alert(&quot;ok&quot;);
}, false);

 btnInner.addEventListener(&quot;click&quot;, function(e){
    alert(&quot;ok1&quot;);
 }, false);

 btnInner.addEventListener(&quot;click&quot;, function(e){
     alert(&quot;ok2&quot;);
 }, false);
</code></pre><p> 结果当然是依次弹出ok、ok1、ok2.</p>
<p>为了进一步理解事件模型，还有一种场景，假如说外层div和内层div同时注册了捕获事件，那么点击内层div时，外层div的事件一定是先触发的，代码如下：</p>
<pre><code>var btn = document.getElementById(&quot;test&quot;);
var btnInner = document.getElementById(&quot;testInner&quot;);

 btnInner.addEventListener(&quot;click&quot;, function(e){
   alert(&quot;ok&quot;);
  }, true);

 btn.addEventListener(&quot;click&quot;, function(e){
     alert(&quot;ok1&quot;);
 }, true);
</code></pre><p>   结果是先弹出ok1。</p>
<p>假如外层div和内层div都是注册的冒泡事件，点击内层div时，一定是内层div事件先执行，原理相同。</p>
<p>细心的读者会发现，对于div嵌套的情况，如果点击内层的div，外层的div也会触发事件，这貌似会有问题！</p>
<p>点击的明明是内层div，但是外层div的事件也触发了，这的确是个问题。</p>
<p>其实，事件触发时，会默认传入一个event对象，前边提过了，这个event对象上有一个方法：stopPropagation，通过此方法，可以阻止冒泡，这样外层div就接收不到事件了。代码如下：</p>
<pre><code>var btn = document.getElementById(&quot;test&quot;);
var btnInner = document.getElementById(&quot;testInner&quot;);

btn.addEventListener(&quot;click&quot;, function(e){
  alert(&quot;ok1&quot;);
  }, false);

 btnInner.addEventListener(&quot;click&quot;, function(e){
   //阻止冒泡
  e.stopPropagation();
    alert(&quot;ok&quot;);
  }, false);
</code></pre><p>终于要说说怎么解除事件了。解除事件语法：btn.removeEventListener(“事件名称”, “事件回调”, “捕获/冒泡”);</p>
<p> 这和绑定事件的参数一样，详细说明下：</p>
<p> ·  事件名称，就是说解除哪个事件呗。</p>
<p> ·  事件回调，是一个函数，这个函数必须和注册事件的函数是同一个。</p>
<p> ·  事件类型，布尔值，这个必须和注册事件时的类型一致。</p>
<p>也就是说，名称、回调、类型，三者共同决定解除哪个事件，缺一不可。举个例子：</p>
<pre><code>var btn = document.getElementById(&quot;test&quot;);
//将回调存储在变量中
var fn = function(e){
 alert(&quot;ok&quot;);
 };
 //绑定
 btn.addEventListener(&quot;click&quot;, fn, false);

 //解除
  btn.removeEventListener(&quot;click&quot;, fn, false);
</code></pre><p>要想注册过的事件能够被解除，必须将回调函数保存起来，否则无法解除。</p>
<p>至此，原生js事件已经讲的差不多了，小菜仅仅知道这些而已，欢迎读者补充其他知识点。</p>
<p> 在实际应用中，真正的行家不会傻傻的真的注册这么多事件，一般情况下，只需在最外层dom元素注册一次事件，然后通过捕获、冒泡机制去找到真正触发事件的dom元素，最后根据触发事件的dom元素提供的信息去调用回调。</p>
<p> 也就是说，行家会自己管理事件，而不依赖浏览器去管理，这样即可以提高效率，又保证了兼容性，JQuery不就是这么做的嘛~</p>
<p>好了，教程到此结束，希望对读者有所帮助！</p>
<p>原文链接：<a href="http://www.cnblogs.com/iyangyuan/p/4190773.html" target="_blank" rel="noopener">http://www.cnblogs.com/iyangyuan/p/4190773.html</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-javascript中常用事件"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2016/01/28/javascript中常用事件/"
    >javascript中常用事件</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2016/01/28/javascript中常用事件/" class="article-date">
  <time datetime="2016-01-28T06:06:06.000Z" itemprop="datePublished">2016-01-28</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>一 获取事件对象 </p>
<pre><code>document.onmouseover=function(){
console.log(&quot;a&quot;)}
由于火狐的兼容性问题，所以通过传参来解决兼容性问题
document.onclick=function(a){
var ev=a||window.event;
console.log(ev)
}
</code></pre><p>二获取鼠标当前位置clientX\clientY </p>
<pre><code>event.clientX 在可视区中,鼠标点击的x坐标 
event.clientY 在可视区中,鼠标点击的y坐标 
</code></pre><p>三 鼠标按下(onmousedown)和抬起(onmouseup)事件 </p>
<pre><code>demo  :使用鼠标拖拽一个div 

var box=document.getElementById(&apos;box&apos;);
document.onmousedown=function(e){
// 解决火狐兼容性问题
var evs=e||window.event; 
var divx=evs.clientX-box.offsetLeft;
var divy=evs.clientY-box.offsetTop;     
 document.onmousemove=function(b){
 // var evs=b||window.event; // 解决火狐兼容性问题
 var evb=b||window.event; 
 var divxb=evb.clientX-divx;
 var divyb=evb.clientY-divy; 
 box.style.left=divxb+&quot;px&quot;;
 box.style.top=divyb+&quot;px&quot;;
 console.log(divxb)
 }

 document.onmouseup=function(a){
 var eva=a||window.event; // 解决火狐兼容性问题
 document.onmousemove=&quot;null&quot;;
  }
  }
</code></pre><p>四 鼠标双击事件:ondblclick</p>
<p>五  组织默认事件的2中方法：</p>
<p>1  return  false       由于会阻止其他，所以一般放在最后执行</p>
<p>2 preventDefault    对IE6-IE8不兼容</p>
<p>六 键盘事件 keydown    keyup</p>
<p>keydown携带的一个参数是:keyCode,这个参数里的是每个按键的编码,我们可以通 过编码来判断用户按的是哪个按键</p>
<pre><code>demo  使用键盘的上下左右键控制div移动 
&lt;script type=&quot;text/javascript&quot;&gt;
var box=document.getElementById(&apos;box&apos;);
var l=0;
var t=0;
var s=0;
document.onkeydown=function(a){
var ev=a||window.event;
 if (ev.keyCode==37){
 l-=10;
 box.style.left=l+&quot;px&quot;;
 }
 else if(ev.keyCode==39){
 l+=10;
 box.style.left=l+&quot;px&quot;;
 }
else if(ev.keyCode==38){
t-=10;
box.style.top=t+&quot;px&quot;;
}

else if(ev.keyCode==40){
t+=10;
box.style.top=t+&quot;px&quot;;
}

else if(ev.keyCode==13){
s+=10;
box.style.top=s+&quot;px&quot;;
box.style.left=s+&quot;px&quot;;
}
}
</code></pre><p>一些特殊的按键 </p>
<pre><code>ctrlKey 返回boolean值,按下时为true 

shiftKey 返回boolean值,按下时为true 

altKey 返回boolean值,按下时为true 
</code></pre><p>按下以上的按键,并不会返回键盘编码,而是布尔值。我们经常在论坛中发帖,可以 按着control+回车键,就能直接发送蚊子了,我们就可以捕捉这两个按键返回的值来做 对应的处理。 </p>
<pre><code>window.onload = function () {
var oText1 = document.getElementById(&apos;text1&apos;);
var oText2 = document.getElementById(&apos;text2&apos;);
var oBtn = document.getElementById(&apos;btn&apos;);
// oBtn.onclick = function () { 
// oText1.value += oText2.value + &apos;\n&apos;; // 
oText2.value = &apos;&apos;; 
}; 
// control+enter , 
oText2.onkeydown = function (ev) {
var oEvent = ev || event;
// control 
if (oEvent.keyCode == 13 &amp;&amp; oEvent.ctrlKey) { 
// oText1.value += oText2.value + &apos;\n&apos;;
// 
oText2.value = &apos;&apos;;
}; 
} }  
</code></pre><p>七 输入框焦点事件:onfocus 焦点聚集 blur 焦点失去</p>
<p>八 事件冒泡 </p>
<p>子标签发生事件后,向父级发送该事件,一直追溯到document。如:点击一个嵌套在 body中的button,则该button的onclick事件也会传递给body、document中,触发他们 的onclick里触发的函数。<br>事件冒泡只发生在相同事件上。可通过cancelBubble=true取消相同事件冒泡</p>
<p>九 事件绑定</p>
<p>1.非IE浏览器</p>
<pre><code>target. addEventListener(type, listener, useCapture)

target: 文档节点、document、window 或 XMLHttpRequest。

type: 字符串,事件名称,不含“on”,比如“click”、“mouseover”、“keydown”等。 

listener :实现了 EventListener 接口或者是 JavaScript 中的函数。 

useCapture :是否使用捕捉,一般用 false 。
</code></pre><p>2.IE浏览器</p>
<pre><code>target.attachEvent(type,listener)

target :文档节点、document、window 或 XMLHttpRequest。 

type :字符串,事件名称,含“on”,比 如“onclick”、“onmouseover”、“onkeydown”等。

listener :实现了 EventListener 接口或者是 JavaScript 中的函数。 
</code></pre><p>3 <strong>有了绑定事件,自然有移除事件,根据是否是IE浏览器有两种写法:</strong></p>
<p>非IE浏览器 :</p>
<pre><code>target.removeEventListener(type,listener,useCapture);
</code></pre><p>IE浏览器:</p>
<pre><code>target.detachEvent(type, listener);
</code></pre><p>4 通过addEventListener()添加的事件处理程序只能使用removeEventListener()来移除；移除时传入的参数与添加处理程序时使用的参数相同。这也意味着通过addEventListener()添加的匿名函数无法移除，如下面的例子所示:</p>
<pre><code>var btn = document.getElementById(&quot;myBtn&quot;);

btn.addEventListener(&quot;click&quot;, function () {
alert(this.id);
}, false);
btn.removeEventListener(&quot;click&quot;, function () { //无效！
alert(this.id);
}, false);
</code></pre><p>在这个例子中，我使用addEventListener()添加一个事件处理程序。虽然调用removeEventListener(0是看似使用了相同的参数，但实际上，第二个参数与传入addEventListener()中的那一个完全不同的函数。而传入removeEventListener()中的事件处理程序函数必须与传入addEventListener()中的相同，如下面的例子所示：</p>
<pre><code>var btn = document.getElementById(&quot;myBtn&quot;);
var handler = function () {
alert(this.id);
};
btn.addEventListener(&quot;click&quot;, handler, false);
btn.removeEventListener(&quot;click&quot;, handler, false); //有效！
</code></pre><p>重写后的这个例子没有问题，是因为在addEventListener()和removeEventListener()中用来相同的函数。</p>
<p>5两者使用的原理:可对执行的优先级不一样,实例讲解如下: </p>
<p>IE:</p>
<pre><code>ele.attachEvent(&quot;onclick&quot;,method1);

ele.attachEvent(&quot;onclick&quot;,method2);

ele.attachEvent(&quot;onclick&quot;,method3);

执行顺序为method3-&gt;method2-&gt;method1 
</code></pre><p>非IE:</p>
<pre><code>ele.addEventListener(&quot;click&quot;,method1,false);

ele.addEventListener(&quot;click&quot;,method2,false);

ele.addEventListener(&quot;click&quot;,method3,false);

执行顺序为method1-&gt;method2-&gt;method3
</code></pre><p>6 为解决兼容性问题，利用判断</p>
<pre><code>var func = function(){}; 
//例： addEvent(window,&quot;load&quot;,func) 
function addEvent(elem, type, fn) { if (elem.attachEvent) { elem.attachEvent(&apos;on&apos; + type, fn); return;  }   if (elem.addEventListener) { elem.addEventListener(type, fn, false);    }   }   //例： removeEvent(window,&quot;load&quot;,func) 
function removeEvent(elem, type, fn) {  if (elem.detachEvent) { elem.detachEvent(&apos;on&apos; + type, fn); return;  }   if (elem.removeEventListener) { elem.removeEventListener(type, fn, false); }    } 
</code></pre> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="初步认识-Touch事件-1"
  class="article article-type-初步认识"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2016/01/14/Touch事件-1/"
    >Touch事件</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2016/01/14/Touch事件-1/" class="article-date">
  <time datetime="2016-01-14T11:12:36.000Z" itemprop="datePublished">2016-01-14</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>js的touch事件，一般用于移动端的触屏滑动，例如：</p>
<pre><code>$(function(){document.addEventListener(&quot;touchmove&quot;, _touch,     false);}) function _touch(event){alert(1);}
</code></pre><p>主要认识一下四种事件：</p>
<p>touchstart:当手指触摸屏幕时触发；即使已经有一个手指放在了屏幕上也会触发。</p>
<p>touchend:当手指从屏幕上移开时触发。</p>
<p>touchmove:当手指在屏幕上滑动时连续的触发。在这个事件发生期间，调用</p>
<p>touchcancel:当系统停止跟踪触摸时触发。</p>
<p>preventDefault()可阻止滚动。</p>
<p>以上事件的event对象上面都存在如下属性：</p>
<p>touches:表示当前跟踪的触摸操作的Touch对象的数组。</p>
<p>targetTouches:特定于事件目标的Touch对象的数组。</p>
<p>changeTouches:表示自上次触摸以来发生了什么改变的Touch对象的数组。</p>
<p>每个Touch对象包含下列属性：</p>
<p>clientX:触摸目标在视口中的X坐标。</p>
<p>clientY:触摸目标在视口中的Y坐标。</p>
<p>identifier：表示触摸的唯一ID。</p>
<p>pageX：触摸目标在页面中的x坐标。</p>
<p>pageY：触摸目标在页面中的y坐标。</p>
<p>screenX:触摸目标在屏幕中的x坐标。</p>
<p>screenY:触摸目标在屏幕中的y坐标。</p>
<p>target:触摸的DOM节点坐标</p>
<h3 id="触摸事件"><a href="#触摸事件" class="headerlink" title="触摸事件"></a>触摸事件</h3><ul>
<li>touchstart：手指放在一个DOM元素上。</li>
<li>touchmove：手指拖曳一个DOM元素。</li>
<li>touchend：手指从一个DOM元素上移开。</li>
</ul>
<p>每个触摸事件都包括了三个触摸列表：</p>
<p> touches：当前位于屏幕上的所有手指的一个列表。</p>
<p> targetTouches：位于当前DOM元素上的手指的一个列表。</p>
<p> changedTouches：涉及当前事件的手指的一个列表</p>
<h3 id="可触控应用"><a href="#可触控应用" class="headerlink" title="可触控应用"></a>可触控应用</h3><p>touchstart、touchmove和touchend事件提供了一组足够丰富的功能来支持几乎是任何类型的基于触摸的交互——其中包括常见的多点触摸手势，比如说捏缩放、旋转等待。    下面的这段代码让你使用单指触摸来四处拖曳一个DOM元素：</p>
<pre><code>var obj = document.getElementByIdx_x_x_x_x_x_x(&apos;id&apos;);
 obj.addEventListener(&apos;touchmove&apos;, function(event) 
 { // 如果这个元素的位置内只有一个手指的话
if (event.targetTouches.length == 1) 
 {
  var touch = event.targetTouches[0];
   // 把元素放在手指所在的位置
   obj.style.left = touch.pageX + &apos;px&apos;;
 obj.style.top = touch.pageY + &apos;px&apos;;
  }
}, false);
</code></pre><p>下面是一个示例，该例子显示了屏幕上当前所有的触点，它的作用就是用来感受一下设备的响应性。</p>
<pre><code>canvas.addEventListener(&apos;touchmove&apos;,   
function(event) {
   for (var i = 0; i &lt; event.touches.length; i++) {
var touch = event.touches;
 ctx.beginPath();
   ctx.arc(touch.pageX, touch.pageY, 20, 0, 2*Math.PI, true);
   ctx.fill();
   ctx.stroke();
  }
 }, false);
</code></pre><h3 id="阻止滚动"><a href="#阻止滚动" class="headerlink" title="阻止滚动"></a>阻止滚动</h3><p>一些移动设备有缺省的touchmove行为，比如说经典的iOS overscroll效果，当滚动超出了内容的界限时就引发视图反弹。这种做法在许多多点触控应用中会带来混乱，但要禁用它很容易。</p>
<pre><code>document.body.addEventListener(&apos;touchmove&apos;, function(event) {
 event.preventDefault();
}, false); 
</code></pre><p>如果你正在编写的多点触控应用涉及了复杂的多指手势的话，要小心地考虑如何响应触摸事件，因为一次要处理这么多的事情。考虑一下前面一节中的在屏幕上画出所有触点的例子，你可以在有触摸输入的时候就立刻进行绘制：</p>
<pre><code>canvas.addEventListener(&apos;touchmove&apos;, function(event) {
 renderTouches(event.touches);
},
</code></pre><p>不过这一技术并不是要随着屏幕上的手指个数的增多而扩充，替代做法是，可以跟踪所有的手指，然后在一个循环中做渲染，这样可获得更好的性能：</p>
<pre><code>var touches = []
canvas.addEventListener(&apos;touchmove&apos;, function(event) {
  touches = event.touches;
}, false);
// 设置一个每秒60帧的定时器
timer = setInterval(function() {
 renderTouches(touches);
}, 15);
</code></pre><p>提示：setInterval不太适合于动画，因为它没有考虑到浏览器自己的渲染循环。现代的桌面浏览器提供了requestAnimationFrame这一函数，基于性能和电池工作时间原因，这是一个更好的选择。一但浏览器提供了对该函数的支持，那将是首选的处理事情的方式。<br>使用targetTouches和changedTouches<br>    要记住的一点是，event.touches是与屏幕接触的所有手指的一个数组，而不仅是位于目标DOM元素上的那些。你可能会发现使用 event.targetTouches和event.changedTouches来代替event.touches更有用一些。<br>    最后一点，因为你是在为移动设备做开发，因此你应该要留心移动的最佳做法，这些在Eric Bidelman的文章中有论及，以及要了解这一W3C文档。</p>
<h3 id="设备支持"><a href="#设备支持" class="headerlink" title="设备支持"></a>设备支持</h3><p>遗憾的是，触摸事件的实现在完备性和质量方面的差别很大。我编写了一个诊断脚本来显示一些关于触摸API实现的基本信息，其中包括哪些事件是支持的，以及 touchmove事件触发的解决方案。我在Nexus One和Nexus S硬件上测试了Android2.3.3，在Xoom上测试了Android 3.0.1，以及在iPad和iPhone上测试了iOS 4.2。</p>
<h3 id="简而言之，所有被测试的浏览器都支持touchstart、touchend和touchmove事件。"><a href="#简而言之，所有被测试的浏览器都支持touchstart、touchend和touchmove事件。" class="headerlink" title="简而言之，所有被测试的浏览器都支持touchstart、touchend和touchmove事件。"></a>简而言之，所有被测试的浏览器都支持touchstart、touchend和touchmove事件。</h3><p>规范提供了额外的三个触摸事件，但被测试的浏览器没有支持它们：</p>
<pre><code>1. touchenter：移动的手指进入一个DOM元素。

2. toucheleave：移动手指离开一个DOM元素。

3. touchcancel：触摸被中断（实现规范）。
</code></pre><p> 被测试的浏览器还在每个触摸列表内部都提供了touches、targetTouches和</p>
<p> changedTouches列表。不过，被测试的浏览器没有支持radiusX、radiusY或是<br> rotationAngle属性，这些属性指明触摸屏幕的手指的形状。在一次touchmove期<br> 间，事件大约一秒钟触发60次，所有的被测试设备都是这样。</p>
<p> 转载自：<br> <a href="http://www.jb51.net/article/72823.htm" target="_blank" rel="noopener">脚本之家</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/3/">上一页</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2021
        <i class="ri-heart-fill heart_icon"></i> 魏姣
      </li>
    </ul>
    <ul>
      <li>
        
        
        
        Powered by <a href="https://hexo.io" target="_blank">Hexo</a>
        <span class="division">|</span>
        Theme - <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></s>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="薇娇"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/旅行/">旅行</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="http://shenyu-vip.lofter.com">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2019/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/lazyload.min.js"></script>
<!-- Tocbot -->

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>
<script src="/dist/main.js"></script>
<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->

<script src="/js/busuanzi-2.3.pure.min.js"></script>

<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->

<link rel="stylesheet" href="/css/clipboard.css">
<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>


<!-- CanvasBackground -->


    
  </div>
</body>

</html>