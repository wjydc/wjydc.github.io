<!DOCTYPE html>


<html lang="en">


<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     薇娇
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  <link rel="stylesheet" href="/dist/main.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css">
  <link rel="stylesheet" href="/css/custom.css">
  
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
  
  

  

</head>

</html>

<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/Shen-Yu/hexo-theme-ayer"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">薇娇</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-三分钟学会css3中的flexbox布局"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2016/03/17/三分钟学会css3中的flexbox布局/"
    >三分钟学会css3中的flexbox布局</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2016/03/17/三分钟学会css3中的flexbox布局/" class="article-date">
  <time datetime="2016-03-17T10:44:24.000Z" itemprop="datePublished">2016-03-17</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h3 id="三分钟学会css3中的flexbox布局"><a href="#三分钟学会css3中的flexbox布局" class="headerlink" title="三分钟学会css3中的flexbox布局"></a>三分钟学会css3中的flexbox布局</h3><p>这篇文章里我们将学习CSS里flexbox布局的几个最重要的概念，通过学习flexbox布局，你会发现以往遇到的所有的关于布局的问题，现在都可以轻松解决了。<br>我们将只关注几个核心概念，等这些核心知识掌握之后，你可以再慢慢的学习那些不重要的相关知识。</p>
<ol>
<li><p>容器和容器里的元素<br>flexbox布局的两个最重要的概念是容器(蓝色)和容器里的子元素(红色)。在本文的例子中，容器和它的子元素都是div。<br>横向布局<br>为了实现flex布局，我们需要在容器的CSS里添加如下代码：</p>
<pre><code>.container {
    display: flex;
}
</code></pre></li>
</ol>
<p>对于容器里面的子元素，我们什么都不需要做。它们会自动的按横坐标一字排开。<br>纵向布局<br>在上面的演示中，缺省排列是沿着横坐标方向的，还有一个方向是纵坐标，这个坐标轴的概念在理解flex布局中非常重要。<br>当我们在容器的CSS里添加 flex-direction: column.后，子元素的排列方向就会发生变化。</p>
<pre><code>.container {
display: flex;
flex-direction: column;
}
</code></pre><p>现在，子元素的排列方向是沿着纵坐标的方向了。</p>
<ol start="2">
<li><p>调整子元素的对齐方式<br>现在我们让子元素重新横向布局，这需要将flex-direction属性的值从 column改成 row, 子元素就会重新回到横向布局。<br>调整子元素的对齐方式，我需要使用justify-content 和 align-items 这两个属性，它们控制着子元素的在横向和纵向两方面的定位和对齐方式。<br>下面我们将要使用justify-content属性让所有子元素都居中对齐：</p>
<pre><code>.container {
display: flex;
flex-direction: row;
justify-content: center;
}
</code></pre><p>使用 align-items 属性来控制子元素的竖向对齐方式：</p>
<pre><code>.container {
    display: flex;
flex-direction: row;
justify-content: center;
align-items: center;
}
</code></pre></li>
</ol>
<p>下面的列表中显示了justify-content 和 align-items属性可以使用的属性值：</p>
<pre><code>justify-content:
* flex-start (default)
* flex-end
* center
* space-between
* space-around

align-items:
* flex-start (default)
 * flex-end
* center
* baseline
* stretch
</code></pre><p>建议大家将justify-content 、align-items和flex-direction几个属性混合使用，相互配合，看看都会达到什么样的布局效果。这样你才能正确的理解flexbox布局的布局方式。</p>
<ol start="3">
<li>子元素<br>最后，我们将学习针对子元素的一些应对flexbox布局的CSS属性。<br>比如我们想调整第一个子元素的位置，我们可以给他添加CSS属性 align-self，这个属性的属性值是和align-items是一样的用法:</li>
</ol>
<pre><code>.item1 {
  align-self: flex-end;
}
</code></pre><p>关于flexbox布局的知识远比本文介绍的这些要丰富，这总重要的几个知识点就是这些，掌握了它们，再学些其他的用法就容易多了。</p>
<p>本文转自 <a href="http://mp.weixin.qq.com/s?__biz=MjM5MDA2MTI1MA==&amp;mid=2649084363&amp;idx=1&amp;sn=bf9c5f2440caad7a8b5746894d16f3be&amp;chksm=be5bf666892c7f709a6effe503bceaf82e1fae250f9a34d1ce168c48674f539fbdd077aa2d4d&amp;mpshare=1&amp;scene=23&amp;srcid=1120l3DfEjLOj10JXjmtwnkf#rd" target="_blank" rel="noopener">http://mp.weixin.qq.com/s?__biz=MjM5MDA2MTI1MA==&amp;mid=2649084363&amp;idx=1&amp;sn=bf9c5f2440caad7a8b5746894d16f3be&amp;chksm=be5bf666892c7f709a6effe503bceaf82e1fae250f9a34d1ce168c48674f539fbdd077aa2d4d&amp;mpshare=1&amp;scene=23&amp;srcid=1120l3DfEjLOj10JXjmtwnkf#rd</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="深入理解css3-帧动画"
  class="article article-type-深入理解css3"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2016/03/12/帧动画/"
    >帧动画</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2016/03/12/帧动画/" class="article-date">
  <time datetime="2016-03-12T06:06:22.000Z" itemprop="datePublished">2016-03-12</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h3 id="深入理解CSS3-Animation-帧动画"><a href="#深入理解CSS3-Animation-帧动画" class="headerlink" title="深入理解CSS3 Animation 帧动画"></a>深入理解CSS3 Animation 帧动画</h3><p>我们知道CSS3的Animation有八个属性</p>
<p>animation-name</p>
<p>animation-duration</p>
<p>animation-delay</p>
<p>animation-iteration-count</p>
<p>animation-direction</p>
<p>animation-play-state</p>
<p>animation-fill-mode</p>
<p>animation-timing-function</p>
<p>其中1-7大多都有介绍，但是animation-timing-function是控制时间的属性</p>
<p>在取值中除了常用到的 三次贝塞尔曲线 以外，还有个让人比较困惑的 steps() 函数</p>
<p>animation默认以ease方式过渡，它会在每个关键帧之间插入补间动画，所以动画效果是连贯性的</p>
<p>除了ease，linear、cubic-bezier之类的过渡函数都会为其插入补间。但有些效果不需要补间，只需要关键帧之间的跳跃，这时应该使用steps过渡方式</p>
<p>animation-timing-function 规定动画的速度曲线</p>
<p><img src="http://images0.cnblogs.com/blog/329084/201507/110906325499781.png" alt="http://images0.cnblogs.com/blog/329084/201507/110906325499781.png"></p>
<p>以上w3school网站上给的使用方法，但是漏掉一个很重要的 steps</p>
<p>简单的来说，我们一直使用animation基本都是实现线性渐变的动画</p>
<p>如</p>
<p>位置在固定的时间从起点到终点</p>
<p>尺寸在固定的时间线性变化</p>
<p>颜色的线性改变等等</p>
<p>看效果 线性动画</p>
<p>截取CSS如下</p>
<pre><code>.test1 {
width: 90px;
height: 60px;
-webkit-animation-name: skyset;
-webkit-animation-duration: 2000ms;
-webkit-animation-iteration-count: infinite; /*无限循环*/
-webkit-animation-timing-function: linear;}@-webkit-keyframes skyset {
0% { background: red;}
50%{ background: blue}
100% {background: yellow;}}
</code></pre><p> timing-function:linear 定义的是一个匀速变化的动画，就是在2秒内，从红色过度到蓝色到黄色，是一个很线性的颜色变化</p>
<p>如果要实现帧动画效果而不是线性的变化就需要引入step这个值了，换句话就是没有过渡的效果，而是一帧帧的变化</p>
<p>同样可以看测试 帧动画</p>
<p> 理解steps</p>
<p>steps 函数指定了一个阶跃函数</p>
<p>第一个参数指定了时间函数中的间隔数量（必须是正整数）</p>
<p>第二个参数可选，接受 start 和 end 两个值，指定在每个间隔的起点或是终点发生阶跃变化，默认为 end。</p>
<p>step-start等同于steps(1,start)，动画分成1步，动画执行时为开始左侧端点的部分为开始；</p>
<p>step-end等同于steps(1,end)：动画分成一步，动画执行时以结尾端点为开始，默认值为end。</p>
<p>看看W3C的规范 transition-timing-function</p>
<p> steps第一个参数的错误的理解：</p>
<p>steps(5，start)</p>
<p>steps() 第一个参数 number 为指定的间隔数，即把动画分为 n 步阶段性展示，估计大多数人理解就是keyframes写的变化次数</p>
<p>例如:</p>
<pre><code>@-webkit-keyframes circle {
    0% {}
    25%{}
    50%{}
    75%{}
    100%{}
 }
</code></pre><p>我之前也一直认为steps(5，start）中的5 就是指的keyframes中的0% 25% 50% 75% 100% 分成5个间隔等分</p>
<p>为什么会出现这种理解错误，我们看一个例子</p>
<p>keyframes的关键帧是只有2个规则的时候，假如我们有一张400px长度的雪碧图</p>
<pre><code>@-webkit-keyframes circle {
    0% {background-position-x: 0;}
    100%{background-position-x: -400px;}
 }
</code></pre><p> 此刻设置steps(5，start）那么会发现5张图会出现帧动画的效果，因为steps中的5把 0% – 100%的规则，内部</p>
<p> 分成5个等分</p>
<p>实际内部会执行这样一个关键帧效果</p>
<pre><code>@-webkit-keyframes circle {
    0% {background-position-x: 0;}
    25% {background-position-x: -100px;}
    50% {background-position-x:-200px;}
    75%{background-position-x: -300px;}
    100%{background-position-x: -400px;}
 }
</code></pre><p> 将这个规则稍微修改下，加入一个50%的状态</p>
<pre><code>@-webkit-keyframes circle {
   0% {background-position-x: 0;}
   50% {background-position-x: -200px;}
   100%{background-position-x: -400px;}
}
</code></pre><p>那么同样用steps(5，start）效果就会乱套</p>
<p>此刻你会很迷惑，所以关键要理解第一个参数的针对点，首先引入一个核心点：</p>
<p>timing-function 作用于每两个关键帧之间，而不是整个动画</p>
<p>那么第一个参数很好理解了，steps的设置都是针对两个关键帧之间的，而非是整个keyframes，所以第一个参数对 - 次数对应了每次steps的变化</p>
<p>换句话说也是 0-25 之间变化5次，  25-50之间 变化5次 ，50-75 之间变化5次，以此类推</p>
<p>第二个参数可选，接受 start 和 end 两个值，指定在每个间隔的起点或是终点发生阶跃变化，默认为 end</p>
<p>通过案例看下 step-start，step-end 的区别</p>
<pre><code>@-webkit-keyframes circle {
    0% {background: red}
    50%{background: yellow}
    100% {background: blue}
}
</code></pre><p>step-start ： 黄色与蓝色相互切换</p>
<p>step-end  ： 红色与黄色相互切换</p>
<p>2个参数都会选择性的跳过前后部分，start跳过0%，end跳过100%</p>
<p>step-start在变化过程中，都是以下一帧的显示效果来填充间隔动画，所以0% 到 50%  直接就显示了黄色yellow</p>
<p>step-end与上面相反，都是以上一帧的显示效果来填充间隔动画，所以0% 到 50% 直接就显示了红色red</p>
<p>引用w3c的一张step的工作机制图</p>
<p><img src="http://images.cnitblog.com/i/596159/201406/091121212334792.png" alt="http://images.cnitblog.com/i/596159/201406/091121212334792.png"></p>
<p>总结：</p>
<p>steps函数，它可以传入两个参数，第一个是一个大于0的整数，他是将间隔动画等分成指定数目的小间隔动画，然后根据第二个参数来决定显示效果。</p>
<p>第二个参数设置后其实和step-start，step-end同义，在分成的小间隔动画中判断显示效果。可以看出：steps(1, start) 等于step-start，steps(1,end)等于step-end</p>
<p>最核心的一点就是：timing-function 作用于每两个关键帧之间，而不是整个动画</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-三张图搞懂JavaScript的原型对象与原型链"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2016/02/29/三张图搞懂JavaScript的原型对象与原型链/"
    >三张图搞懂JavaScript的原型对象与原型链</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2016/02/29/三张图搞懂JavaScript的原型对象与原型链/" class="article-date">
  <time datetime="2016-02-29T12:46:35.000Z" itemprop="datePublished">2016-02-29</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h3 id="三张图搞懂JavaScript的原型对象与原型链"><a href="#三张图搞懂JavaScript的原型对象与原型链" class="headerlink" title="三张图搞懂JavaScript的原型对象与原型链"></a>三张图搞懂JavaScript的原型对象与原型链</h3><p>原文地址：<a href="三张图搞懂JavaScript的原型对象与原型链">三张图搞懂JavaScript的原型对象与原型链</a></p>
<p>对于新人来说，JavaScript的原型是一个很让人头疼的事情，一来prototype容易与<strong>proto</strong>混淆，二来它们之间的各种指向实在有些复杂，其实市面上已经有非常多的文章在尝试说清楚，有一张所谓很经典的图，上面画了各种线条，一会连接这个一会连接那个，说实话我自己看得就非常头晕，更谈不上完全理解了。所以我自己也想尝试一下，看看能不能把原型中的重要知识点拆分出来，用最简单的图表形式说清楚。</p>
<p>我们知道原型是一个对象，其他对象可以通过它实现属性继承。但是尼玛除了prototype，又有一个<strong>proto</strong>是用来干嘛的？长那么像，让人怎么区分呢？它们都指向谁，那么混乱怎么记啊？原型链又是什么鬼？相信不少初学者甚至有一定经验的老鸟都不一定能完全说清楚，下面用三张简单的图，配合一些示例代码来理解一下。</p>
<p>1、prototype和<strong>proto</strong>的区别</p>
<p><img src="http://ac-myg6wstv.clouddn.com/2e7817d676e605e54e62.png" alt="http://ac-myg6wstv.clouddn.com/2e7817d676e605e54e62.png"></p>
<pre><code>var a = {};
console.log(a.prototype); //undefined
console.log(a.__proto__);  //Object {}

var b = function(){}
console.log(b.prototype); //b {}
console.log(b.__proto__);  //function() {}
</code></pre><p>2、<strong>proto</strong>属性指向谁</p>
<p><img src="http://ac-myg6wstv.clouddn.com/414693e5821245adeb86.png" alt="http://ac-myg6wstv.clouddn.com/414693e5821245adeb86.png"></p>
<pre><code>/*1、字面量方式*/
var a = {};
console.log(a.constructor); //function Object() { [native code] } (即构造器Object）
console.log(a.__proto__ === a.constructor.prototype); //true

/*2、构造器方式*/
var A = function (){}; var a = new A();
console.log(a.constructor); // function(){}（即构造器function A）
console.log(a.__proto__ === a.constructor.prototype); //true

/*3、Object.create()方式*/
var a1 = {a:1} 
var a2 = Object.create(a1);
console.log(a2.constructor); //function Object() { [native code] } (即构造器Object)
console.log(a2.__proto__ === a1);// true 
console.log(a2.__proto__ === a2.constructor.prototype); //false（此处即为图1中的例外情况）
</code></pre><h3 id="三、什么是原型链"><a href="#三、什么是原型链" class="headerlink" title="三、什么是原型链"></a>三、什么是原型链</h3><p><img src="http://ac-myg6wstv.clouddn.com/e8f4cc45af11650de1f8.png" alt="http://ac-myg6wstv.clouddn.com/e8f4cc45af11650de1f8.png">    </p>
<pre><code>var A = function(){};
var a = new A();
console.log(a.__proto__); //Object {}（即构造器function A 的原型对象）
console.log(a.__proto__.__proto__); //Object {}（即构造器function Object 的原型对象）
console.log(a.__proto__.__proto__.__proto__); //null
</code></pre> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-使用CSS完成元素居中的七种方法"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2016/02/22/使用CSS完成元素居中的七种方法/"
    >使用CSS完成元素居中的七种方法</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2016/02/22/使用CSS完成元素居中的七种方法/" class="article-date">
  <time datetime="2016-02-22T04:53:56.000Z" itemprop="datePublished">2016-02-22</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h3 id="使用CSS完成元素居中的七种方法"><a href="#使用CSS完成元素居中的七种方法" class="headerlink" title="使用CSS完成元素居中的七种方法"></a>使用CSS完成元素居中的七种方法</h3><p>在网页上使 HTML 元素居中看似一件很简单的事情. 至少在某些情况下是这样的，但是复杂的布局往往使一些解决方案不能很好的发挥作用。</p>
<p>在网页布局中元素水平居中比元素垂直居中要简单不少，同时实现水平居中和垂直居中往往是最难的。现在是响应式设计的时代，我们很难确切的知道元素的准确高度和宽度，所以一些方案不大适用。据我所知, 在CSS中至少有六种实现居中的方法。我将使用下面的HTML结构从简单到复杂开始讲解:</p>
<pre><code>&lt;div class=&quot;center&quot;&gt;
      &lt;img src=&quot;jimmy-choo-shoe.jpg&quot; alt&gt;&lt;/div&gt;
</code></pre><h4 id="使用text-align水平居中"><a href="#使用text-align水平居中" class="headerlink" title="使用text-align水平居中"></a>使用text-align水平居中</h4><p><img src="https://gss0.baidu.com/9fo3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/eac4b74543a982268da2a9ac8c82b9014b90ebde.jpg" alt=""></p>
<p>有时显而易见的方案是最佳的选择：</p>
<pre><code>div.center {
  text-align: center;
  background: hsl(0, 100%, 97%);}div.center img {
  width: 33%; height: auto;}
</code></pre><p> 这种方案没有使图片垂直居中：你需要给<div> 添加 padding 或者给内容添加margin-top 和 margin-bottom使容器与内容之间有一定的距离。</div></p>
<h4 id="使用-margin-auto-居中"><a href="#使用-margin-auto-居中" class="headerlink" title="使用 margin: auto 居中"></a>使用 margin: auto 居中</h4><p><img src="http://d06.res.meilishuo.net/picdetail/a/53/82/990dcf4f386c706bbd38a83d3996_715_488_1_1.jpeg" alt=""></p>
<p>这种方式实现水平居中和上面使用text-align的方法有相同局限性。</p>
<pre><code>div.center {
  background: hsl(60, 100%, 97%);}div.center img {
  display: block;
  width: 33%;
  height: auto;
  margin: 0 auto;}
</code></pre><p> 注意： 必须使用display: block使 margin: 0 auto对img元素生效。</p>
<h4 id="使用table-cell居中"><a href="#使用table-cell居中" class="headerlink" title="使用table-cell居中"></a>使用table-cell居中</h4><p><img src="http://d04.res.meilishuo.net/pic/_o/12/b2/fedaa42ff8322d23c7f838706030_500_500.jpeg" alt=""></p>
<p>使用 display: table-cell, 而不是使用table标签; 可以实现水平居中和垂直居中，但是这种方法需要添加额外的元素作为外部容器。</p>
<pre><code>&lt;div class=&quot;center-aligned&quot;&gt;
&lt;div class=&quot;center-core&quot;&gt;
    &lt;img src=&quot;jimmy-choo-shoe.jpg&quot;&gt;
&lt;/div&gt;&lt;/div&gt;
</code></pre><p>CSS:</p>
<pre><code>.center-aligned {
display: table;
background: hsl(120, 100%, 97%);
width: 100%;}.center-core {
display: table-cell;
text-align: center;
vertical-align: middle;}.center-core img {
width: 33%;
height: auto;}
</code></pre><p>注意：为了使div 不折叠必须加上 width: 100%，外部容器元素也需要加上一定高度使得内容垂直居中。给html和body设置高度后，也可以使元素在body垂直居中。此方法在IE8+浏览器上生效。</p>
<h4 id="使用absolute定位居中"><a href="#使用absolute定位居中" class="headerlink" title="使用absolute定位居中"></a>使用absolute定位居中</h4><p><img src="http://d1.tuanimg.com/imagev2/zhaoshang/700x700.fdd06d6fd9aaed1bb1a333be58f1ec72.310x310.jpg" alt=""></p>
<p>这种 方案 有非常好的跨浏览器支持。有一个缺点就是必须显式声明外部容器元素的height：</p>
<pre><code>.absolute-aligned {
position: relative;
min-height: 500px;
background: hsl(200, 100%, 97%);}.absolute-aligned img {
width: 50%;
min-width: 200px;
height: auto;
overflow: auto;
margin: auto;
position: absolute;
top: 0; left: 0;
bottom: 0; right: 0;}
</code></pre><p>Stephen在他的 博客 中演示了这种方案的几种变化。</p>
<h4 id="使用translate居中"><a href="#使用translate居中" class="headerlink" title="使用translate居中"></a>使用translate居中</h4><p><img src="http://d1.tuanimg.com/imagev2/zhaoshang/700x700.fdd06d6fd9aaed1bb1a333be58f1ec72.310x310.jpg" alt=""><br>Chris Coiyer 提出了一个使用 CSS transforms 的新方案。 同样支持水平居中和垂直居中:</p>
<pre><code>.center {
background: hsl(180, 100%, 97%);
position: relative;
min-height: 500px;}.center img {
position: absolute;
top: 50%; left: 50%;
transform: translate(-50%, -50%);
width: 30%; height: auto;}
</code></pre><p>但是有以下几种缺点:</p>
<ul>
<li>CSS transform 在部分就浏览器上需要使用 前缀。</li>
<li>不支持 IE9 以下的浏览器。</li>
<li>外部容器需要设置height （或者用其他方式设置），因为不能获取 绝对定位 的内容的高度。</li>
<li>如果内容包含文字，现在的浏览器合成技术会使文字模糊不清。 </li>
</ul>
<h4 id="使用Flexbox居中"><a href="#使用Flexbox居中" class="headerlink" title="使用Flexbox居中"></a>使用Flexbox居中</h4><p><img src="http://www.qqjia.com/z/07/tu8603_13.jpg" alt=""><br>当新旧语法差异和浏览器前缀消失时，这种方法会成为主流的居中方案。</p>
<pre><code>.center { 
background: hsl(240, 100%, 97%);
display: flex;
justify-content: center;
align-items: center;}.center img { 
width: 30%; height: auto;}
</code></pre><p>在很多方面 flexbox 是一种简单的方案， 但是它有新旧两种语法以及早期版本的IE缺乏支持 （尽管可以使用 display: table-cell作为降级方案）。</p>
<p>现在规范已经最终确定，现代浏览器也大都支持,我写了一篇详细的教程 教程。</p>
<h4 id="使用calc居中"><a href="#使用calc居中" class="headerlink" title="使用calc居中"></a>使用calc居中</h4><p><img src="http://www.qqjia.com/z/07/tu8603_13.jpg" alt=""></p>
<p>在某些情况下比flexbox更全面：</p>
<pre><code>.center {
background: hsl(300, 100%, 97%);
min-height: 600px;
position: relative;}.center img {
width: 40%;
height: auto;
position: absolute;
top: calc(50% - 20%);
left: calc(50% - 20%);}
</code></pre><p>很简单，calc 允许你基于当前的页面布局计算尺寸。在上面的简单计算中， 50% 是容器元素的中心点，但是如果只设置50%会使图片的左上角对齐div的中心位置。 我们需要把图片向左和向上各移动图片宽高的一半。计算公式为：</p>
<pre><code>top: calc(50% - (40% / 2));left: calc(50% - (40% / 2));
</code></pre><p>在现在的浏览其中你会发现，这种方法更适用于当内容的宽高为固定尺寸：</p>
<pre><code>.center img {
width: 500px; height: 500px;
position: absolute;
top: calc(50% - (300px / 2));
left: calc(50% - (300px – 2)); }
</code></pre><p> 这种方案和flex一样有许多相同的缺点： 虽然在现代浏览器中有良好的支持，但是在较早的版本中仍然需要浏览器前缀，并且不支持IE8。</p>
<pre><code> .center img {
width: 40%; height: auto;
position: absolute;
top: calc(50% - 20%);
left: calc(50% - 20%);}
</code></pre><p> 当然还有 其他更多的方案。理解这六种方案之后，web开发人员在面对元素居中的时候会有更多的选择。</p>
<p>来源<a href="http://www.zcfy.cc/article/the-new-code-seven-ways-of-centering-with-css-439.html" target="_blank" rel="noopener">http://www.zcfy.cc/article/the-new-code-seven-ways-of-centering-with-css-439.html</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-高德地图插件使用"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2016/02/02/高德地图插件使用/"
    >高德地图插件使用</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2016/02/02/高德地图插件使用/" class="article-date">
  <time datetime="2016-02-02T01:50:36.000Z" itemprop="datePublished">2016-02-02</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="高德地图"><a href="#高德地图" class="headerlink" title="高德地图"></a>高德地图</h2><h3 id="本文引自高德开放平台"><a href="#本文引自高德开放平台" class="headerlink" title="本文引自高德开放平台"></a>本文引自高德开放平台</h3><h4 id="准备页面"><a href="#准备页面" class="headerlink" title="准备页面"></a>准备页面</h4><p>在正式开始开发地图应用之前,您需要做如下几步:</p>
<p>1 在高德地图官网注册一个账号</p>
<p>2 <strong>申请JSAPI的开发者Key</strong><br>申请地址：</p>
<p><a href="http://lbs.amap.com/dev/key" target="_blank" rel="noopener">http://lbs.amap.com/dev/key</a></p>
<h3 id="引入高德地图JavaScript-API入口脚本"><a href="#引入高德地图JavaScript-API入口脚本" class="headerlink" title="引入高德地图JavaScript API入口脚本:"></a>引入高德地图JavaScript API入口脚本:</h3><pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;http://webapi.amap.com/maps?v=1.3&amp;key=您申请的key值&quot;&gt;&lt;/script&gt;
</code></pre><h3 id="创建地图容器"><a href="#创建地图容器" class="headerlink" title="创建地图容器"></a>创建地图容器</h3><p>在页面body里你想展示地图的地方创建一个div 容器，并指定id标识:</p>
<pre><code>&lt;div id=&quot;container&quot;&gt;&lt;/div&gt;
</code></pre><h3 id="指定容器大小"><a href="#指定容器大小" class="headerlink" title="指定容器大小"></a>指定容器大小</h3><p>使用CSS为地图容器设置合适的大小，比如:</p>
<pre><code>#container {width:300px; height: 180px; } 
</code></pre><h4 id="创建地图"><a href="#创建地图" class="headerlink" title="创建地图"></a>创建地图</h4><p>做完简单的准备工作之后，就可以开始创建地图了.</p>
<h3 id="按照默认属性创建地图"><a href="#按照默认属性创建地图" class="headerlink" title="按照默认属性创建地图"></a>按照默认属性创建地图</h3><p>生成一副简单地图只需要一句代码，将我们刚刚创建的div的id传给Map的构造函数即可，这个时候API将根据用户所在的城市自动进行地图中心点和级别的设定：</p>
<pre><code>var map = new AMap.Map(&apos;container&apos;);
</code></pre><ul>
<li><h3 id="设定地图的中心点和级别"><a href="#设定地图的中心点和级别" class="headerlink" title="设定地图的中心点和级别"></a>设定地图的中心点和级别</h3></li>
</ul>
<p>我们一般需要给地图按需设定中心点和坐标等属性，这里可以通过两种方式，第一种，直接在地图初始化的时候传入相关属性，center属性的值可以使经纬度的二元数组，也可以是AMap.LngLat对象，要求经度值在前，纬度值在后：</p>
<pre><code>var map = new AMap.Map(&apos;container&apos;,{
zoom: 10,
center: [116.39,39.9]});
</code></pre><p> 也可以在地图初始化过后，任何需要的地方通过方法来改变地图的中心点和级别</p>
<pre><code> var map = new AMap.Map(&apos;container&apos;);
map.setZoom(10);
map.setCenter([116.39,39.9]);
</code></pre><h4 id="添加点标记"><a href="#添加点标记" class="headerlink" title="添加点标记"></a>添加点标记</h4><p>创建好地图之后，我们就可以在地图上添加点标记了，用来标注任何用户感兴趣的位置和信息，这里使用到了AMap.Marker这个类。</p>
<ul>
<li><h4 id="点标记的创建与添加"><a href="#点标记的创建与添加" class="headerlink" title="点标记的创建与添加"></a>点标记的创建与添加</h4><p>同地图一样，点标记可以在创建的时候设定位置等属性，如果设定了map属性的话，marker点将被立即添加到地图上：</p>
<pre><code>var marker = new AMap.Marker({
position: [116.480983, 39.989628],
    map:map
});    
</code></pre><p>  也可以在创建之后按需更改这些属性:</p>
<pre><code>var marker = new AMap.Marker();
marker.setMap(map);
</code></pre></li>
<li><h4 id="点标记的移除"><a href="#点标记的移除" class="headerlink" title="点标记的移除"></a>点标记的移除</h4><p>移除的话，同样使用setMap方法,不传参数或者传入空参数：</p>
<pre><code>marker.setMap();
</code></pre></li>
</ul>
<h4 id="添加信息窗体"><a href="#添加信息窗体" class="headerlink" title="添加信息窗体"></a>添加信息窗体</h4><p>我们也可以用信息窗体InfoWindow类来向用户展示一些更详细的信息，比如点击一个点标记后，通过信息窗体来展示这个点标记在哪里</p>
<h5 id="信息窗体的创建与设定"><a href="#信息窗体的创建与设定" class="headerlink" title="信息窗体的创建与设定"></a>信息窗体的创建与设定</h5><p>信息窗体一样可以在创建的时候设定内容、偏移量、大小等属性，offset是信息窗体的锚点以position为基准位置的像素偏移量，content除了使用字符串的形式外也可以直接设定为某个创建好的DOM节点：</p>
<pre><code>var infowindow = new AMap.InfoWindow({
 content: &apos;&lt;h3&gt;高德地图&lt;/h3&gt;&lt;div&gt;高德是中国领先的数字地图内容、导航    和位置服务解决方案提供商。&lt;/div&gt;&apos;,
 offset: new AMap.Pixel(0, -30),
 size:new AMap.Size(230,0)
})
</code></pre><p>也可以在创建之后按需更改这些属性:</p>
<pre><code>infowindow.setSize(new AMap.Size(150,50));
var contentDiv = document.createElement(&apos;div&apos;);
contentDiv.innerText=&apos;我是信息窗体&apos;;
infowindow.setContent(contentDiv);
</code></pre><h5 id="如何打开信息窗体"><a href="#如何打开信息窗体" class="headerlink" title="如何打开信息窗体"></a>如何打开信息窗体</h5><p>我们可以在信息窗体创建之后立即调用其open方法将它显示在需要的位置：</p>
<pre><code>infowindow.open(map,new AMap.LngLat(116.480983, 39.989628));
</code></pre><p>也可以通过事件监听，在需要的时候才将信息窗体显示出来,比如在marker被单击的时候显示</p>
<pre><code>var clickHandle = AMap.event.addListener(marker, &apos;click&apos;,     function() {
    infowindow2.open(map, marker.getPosition())
})
</code></pre><p>当不再需要点击marker显示信息窗体这个功能的时候，可以通过如下方式移除事件绑定</p>
<pre><code>AMap.event.removeListener(clickHandle);
</code></pre><h3 id="使用高级信息窗体"><a href="#使用高级信息窗体" class="headerlink" title="使用高级信息窗体"></a>使用高级信息窗体</h3><p>除了普通的信息窗体，我们还提供了封装了周边搜索和路线规划功能在内的高级信息窗体，要使用高级信息窗体，首先需要通过plugin方法加载该插件，然后就可以和普通信息窗体一样进行创建和打开了。如果为高级信息窗体制定了panel属性，将在以panel的值为id的div上显示周边搜索或者路线规划的结果，如果需要对高级信息窗体和panel内容的样式进行修改，可以对相应classname的css进行重写：</p>
<pre><code>AMap.plugin(&apos;AMap.AdvancedInfoWindow&apos;,function(){
  var infowindow = new AMap.AdvancedInfoWindow({
content: &apos;&lt;h3 class=&quot;title&quot;&gt;高德地图&lt;/h3&gt;&apos;+
         &apos;&lt;div class=&quot;content&quot;&gt;高德是中国领先的数字地图内容、&apos;+
         &apos;导航和位置服务解决方案提供商。&lt;/div&gt;&apos;,
offset: new AMap.Pixel(0, -30),
asOrigin:false
  });
  infowindow.open(map,new AMap.LngLat(116.480983, 39.989628));
})
</code></pre><h5 id="添加工具条和比例尺"><a href="#添加工具条和比例尺" class="headerlink" title="添加工具条和比例尺"></a>添加工具条和比例尺</h5><p>高德地图JSAPI提供了大量丰富的功能控件和服务插件，下面我们来给上面做好的地图添加两个常用的控件，工具条和比例尺。</p>
<h6 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h6><p>添加控件的时候首先需要加载插件,同时需要多个插件的时候第一个参数可以设定为控件名称的数组</p>
<pre><code>AMap.plugin([&apos;AMap.ToolBar&apos;,&apos;AMap.Scale&apos;],function(){
//TODO  创建控件并添加
})
</code></pre><p>在回调函数里我们来进行控件的生成和添加:</p>
<pre><code>AMap.plugin([&apos;AMap.ToolBar&apos;,&apos;AMap.Scale&apos;],function(){
var toolBar = new AMap.ToolBar();
var scale = new AMap.Scale();
map.addControl(toolBar);
map.addControl(scale);
})
</code></pre><h5 id="移除"><a href="#移除" class="headerlink" title="移除"></a>移除</h5><p>要移除控件的时候调用地图的removeControl方法即可</p>
<pre><code>map.removeControl(toolBar);
</code></pre> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-原生JavaScript事件详解"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2016/01/29/原生JavaScript事件详解/"
    >原生JavaScript事件详解</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2016/01/29/原生JavaScript事件详解/" class="article-date">
  <time datetime="2016-01-29T12:18:25.000Z" itemprop="datePublished">2016-01-29</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h3 id="原生JavaScript事件详解"><a href="#原生JavaScript事件详解" class="headerlink" title="原生JavaScript事件详解"></a>原生JavaScript事件详解</h3><p>JQuery这种Write Less Do More的框架，用多了难免会对原生js眼高手低。</p>
<p>小菜其实不想写这篇博客，貌似很初级的样子，但是看到网络上连原生js事件绑定和解除都说不明白，还是决定科普一下了。</p>
<p>首先声明，小菜懂的也不是很多，只是把我的思路和大家分享一下。</p>
<h4 id="DOM0事件模型"><a href="#DOM0事件模型" class="headerlink" title="DOM0事件模型"></a>DOM0事件模型</h4><p>事件模型在不断发展，早期的事件模型称为DOM0级别。</p>
<p>DOM0事件模型，所有的浏览器都支持。</p>
<p>直接在dom对象上注册事件名称，就是DOM0写法，比如：</p>
<pre><code>document.getElementById(&quot;test&quot;).onclick = function(e){};
</code></pre><p>意思就是注册一个onclick事件。当然，它和这种写法是一个意思：</p>
<pre><code>document.getElementById(&quot;test&quot;)[&quot;onmousemove&quot;] = function(e){};
</code></pre><p>这没什么，只不过是两种访问js对象属性的方法，[]的形式主要是为了解决属性名不是合法的标识符，比如：object.123肯定报错，但是object[“123”]就避免了这个问题，与此同时，[]的写法，也把js写活了，用字符串表示属性名称，可以在运行时动态绑定事件。</p>
<p>言归正传，事件被触发时，会默认传入一个参数e，表示事件对象，通过e，我们可以获取很多有用的信息，比如点击的坐标、具体触发该事件的dom元素等等。</p>
<p>基于DOM0的事件，对于同一个dom节点而言，只能注册一个，后边注册的同种事件会覆盖之前注册的。例如：</p>
<pre><code>var btn = document.getElementById(&quot;test&quot;);
btn.onmousemove = function(e){
 alert(&quot;ok&quot;);
 };

 btn[&quot;onmousemove&quot;] = function(e){
  alert(&quot;ok1&quot;);
 };
</code></pre><p>结果会输出ok1。</p>
<p>接下来再说说this。事件触发时，this就是指该事件在哪个dom对象上触发。例如：</p>
<pre><code>var btn = document.getElementById(&quot;test&quot;);

btn.onmousemove = function(e){
  alert(this.id);
  };
</code></pre><p>结果输出test。因为事件就是在id为test的dom节点上注册的，事件触发时，this当然代表这个dom节点，可以理解为事件是被这个dom节点调用的。</p>
<p>所以，想解除事件就相当简单了，只需要再注册一次事件，把值设成null，例如：</p>
<pre><code>var btn = document.getElementById(&quot;test&quot;);
btn.onclick = function(e){
 alert(&quot;ok&quot;);
 };

  btn.onclick = null;
</code></pre><p>原理就是最后注册的事件要覆盖之前的，最后一次注册事件设置成null，也就解除了事件绑定。</p>
<p>事情还没结束，DOM0事件模型还涉及到直接写在html中的事件。例如：</p>
<pre><code>&lt;div id=&quot;test&quot; class=&quot;test&quot; onclick=&quot;exec();&quot; &gt;&lt;/div&gt;
</code></pre><p>通过这种方式注册的事件，同样遵循覆盖原则，同样只能注册一个，最后一个生效。</p>
<p>区别就是，这样注册的事件，相当于动态调用函数(有点eval的意思)，因此不会传入event对象，同时，this指向的是window，不再是触发事件的dom对象。     </p>
<h4 id="DOM2事件模型"><a href="#DOM2事件模型" class="headerlink" title="DOM2事件模型"></a>DOM2事件模型</h4><p>  DOM2事件模型相对于DOM0，小菜仅仅了解如下两点：</p>
<p> ·  DOM2支持同一dom元素注册多个同种事件。</p>
<p> ·  DOM2新增了捕获和冒泡的概念。</p>
<p> DOM2事件通过addEventListener和removeEventListener管理，当然，这是标准。</p>
<p> 但IE8及其以下版本浏览器，自娱自乐，搞出了对应的attachEvent和detachEvent，由于小菜才疏学浅，本文不做讨论。</p>
<p>addEventListener当然就是注册事件，她有三个参数，分别为：”事件名称”, “事件回调”, “捕获/冒泡”。举个例子：     </p>
<pre><code>var btn = document.getElementById(&quot;test&quot;);
btn.addEventListener(&quot;click&quot;, function(e){
 alert(&quot;ok&quot;);
 }, false);
</code></pre><p> 事件名称就不用多说了，相比DOM0，去掉了前边的on而已。</p>
<p>事件回调也很好理解，事件触发了总得通知你吧！回调时和DOM0一样，也会默认传入一个event参数，同时this是指触发该事件的dom节点。</p>
<p>最后一个参数是布尔型，true代表捕获事件，false代表冒泡事件。其实很好理解，先来个示意图：<br><img src="http://images.cnitblog.com/blog/471788/201412/282221104503701.gif" alt="http://images.cnitblog.com/blog/471788/201412/282221104503701.gif"></p>
<p> 意思就是说，某个元素触发了某个事件，最先得到通知的是window，然后是document，依次而入，直到真正触发事件的那个元素(目标元素)为止，这个过程就是捕获。接下来，事件会从目标元素开始起泡，再依次而出，直到window对象为止，这个过程就是冒泡。</p>
<p>为什么要这样设计呢？这貌似是由于深厚的历史渊源，小菜也不怎么了解，就不乱说了。</p>
<p> 由此可以看出，捕获事件要比冒泡事件先触发.</p>
<p>假设有这样的html结构：</p>
<pre><code>&lt;div id=&quot;test&quot; class=&quot;test&quot;&gt;
    &lt;div id=&quot;testInner&quot; class=&quot;test-inner&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre><p>然后我们在外层div上注册两个click事件，分别是捕获事件和冒泡事件，代码如下：</p>
<pre><code>var btn = document.getElementById(&quot;test&quot;);
//捕获事件
btn.addEventListener(&quot;click&quot;, function(e){
alert(&quot;ok1&quot;);
}, true);

//冒泡事件
btn.addEventListener(&quot;click&quot;, function(e){
 alert(&quot;ok&quot;);
 }, false);
</code></pre><p>最后，点击内层的div，先弹出ok1，后弹出ok。结合上边的原理图，外层div相当于图中的body，内层div相当于图中最下边的div，证明了捕获事件先执行，然后执行冒泡事件。</p>
<p>为什么要强调点击内层的div呢？因为真正触发事件的dom元素，必须是内层的，外层dom元素才有机会模拟捕获事件和冒泡事件，从原理图上就看出了。</p>
<p>如果在真正触发事件的dom元素上注册捕获事件和冒泡事件呢？</p>
<p>html结构同上，js代码如下：</p>
<pre><code>var btnInner = document.getElementById(&quot;testInner&quot;);
 3 //冒泡事件
 btnInner.addEventListener(&quot;click&quot;, function(e){
  alert(&quot;ok&quot;);
  }, false);
  //捕获事件
  btnInner.addEventListener(&quot;click&quot;, function(e){
  alert(&quot;ok1&quot;);
  }, true);
</code></pre><p>当然还是点击内层div，结果是先弹出ok，再弹出ok1。理论上应该先触发捕获事件，也就是先弹出ok1，但是这里比较特殊，因为我们是在真正触发事件的dom元素上注册的事件，相当于在图中的div上注册，由图可以看出真正触发事件的dom元素，是捕获事件的终点，是冒泡事件的起点，所以这里就不区分事件了，哪个先注册，就先执行哪个。本例中，冒泡事件先注册，所以先执行。</p>
<p> 这个道理适用于多个同种事件，比如说一下子注册了3个冒泡事件，那么执行顺序就按照注册的顺序来，先注册先执行。例如：</p>
<pre><code>var btnInner = document.getElementById(&quot;testInner&quot;);
btnInner.addEventListener(&quot;click&quot;, function(e){
 alert(&quot;ok&quot;);
}, false);

 btnInner.addEventListener(&quot;click&quot;, function(e){
    alert(&quot;ok1&quot;);
 }, false);

 btnInner.addEventListener(&quot;click&quot;, function(e){
     alert(&quot;ok2&quot;);
 }, false);
</code></pre><p> 结果当然是依次弹出ok、ok1、ok2.</p>
<p>为了进一步理解事件模型，还有一种场景，假如说外层div和内层div同时注册了捕获事件，那么点击内层div时，外层div的事件一定是先触发的，代码如下：</p>
<pre><code>var btn = document.getElementById(&quot;test&quot;);
var btnInner = document.getElementById(&quot;testInner&quot;);

 btnInner.addEventListener(&quot;click&quot;, function(e){
   alert(&quot;ok&quot;);
  }, true);

 btn.addEventListener(&quot;click&quot;, function(e){
     alert(&quot;ok1&quot;);
 }, true);
</code></pre><p>   结果是先弹出ok1。</p>
<p>假如外层div和内层div都是注册的冒泡事件，点击内层div时，一定是内层div事件先执行，原理相同。</p>
<p>细心的读者会发现，对于div嵌套的情况，如果点击内层的div，外层的div也会触发事件，这貌似会有问题！</p>
<p>点击的明明是内层div，但是外层div的事件也触发了，这的确是个问题。</p>
<p>其实，事件触发时，会默认传入一个event对象，前边提过了，这个event对象上有一个方法：stopPropagation，通过此方法，可以阻止冒泡，这样外层div就接收不到事件了。代码如下：</p>
<pre><code>var btn = document.getElementById(&quot;test&quot;);
var btnInner = document.getElementById(&quot;testInner&quot;);

btn.addEventListener(&quot;click&quot;, function(e){
  alert(&quot;ok1&quot;);
  }, false);

 btnInner.addEventListener(&quot;click&quot;, function(e){
   //阻止冒泡
  e.stopPropagation();
    alert(&quot;ok&quot;);
  }, false);
</code></pre><p>终于要说说怎么解除事件了。解除事件语法：btn.removeEventListener(“事件名称”, “事件回调”, “捕获/冒泡”);</p>
<p> 这和绑定事件的参数一样，详细说明下：</p>
<p> ·  事件名称，就是说解除哪个事件呗。</p>
<p> ·  事件回调，是一个函数，这个函数必须和注册事件的函数是同一个。</p>
<p> ·  事件类型，布尔值，这个必须和注册事件时的类型一致。</p>
<p>也就是说，名称、回调、类型，三者共同决定解除哪个事件，缺一不可。举个例子：</p>
<pre><code>var btn = document.getElementById(&quot;test&quot;);
//将回调存储在变量中
var fn = function(e){
 alert(&quot;ok&quot;);
 };
 //绑定
 btn.addEventListener(&quot;click&quot;, fn, false);

 //解除
  btn.removeEventListener(&quot;click&quot;, fn, false);
</code></pre><p>要想注册过的事件能够被解除，必须将回调函数保存起来，否则无法解除。</p>
<p>至此，原生js事件已经讲的差不多了，小菜仅仅知道这些而已，欢迎读者补充其他知识点。</p>
<p> 在实际应用中，真正的行家不会傻傻的真的注册这么多事件，一般情况下，只需在最外层dom元素注册一次事件，然后通过捕获、冒泡机制去找到真正触发事件的dom元素，最后根据触发事件的dom元素提供的信息去调用回调。</p>
<p> 也就是说，行家会自己管理事件，而不依赖浏览器去管理，这样即可以提高效率，又保证了兼容性，JQuery不就是这么做的嘛~</p>
<p>好了，教程到此结束，希望对读者有所帮助！</p>
<p>原文链接：<a href="http://www.cnblogs.com/iyangyuan/p/4190773.html" target="_blank" rel="noopener">http://www.cnblogs.com/iyangyuan/p/4190773.html</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-javascript中常用事件"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2016/01/28/javascript中常用事件/"
    >javascript中常用事件</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2016/01/28/javascript中常用事件/" class="article-date">
  <time datetime="2016-01-28T06:06:06.000Z" itemprop="datePublished">2016-01-28</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>一 获取事件对象 </p>
<pre><code>document.onmouseover=function(){
console.log(&quot;a&quot;)}
由于火狐的兼容性问题，所以通过传参来解决兼容性问题
document.onclick=function(a){
var ev=a||window.event;
console.log(ev)
}
</code></pre><p>二获取鼠标当前位置clientX\clientY </p>
<pre><code>event.clientX 在可视区中,鼠标点击的x坐标 
event.clientY 在可视区中,鼠标点击的y坐标 
</code></pre><p>三 鼠标按下(onmousedown)和抬起(onmouseup)事件 </p>
<pre><code>demo  :使用鼠标拖拽一个div 

var box=document.getElementById(&apos;box&apos;);
document.onmousedown=function(e){
// 解决火狐兼容性问题
var evs=e||window.event; 
var divx=evs.clientX-box.offsetLeft;
var divy=evs.clientY-box.offsetTop;     
 document.onmousemove=function(b){
 // var evs=b||window.event; // 解决火狐兼容性问题
 var evb=b||window.event; 
 var divxb=evb.clientX-divx;
 var divyb=evb.clientY-divy; 
 box.style.left=divxb+&quot;px&quot;;
 box.style.top=divyb+&quot;px&quot;;
 console.log(divxb)
 }

 document.onmouseup=function(a){
 var eva=a||window.event; // 解决火狐兼容性问题
 document.onmousemove=&quot;null&quot;;
  }
  }
</code></pre><p>四 鼠标双击事件:ondblclick</p>
<p>五  组织默认事件的2中方法：</p>
<p>1  return  false       由于会阻止其他，所以一般放在最后执行</p>
<p>2 preventDefault    对IE6-IE8不兼容</p>
<p>六 键盘事件 keydown    keyup</p>
<p>keydown携带的一个参数是:keyCode,这个参数里的是每个按键的编码,我们可以通 过编码来判断用户按的是哪个按键</p>
<pre><code>demo  使用键盘的上下左右键控制div移动 
&lt;script type=&quot;text/javascript&quot;&gt;
var box=document.getElementById(&apos;box&apos;);
var l=0;
var t=0;
var s=0;
document.onkeydown=function(a){
var ev=a||window.event;
 if (ev.keyCode==37){
 l-=10;
 box.style.left=l+&quot;px&quot;;
 }
 else if(ev.keyCode==39){
 l+=10;
 box.style.left=l+&quot;px&quot;;
 }
else if(ev.keyCode==38){
t-=10;
box.style.top=t+&quot;px&quot;;
}

else if(ev.keyCode==40){
t+=10;
box.style.top=t+&quot;px&quot;;
}

else if(ev.keyCode==13){
s+=10;
box.style.top=s+&quot;px&quot;;
box.style.left=s+&quot;px&quot;;
}
}
</code></pre><p>一些特殊的按键 </p>
<pre><code>ctrlKey 返回boolean值,按下时为true 

shiftKey 返回boolean值,按下时为true 

altKey 返回boolean值,按下时为true 
</code></pre><p>按下以上的按键,并不会返回键盘编码,而是布尔值。我们经常在论坛中发帖,可以 按着control+回车键,就能直接发送蚊子了,我们就可以捕捉这两个按键返回的值来做 对应的处理。 </p>
<pre><code>window.onload = function () {
var oText1 = document.getElementById(&apos;text1&apos;);
var oText2 = document.getElementById(&apos;text2&apos;);
var oBtn = document.getElementById(&apos;btn&apos;);
// oBtn.onclick = function () { 
// oText1.value += oText2.value + &apos;\n&apos;; // 
oText2.value = &apos;&apos;; 
}; 
// control+enter , 
oText2.onkeydown = function (ev) {
var oEvent = ev || event;
// control 
if (oEvent.keyCode == 13 &amp;&amp; oEvent.ctrlKey) { 
// oText1.value += oText2.value + &apos;\n&apos;;
// 
oText2.value = &apos;&apos;;
}; 
} }  
</code></pre><p>七 输入框焦点事件:onfocus 焦点聚集 blur 焦点失去</p>
<p>八 事件冒泡 </p>
<p>子标签发生事件后,向父级发送该事件,一直追溯到document。如:点击一个嵌套在 body中的button,则该button的onclick事件也会传递给body、document中,触发他们 的onclick里触发的函数。<br>事件冒泡只发生在相同事件上。可通过cancelBubble=true取消相同事件冒泡</p>
<p>九 事件绑定</p>
<p>1.非IE浏览器</p>
<pre><code>target. addEventListener(type, listener, useCapture)

target: 文档节点、document、window 或 XMLHttpRequest。

type: 字符串,事件名称,不含“on”,比如“click”、“mouseover”、“keydown”等。 

listener :实现了 EventListener 接口或者是 JavaScript 中的函数。 

useCapture :是否使用捕捉,一般用 false 。
</code></pre><p>2.IE浏览器</p>
<pre><code>target.attachEvent(type,listener)

target :文档节点、document、window 或 XMLHttpRequest。 

type :字符串,事件名称,含“on”,比 如“onclick”、“onmouseover”、“onkeydown”等。

listener :实现了 EventListener 接口或者是 JavaScript 中的函数。 
</code></pre><p>3 <strong>有了绑定事件,自然有移除事件,根据是否是IE浏览器有两种写法:</strong></p>
<p>非IE浏览器 :</p>
<pre><code>target.removeEventListener(type,listener,useCapture);
</code></pre><p>IE浏览器:</p>
<pre><code>target.detachEvent(type, listener);
</code></pre><p>4 通过addEventListener()添加的事件处理程序只能使用removeEventListener()来移除；移除时传入的参数与添加处理程序时使用的参数相同。这也意味着通过addEventListener()添加的匿名函数无法移除，如下面的例子所示:</p>
<pre><code>var btn = document.getElementById(&quot;myBtn&quot;);

btn.addEventListener(&quot;click&quot;, function () {
alert(this.id);
}, false);
btn.removeEventListener(&quot;click&quot;, function () { //无效！
alert(this.id);
}, false);
</code></pre><p>在这个例子中，我使用addEventListener()添加一个事件处理程序。虽然调用removeEventListener(0是看似使用了相同的参数，但实际上，第二个参数与传入addEventListener()中的那一个完全不同的函数。而传入removeEventListener()中的事件处理程序函数必须与传入addEventListener()中的相同，如下面的例子所示：</p>
<pre><code>var btn = document.getElementById(&quot;myBtn&quot;);
var handler = function () {
alert(this.id);
};
btn.addEventListener(&quot;click&quot;, handler, false);
btn.removeEventListener(&quot;click&quot;, handler, false); //有效！
</code></pre><p>重写后的这个例子没有问题，是因为在addEventListener()和removeEventListener()中用来相同的函数。</p>
<p>5两者使用的原理:可对执行的优先级不一样,实例讲解如下: </p>
<p>IE:</p>
<pre><code>ele.attachEvent(&quot;onclick&quot;,method1);

ele.attachEvent(&quot;onclick&quot;,method2);

ele.attachEvent(&quot;onclick&quot;,method3);

执行顺序为method3-&gt;method2-&gt;method1 
</code></pre><p>非IE:</p>
<pre><code>ele.addEventListener(&quot;click&quot;,method1,false);

ele.addEventListener(&quot;click&quot;,method2,false);

ele.addEventListener(&quot;click&quot;,method3,false);

执行顺序为method1-&gt;method2-&gt;method3
</code></pre><p>6 为解决兼容性问题，利用判断</p>
<pre><code>var func = function(){}; 
//例： addEvent(window,&quot;load&quot;,func) 
function addEvent(elem, type, fn) { if (elem.attachEvent) { elem.attachEvent(&apos;on&apos; + type, fn); return;  }   if (elem.addEventListener) { elem.addEventListener(type, fn, false);    }   }   //例： removeEvent(window,&quot;load&quot;,func) 
function removeEvent(elem, type, fn) {  if (elem.detachEvent) { elem.detachEvent(&apos;on&apos; + type, fn); return;  }   if (elem.removeEventListener) { elem.removeEventListener(type, fn, false); }    } 
</code></pre> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="初步认识-Touch事件-1"
  class="article article-type-初步认识"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2016/01/14/Touch事件-1/"
    >Touch事件</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2016/01/14/Touch事件-1/" class="article-date">
  <time datetime="2016-01-14T11:12:36.000Z" itemprop="datePublished">2016-01-14</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>js的touch事件，一般用于移动端的触屏滑动，例如：</p>
<pre><code>$(function(){document.addEventListener(&quot;touchmove&quot;, _touch,     false);}) function _touch(event){alert(1);}
</code></pre><p>主要认识一下四种事件：</p>
<p>touchstart:当手指触摸屏幕时触发；即使已经有一个手指放在了屏幕上也会触发。</p>
<p>touchend:当手指从屏幕上移开时触发。</p>
<p>touchmove:当手指在屏幕上滑动时连续的触发。在这个事件发生期间，调用</p>
<p>touchcancel:当系统停止跟踪触摸时触发。</p>
<p>preventDefault()可阻止滚动。</p>
<p>以上事件的event对象上面都存在如下属性：</p>
<p>touches:表示当前跟踪的触摸操作的Touch对象的数组。</p>
<p>targetTouches:特定于事件目标的Touch对象的数组。</p>
<p>changeTouches:表示自上次触摸以来发生了什么改变的Touch对象的数组。</p>
<p>每个Touch对象包含下列属性：</p>
<p>clientX:触摸目标在视口中的X坐标。</p>
<p>clientY:触摸目标在视口中的Y坐标。</p>
<p>identifier：表示触摸的唯一ID。</p>
<p>pageX：触摸目标在页面中的x坐标。</p>
<p>pageY：触摸目标在页面中的y坐标。</p>
<p>screenX:触摸目标在屏幕中的x坐标。</p>
<p>screenY:触摸目标在屏幕中的y坐标。</p>
<p>target:触摸的DOM节点坐标</p>
<h3 id="触摸事件"><a href="#触摸事件" class="headerlink" title="触摸事件"></a>触摸事件</h3><ul>
<li>touchstart：手指放在一个DOM元素上。</li>
<li>touchmove：手指拖曳一个DOM元素。</li>
<li>touchend：手指从一个DOM元素上移开。</li>
</ul>
<p>每个触摸事件都包括了三个触摸列表：</p>
<p> touches：当前位于屏幕上的所有手指的一个列表。</p>
<p> targetTouches：位于当前DOM元素上的手指的一个列表。</p>
<p> changedTouches：涉及当前事件的手指的一个列表</p>
<h3 id="可触控应用"><a href="#可触控应用" class="headerlink" title="可触控应用"></a>可触控应用</h3><p>touchstart、touchmove和touchend事件提供了一组足够丰富的功能来支持几乎是任何类型的基于触摸的交互——其中包括常见的多点触摸手势，比如说捏缩放、旋转等待。    下面的这段代码让你使用单指触摸来四处拖曳一个DOM元素：</p>
<pre><code>var obj = document.getElementByIdx_x_x_x_x_x_x(&apos;id&apos;);
 obj.addEventListener(&apos;touchmove&apos;, function(event) 
 { // 如果这个元素的位置内只有一个手指的话
if (event.targetTouches.length == 1) 
 {
  var touch = event.targetTouches[0];
   // 把元素放在手指所在的位置
   obj.style.left = touch.pageX + &apos;px&apos;;
 obj.style.top = touch.pageY + &apos;px&apos;;
  }
}, false);
</code></pre><p>下面是一个示例，该例子显示了屏幕上当前所有的触点，它的作用就是用来感受一下设备的响应性。</p>
<pre><code>canvas.addEventListener(&apos;touchmove&apos;,   
function(event) {
   for (var i = 0; i &lt; event.touches.length; i++) {
var touch = event.touches;
 ctx.beginPath();
   ctx.arc(touch.pageX, touch.pageY, 20, 0, 2*Math.PI, true);
   ctx.fill();
   ctx.stroke();
  }
 }, false);
</code></pre><h3 id="阻止滚动"><a href="#阻止滚动" class="headerlink" title="阻止滚动"></a>阻止滚动</h3><p>一些移动设备有缺省的touchmove行为，比如说经典的iOS overscroll效果，当滚动超出了内容的界限时就引发视图反弹。这种做法在许多多点触控应用中会带来混乱，但要禁用它很容易。</p>
<pre><code>document.body.addEventListener(&apos;touchmove&apos;, function(event) {
 event.preventDefault();
}, false); 
</code></pre><p>如果你正在编写的多点触控应用涉及了复杂的多指手势的话，要小心地考虑如何响应触摸事件，因为一次要处理这么多的事情。考虑一下前面一节中的在屏幕上画出所有触点的例子，你可以在有触摸输入的时候就立刻进行绘制：</p>
<pre><code>canvas.addEventListener(&apos;touchmove&apos;, function(event) {
 renderTouches(event.touches);
},
</code></pre><p>不过这一技术并不是要随着屏幕上的手指个数的增多而扩充，替代做法是，可以跟踪所有的手指，然后在一个循环中做渲染，这样可获得更好的性能：</p>
<pre><code>var touches = []
canvas.addEventListener(&apos;touchmove&apos;, function(event) {
  touches = event.touches;
}, false);
// 设置一个每秒60帧的定时器
timer = setInterval(function() {
 renderTouches(touches);
}, 15);
</code></pre><p>提示：setInterval不太适合于动画，因为它没有考虑到浏览器自己的渲染循环。现代的桌面浏览器提供了requestAnimationFrame这一函数，基于性能和电池工作时间原因，这是一个更好的选择。一但浏览器提供了对该函数的支持，那将是首选的处理事情的方式。<br>使用targetTouches和changedTouches<br>    要记住的一点是，event.touches是与屏幕接触的所有手指的一个数组，而不仅是位于目标DOM元素上的那些。你可能会发现使用 event.targetTouches和event.changedTouches来代替event.touches更有用一些。<br>    最后一点，因为你是在为移动设备做开发，因此你应该要留心移动的最佳做法，这些在Eric Bidelman的文章中有论及，以及要了解这一W3C文档。</p>
<h3 id="设备支持"><a href="#设备支持" class="headerlink" title="设备支持"></a>设备支持</h3><p>遗憾的是，触摸事件的实现在完备性和质量方面的差别很大。我编写了一个诊断脚本来显示一些关于触摸API实现的基本信息，其中包括哪些事件是支持的，以及 touchmove事件触发的解决方案。我在Nexus One和Nexus S硬件上测试了Android2.3.3，在Xoom上测试了Android 3.0.1，以及在iPad和iPhone上测试了iOS 4.2。</p>
<h3 id="简而言之，所有被测试的浏览器都支持touchstart、touchend和touchmove事件。"><a href="#简而言之，所有被测试的浏览器都支持touchstart、touchend和touchmove事件。" class="headerlink" title="简而言之，所有被测试的浏览器都支持touchstart、touchend和touchmove事件。"></a>简而言之，所有被测试的浏览器都支持touchstart、touchend和touchmove事件。</h3><p>规范提供了额外的三个触摸事件，但被测试的浏览器没有支持它们：</p>
<pre><code>1. touchenter：移动的手指进入一个DOM元素。

2. toucheleave：移动手指离开一个DOM元素。

3. touchcancel：触摸被中断（实现规范）。
</code></pre><p> 被测试的浏览器还在每个触摸列表内部都提供了touches、targetTouches和</p>
<p> changedTouches列表。不过，被测试的浏览器没有支持radiusX、radiusY或是<br> rotationAngle属性，这些属性指明触摸屏幕的手指的形状。在一次touchmove期<br> 间，事件大约一秒钟触发60次，所有的被测试设备都是这样。</p>
<p> 转载自：<br> <a href="http://www.jb51.net/article/72823.htm" target="_blank" rel="noopener">脚本之家</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/3/">上一页</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2021
        <i class="ri-heart-fill heart_icon"></i> 魏姣
      </li>
    </ul>
    <ul>
      <li>
        
        
        
        Powered by <a href="https://hexo.io" target="_blank">Hexo</a>
        <span class="division">|</span>
        Theme - <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></s>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="薇娇"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/lazyload.min.js"></script>
<!-- Tocbot -->

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>
<script src="/dist/main.js"></script>
<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->

<script src="/js/busuanzi-2.3.pure.min.js"></script>

<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->

<link rel="stylesheet" href="/css/clipboard.css">
<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>


<!-- CanvasBackground -->


    
  </div>
</body>

</html>