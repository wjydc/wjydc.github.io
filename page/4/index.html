<!doctype html>
<html class="theme-next use-motion theme-next-hexo-theme-next-0.4.0">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>




  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>


<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.0"/>





    <meta name="keywords" content="Hexo,next" />





    <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.0" />




  <title> 薇娇 </title>
</head>

<body>
  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <div id="header" class="header">
      <div class="header-inner">
        <h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand">
      <span class="logo">
        <i class="icon-logo"></i>
      </span>
      <span class="site-title">薇娇</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>


  <ul id="menu" class="menu">
    
      
      <li class="menu-item menu-item-home">
        <a href="/">
          <i class="menu-item-icon icon-home"></i> <br />
          Home
        </a>
      </li>
    
      
      <li class="menu-item menu-item-archives">
        <a href="/archives">
          <i class="menu-item-icon icon-archives"></i> <br />
          Archives
        </a>
      </li>
    
      
      <li class="menu-item menu-item-tags">
        <a href="/tags">
          <i class="menu-item-icon icon-tags"></i> <br />
          Tags
        </a>
      </li>
    
  </ul>


      </div>
    </div>

    <div id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content">
          
            
          

          <div id="posts" class="posts-expand">
            
  
    

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2016/02/22/使用CSS完成元素居中的七种方法/">
                使用CSS完成元素居中的七种方法
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          
            Posted on 2016-02-22
          
        </span>

        
          
        

        
          
        
      </div>
    </div>

    
      <div class="post-body">

        
        

        
          
            <h3 id="使用CSS完成元素居中的七种方法"><a href="#使用CSS完成元素居中的七种方法" class="headerlink" title="使用CSS完成元素居中的七种方法"></a>使用CSS完成元素居中的七种方法</h3><p>在网页上使 HTML 元素居中看似一件很简单的事情. 至少在某些情况下是这样的，但是复杂的布局往往使一些解决方案不能很好的发挥作用。</p>
<p>在网页布局中元素水平居中比元素垂直居中要简单不少，同时实现水平居中和垂直居中往往是最难的。现在是响应式设计的时代，我们很难确切的知道元素的准确高度和宽度，所以一些方案不大适用。据我所知, 在CSS中至少有六种实现居中的方法。我将使用下面的HTML结构从简单到复杂开始讲解:</p>
<pre><code>&lt;div class=&quot;center&quot;&gt;
      &lt;img src=&quot;jimmy-choo-shoe.jpg&quot; alt&gt;&lt;/div&gt;
</code></pre><h4 id="使用text-align水平居中"><a href="#使用text-align水平居中" class="headerlink" title="使用text-align水平居中"></a>使用text-align水平居中</h4><p><img src="https://gss0.baidu.com/9fo3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/eac4b74543a982268da2a9ac8c82b9014b90ebde.jpg" alt=""></p>
<p>有时显而易见的方案是最佳的选择：</p>
<pre><code>div.center {
  text-align: center;
  background: hsl(0, 100%, 97%);}div.center img {
  width: 33%; height: auto;}
</code></pre><p> 这种方案没有使图片垂直居中：你需要给<div> 添加 padding 或者给内容添加margin-top 和 margin-bottom使容器与内容之间有一定的距离。</div></p>
<h4 id="使用-margin-auto-居中"><a href="#使用-margin-auto-居中" class="headerlink" title="使用 margin: auto 居中"></a>使用 margin: auto 居中</h4><p><img src="http://d06.res.meilishuo.net/picdetail/a/53/82/990dcf4f386c706bbd38a83d3996_715_488_1_1.jpeg" alt=""></p>
<p>这种方式实现水平居中和上面使用text-align的方法有相同局限性。</p>
<pre><code>div.center {
  background: hsl(60, 100%, 97%);}div.center img {
  display: block;
  width: 33%;
  height: auto;
  margin: 0 auto;}
</code></pre><p> 注意： 必须使用display: block使 margin: 0 auto对img元素生效。</p>
<h4 id="使用table-cell居中"><a href="#使用table-cell居中" class="headerlink" title="使用table-cell居中"></a>使用table-cell居中</h4><p><img src="http://d04.res.meilishuo.net/pic/_o/12/b2/fedaa42ff8322d23c7f838706030_500_500.jpeg" alt=""></p>
<p>使用 display: table-cell, 而不是使用table标签; 可以实现水平居中和垂直居中，但是这种方法需要添加额外的元素作为外部容器。</p>
<pre><code>&lt;div class=&quot;center-aligned&quot;&gt;
&lt;div class=&quot;center-core&quot;&gt;
    &lt;img src=&quot;jimmy-choo-shoe.jpg&quot;&gt;
&lt;/div&gt;&lt;/div&gt;
</code></pre><p>CSS:</p>
<pre><code>.center-aligned {
display: table;
background: hsl(120, 100%, 97%);
width: 100%;}.center-core {
display: table-cell;
text-align: center;
vertical-align: middle;}.center-core img {
width: 33%;
height: auto;}
</code></pre><p>注意：为了使div 不折叠必须加上 width: 100%，外部容器元素也需要加上一定高度使得内容垂直居中。给html和body设置高度后，也可以使元素在body垂直居中。此方法在IE8+浏览器上生效。</p>
<h4 id="使用absolute定位居中"><a href="#使用absolute定位居中" class="headerlink" title="使用absolute定位居中"></a>使用absolute定位居中</h4><p><img src="http://d1.tuanimg.com/imagev2/zhaoshang/700x700.fdd06d6fd9aaed1bb1a333be58f1ec72.310x310.jpg" alt=""></p>
<p>这种 方案 有非常好的跨浏览器支持。有一个缺点就是必须显式声明外部容器元素的height：</p>
<pre><code>.absolute-aligned {
position: relative;
min-height: 500px;
background: hsl(200, 100%, 97%);}.absolute-aligned img {
width: 50%;
min-width: 200px;
height: auto;
overflow: auto;
margin: auto;
position: absolute;
top: 0; left: 0;
bottom: 0; right: 0;}
</code></pre><p>Stephen在他的 博客 中演示了这种方案的几种变化。</p>
<h4 id="使用translate居中"><a href="#使用translate居中" class="headerlink" title="使用translate居中"></a>使用translate居中</h4><p><img src="http://d1.tuanimg.com/imagev2/zhaoshang/700x700.fdd06d6fd9aaed1bb1a333be58f1ec72.310x310.jpg" alt=""><br>Chris Coiyer 提出了一个使用 CSS transforms 的新方案。 同样支持水平居中和垂直居中:</p>
<pre><code>.center {
background: hsl(180, 100%, 97%);
position: relative;
min-height: 500px;}.center img {
position: absolute;
top: 50%; left: 50%;
transform: translate(-50%, -50%);
width: 30%; height: auto;}
</code></pre><p>但是有以下几种缺点:</p>
<ul>
<li>CSS transform 在部分就浏览器上需要使用 前缀。</li>
<li>不支持 IE9 以下的浏览器。</li>
<li>外部容器需要设置height （或者用其他方式设置），因为不能获取 绝对定位 的内容的高度。</li>
<li>如果内容包含文字，现在的浏览器合成技术会使文字模糊不清。 </li>
</ul>
<h4 id="使用Flexbox居中"><a href="#使用Flexbox居中" class="headerlink" title="使用Flexbox居中"></a>使用Flexbox居中</h4><p><img src="http://www.qqjia.com/z/07/tu8603_13.jpg" alt=""><br>当新旧语法差异和浏览器前缀消失时，这种方法会成为主流的居中方案。</p>
<pre><code>.center { 
background: hsl(240, 100%, 97%);
display: flex;
justify-content: center;
align-items: center;}.center img { 
width: 30%; height: auto;}
</code></pre><p>在很多方面 flexbox 是一种简单的方案， 但是它有新旧两种语法以及早期版本的IE缺乏支持 （尽管可以使用 display: table-cell作为降级方案）。</p>
<p>现在规范已经最终确定，现代浏览器也大都支持,我写了一篇详细的教程 教程。</p>
<h4 id="使用calc居中"><a href="#使用calc居中" class="headerlink" title="使用calc居中"></a>使用calc居中</h4><p><img src="http://www.qqjia.com/z/07/tu8603_13.jpg" alt=""></p>
<p>在某些情况下比flexbox更全面：</p>
<pre><code>.center {
background: hsl(300, 100%, 97%);
min-height: 600px;
position: relative;}.center img {
width: 40%;
height: auto;
position: absolute;
top: calc(50% - 20%);
left: calc(50% - 20%);}
</code></pre><p>很简单，calc 允许你基于当前的页面布局计算尺寸。在上面的简单计算中， 50% 是容器元素的中心点，但是如果只设置50%会使图片的左上角对齐div的中心位置。 我们需要把图片向左和向上各移动图片宽高的一半。计算公式为：</p>
<pre><code>top: calc(50% - (40% / 2));left: calc(50% - (40% / 2));
</code></pre><p>在现在的浏览其中你会发现，这种方法更适用于当内容的宽高为固定尺寸：</p>
<pre><code>.center img {
width: 500px; height: 500px;
position: absolute;
top: calc(50% - (300px / 2));
left: calc(50% - (300px – 2)); }
</code></pre><p> 这种方案和flex一样有许多相同的缺点： 虽然在现代浏览器中有良好的支持，但是在较早的版本中仍然需要浏览器前缀，并且不支持IE8。</p>
<pre><code> .center img {
width: 40%; height: auto;
position: absolute;
top: calc(50% - 20%);
left: calc(50% - 20%);}
</code></pre><p> 当然还有 其他更多的方案。理解这六种方案之后，web开发人员在面对元素居中的时候会有更多的选择。</p>
<p>来源<a href="http://www.zcfy.cc/article/the-new-code-seven-ways-of-centering-with-css-439.html" target="_blank" rel="noopener">http://www.zcfy.cc/article/the-new-code-seven-ways-of-centering-with-css-439.html</a></p>

          
        
      </div>
    

    
      <div class="post-footer">
        

        

        
        
          <div class="post-eof"></div>
        
      </div>
    
  </div>


  
    

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2016/02/02/高德地图插件使用/">
                高德地图插件使用
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          
            Posted on 2016-02-02
          
        </span>

        
          
        

        
          
        
      </div>
    </div>

    
      <div class="post-body">

        
        

        
          
            <h2 id="高德地图"><a href="#高德地图" class="headerlink" title="高德地图"></a>高德地图</h2><h3 id="本文引自高德开放平台"><a href="#本文引自高德开放平台" class="headerlink" title="本文引自高德开放平台"></a>本文引自高德开放平台</h3><h4 id="准备页面"><a href="#准备页面" class="headerlink" title="准备页面"></a>准备页面</h4><p>在正式开始开发地图应用之前,您需要做如下几步:</p>
<p>1 在高德地图官网注册一个账号</p>
<p>2 <strong>申请JSAPI的开发者Key</strong><br>申请地址：</p>
<p><a href="http://lbs.amap.com/dev/key" target="_blank" rel="noopener">http://lbs.amap.com/dev/key</a></p>
<h3 id="引入高德地图JavaScript-API入口脚本"><a href="#引入高德地图JavaScript-API入口脚本" class="headerlink" title="引入高德地图JavaScript API入口脚本:"></a>引入高德地图JavaScript API入口脚本:</h3><pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;http://webapi.amap.com/maps?v=1.3&amp;key=您申请的key值&quot;&gt;&lt;/script&gt;
</code></pre><h3 id="创建地图容器"><a href="#创建地图容器" class="headerlink" title="创建地图容器"></a>创建地图容器</h3><p>在页面body里你想展示地图的地方创建一个div 容器，并指定id标识:</p>
<pre><code>&lt;div id=&quot;container&quot;&gt;&lt;/div&gt;
</code></pre><h3 id="指定容器大小"><a href="#指定容器大小" class="headerlink" title="指定容器大小"></a>指定容器大小</h3><p>使用CSS为地图容器设置合适的大小，比如:</p>
<pre><code>#container {width:300px; height: 180px; } 
</code></pre><h4 id="创建地图"><a href="#创建地图" class="headerlink" title="创建地图"></a>创建地图</h4><p>做完简单的准备工作之后，就可以开始创建地图了.</p>
<h3 id="按照默认属性创建地图"><a href="#按照默认属性创建地图" class="headerlink" title="按照默认属性创建地图"></a>按照默认属性创建地图</h3><p>生成一副简单地图只需要一句代码，将我们刚刚创建的div的id传给Map的构造函数即可，这个时候API将根据用户所在的城市自动进行地图中心点和级别的设定：</p>
<pre><code>var map = new AMap.Map(&apos;container&apos;);
</code></pre><ul>
<li><h3 id="设定地图的中心点和级别"><a href="#设定地图的中心点和级别" class="headerlink" title="设定地图的中心点和级别"></a>设定地图的中心点和级别</h3></li>
</ul>
<p>我们一般需要给地图按需设定中心点和坐标等属性，这里可以通过两种方式，第一种，直接在地图初始化的时候传入相关属性，center属性的值可以使经纬度的二元数组，也可以是AMap.LngLat对象，要求经度值在前，纬度值在后：</p>
<pre><code>var map = new AMap.Map(&apos;container&apos;,{
zoom: 10,
center: [116.39,39.9]});
</code></pre><p> 也可以在地图初始化过后，任何需要的地方通过方法来改变地图的中心点和级别</p>
<pre><code> var map = new AMap.Map(&apos;container&apos;);
map.setZoom(10);
map.setCenter([116.39,39.9]);
</code></pre><h4 id="添加点标记"><a href="#添加点标记" class="headerlink" title="添加点标记"></a>添加点标记</h4><p>创建好地图之后，我们就可以在地图上添加点标记了，用来标注任何用户感兴趣的位置和信息，这里使用到了AMap.Marker这个类。</p>
<ul>
<li><h4 id="点标记的创建与添加"><a href="#点标记的创建与添加" class="headerlink" title="点标记的创建与添加"></a>点标记的创建与添加</h4><p>同地图一样，点标记可以在创建的时候设定位置等属性，如果设定了map属性的话，marker点将被立即添加到地图上：</p>
<pre><code>var marker = new AMap.Marker({
position: [116.480983, 39.989628],
    map:map
});    
</code></pre><p>  也可以在创建之后按需更改这些属性:</p>
<pre><code>var marker = new AMap.Marker();
marker.setMap(map);
</code></pre></li>
<li><h4 id="点标记的移除"><a href="#点标记的移除" class="headerlink" title="点标记的移除"></a>点标记的移除</h4><p>移除的话，同样使用setMap方法,不传参数或者传入空参数：</p>
<pre><code>marker.setMap();
</code></pre></li>
</ul>
<h4 id="添加信息窗体"><a href="#添加信息窗体" class="headerlink" title="添加信息窗体"></a>添加信息窗体</h4><p>我们也可以用信息窗体InfoWindow类来向用户展示一些更详细的信息，比如点击一个点标记后，通过信息窗体来展示这个点标记在哪里</p>
<h5 id="信息窗体的创建与设定"><a href="#信息窗体的创建与设定" class="headerlink" title="信息窗体的创建与设定"></a>信息窗体的创建与设定</h5><p>信息窗体一样可以在创建的时候设定内容、偏移量、大小等属性，offset是信息窗体的锚点以position为基准位置的像素偏移量，content除了使用字符串的形式外也可以直接设定为某个创建好的DOM节点：</p>
<pre><code>var infowindow = new AMap.InfoWindow({
 content: &apos;&lt;h3&gt;高德地图&lt;/h3&gt;&lt;div&gt;高德是中国领先的数字地图内容、导航    和位置服务解决方案提供商。&lt;/div&gt;&apos;,
 offset: new AMap.Pixel(0, -30),
 size:new AMap.Size(230,0)
})
</code></pre><p>也可以在创建之后按需更改这些属性:</p>
<pre><code>infowindow.setSize(new AMap.Size(150,50));
var contentDiv = document.createElement(&apos;div&apos;);
contentDiv.innerText=&apos;我是信息窗体&apos;;
infowindow.setContent(contentDiv);
</code></pre><h5 id="如何打开信息窗体"><a href="#如何打开信息窗体" class="headerlink" title="如何打开信息窗体"></a>如何打开信息窗体</h5><p>我们可以在信息窗体创建之后立即调用其open方法将它显示在需要的位置：</p>
<pre><code>infowindow.open(map,new AMap.LngLat(116.480983, 39.989628));
</code></pre><p>也可以通过事件监听，在需要的时候才将信息窗体显示出来,比如在marker被单击的时候显示</p>
<pre><code>var clickHandle = AMap.event.addListener(marker, &apos;click&apos;,     function() {
    infowindow2.open(map, marker.getPosition())
})
</code></pre><p>当不再需要点击marker显示信息窗体这个功能的时候，可以通过如下方式移除事件绑定</p>
<pre><code>AMap.event.removeListener(clickHandle);
</code></pre><h3 id="使用高级信息窗体"><a href="#使用高级信息窗体" class="headerlink" title="使用高级信息窗体"></a>使用高级信息窗体</h3><p>除了普通的信息窗体，我们还提供了封装了周边搜索和路线规划功能在内的高级信息窗体，要使用高级信息窗体，首先需要通过plugin方法加载该插件，然后就可以和普通信息窗体一样进行创建和打开了。如果为高级信息窗体制定了panel属性，将在以panel的值为id的div上显示周边搜索或者路线规划的结果，如果需要对高级信息窗体和panel内容的样式进行修改，可以对相应classname的css进行重写：</p>
<pre><code>AMap.plugin(&apos;AMap.AdvancedInfoWindow&apos;,function(){
  var infowindow = new AMap.AdvancedInfoWindow({
content: &apos;&lt;h3 class=&quot;title&quot;&gt;高德地图&lt;/h3&gt;&apos;+
         &apos;&lt;div class=&quot;content&quot;&gt;高德是中国领先的数字地图内容、&apos;+
         &apos;导航和位置服务解决方案提供商。&lt;/div&gt;&apos;,
offset: new AMap.Pixel(0, -30),
asOrigin:false
  });
  infowindow.open(map,new AMap.LngLat(116.480983, 39.989628));
})
</code></pre><h5 id="添加工具条和比例尺"><a href="#添加工具条和比例尺" class="headerlink" title="添加工具条和比例尺"></a>添加工具条和比例尺</h5><p>高德地图JSAPI提供了大量丰富的功能控件和服务插件，下面我们来给上面做好的地图添加两个常用的控件，工具条和比例尺。</p>
<h6 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h6><p>添加控件的时候首先需要加载插件,同时需要多个插件的时候第一个参数可以设定为控件名称的数组</p>
<pre><code>AMap.plugin([&apos;AMap.ToolBar&apos;,&apos;AMap.Scale&apos;],function(){
//TODO  创建控件并添加
})
</code></pre><p>在回调函数里我们来进行控件的生成和添加:</p>
<pre><code>AMap.plugin([&apos;AMap.ToolBar&apos;,&apos;AMap.Scale&apos;],function(){
var toolBar = new AMap.ToolBar();
var scale = new AMap.Scale();
map.addControl(toolBar);
map.addControl(scale);
})
</code></pre><h5 id="移除"><a href="#移除" class="headerlink" title="移除"></a>移除</h5><p>要移除控件的时候调用地图的removeControl方法即可</p>
<pre><code>map.removeControl(toolBar);
</code></pre>
          
        
      </div>
    

    
      <div class="post-footer">
        

        

        
        
          <div class="post-eof"></div>
        
      </div>
    
  </div>


  
    

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2016/01/29/原生JavaScript事件详解/">
                原生JavaScript事件详解
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          
            Posted on 2016-01-29
          
        </span>

        
          
        

        
          
        
      </div>
    </div>

    
      <div class="post-body">

        
        

        
          
            <h3 id="原生JavaScript事件详解"><a href="#原生JavaScript事件详解" class="headerlink" title="原生JavaScript事件详解"></a>原生JavaScript事件详解</h3><p>JQuery这种Write Less Do More的框架，用多了难免会对原生js眼高手低。</p>
<p>小菜其实不想写这篇博客，貌似很初级的样子，但是看到网络上连原生js事件绑定和解除都说不明白，还是决定科普一下了。</p>
<p>首先声明，小菜懂的也不是很多，只是把我的思路和大家分享一下。</p>
<h4 id="DOM0事件模型"><a href="#DOM0事件模型" class="headerlink" title="DOM0事件模型"></a>DOM0事件模型</h4><p>事件模型在不断发展，早期的事件模型称为DOM0级别。</p>
<p>DOM0事件模型，所有的浏览器都支持。</p>
<p>直接在dom对象上注册事件名称，就是DOM0写法，比如：</p>
<pre><code>document.getElementById(&quot;test&quot;).onclick = function(e){};
</code></pre><p>意思就是注册一个onclick事件。当然，它和这种写法是一个意思：</p>
<pre><code>document.getElementById(&quot;test&quot;)[&quot;onmousemove&quot;] = function(e){};
</code></pre><p>这没什么，只不过是两种访问js对象属性的方法，[]的形式主要是为了解决属性名不是合法的标识符，比如：object.123肯定报错，但是object[“123”]就避免了这个问题，与此同时，[]的写法，也把js写活了，用字符串表示属性名称，可以在运行时动态绑定事件。</p>
<p>言归正传，事件被触发时，会默认传入一个参数e，表示事件对象，通过e，我们可以获取很多有用的信息，比如点击的坐标、具体触发该事件的dom元素等等。</p>
<p>基于DOM0的事件，对于同一个dom节点而言，只能注册一个，后边注册的同种事件会覆盖之前注册的。例如：</p>
<pre><code>var btn = document.getElementById(&quot;test&quot;);
btn.onmousemove = function(e){
 alert(&quot;ok&quot;);
 };

 btn[&quot;onmousemove&quot;] = function(e){
  alert(&quot;ok1&quot;);
 };
</code></pre><p>结果会输出ok1。</p>
<p>接下来再说说this。事件触发时，this就是指该事件在哪个dom对象上触发。例如：</p>
<pre><code>var btn = document.getElementById(&quot;test&quot;);

btn.onmousemove = function(e){
  alert(this.id);
  };
</code></pre><p>结果输出test。因为事件就是在id为test的dom节点上注册的，事件触发时，this当然代表这个dom节点，可以理解为事件是被这个dom节点调用的。</p>
<p>所以，想解除事件就相当简单了，只需要再注册一次事件，把值设成null，例如：</p>
<pre><code>var btn = document.getElementById(&quot;test&quot;);
btn.onclick = function(e){
 alert(&quot;ok&quot;);
 };

  btn.onclick = null;
</code></pre><p>原理就是最后注册的事件要覆盖之前的，最后一次注册事件设置成null，也就解除了事件绑定。</p>
<p>事情还没结束，DOM0事件模型还涉及到直接写在html中的事件。例如：</p>
<pre><code>&lt;div id=&quot;test&quot; class=&quot;test&quot; onclick=&quot;exec();&quot; &gt;&lt;/div&gt;
</code></pre><p>通过这种方式注册的事件，同样遵循覆盖原则，同样只能注册一个，最后一个生效。</p>
<p>区别就是，这样注册的事件，相当于动态调用函数(有点eval的意思)，因此不会传入event对象，同时，this指向的是window，不再是触发事件的dom对象。     </p>
<h4 id="DOM2事件模型"><a href="#DOM2事件模型" class="headerlink" title="DOM2事件模型"></a>DOM2事件模型</h4><p>  DOM2事件模型相对于DOM0，小菜仅仅了解如下两点：</p>
<p> ·  DOM2支持同一dom元素注册多个同种事件。</p>
<p> ·  DOM2新增了捕获和冒泡的概念。</p>
<p> DOM2事件通过addEventListener和removeEventListener管理，当然，这是标准。</p>
<p> 但IE8及其以下版本浏览器，自娱自乐，搞出了对应的attachEvent和detachEvent，由于小菜才疏学浅，本文不做讨论。</p>
<p>addEventListener当然就是注册事件，她有三个参数，分别为：”事件名称”, “事件回调”, “捕获/冒泡”。举个例子：     </p>
<pre><code>var btn = document.getElementById(&quot;test&quot;);
btn.addEventListener(&quot;click&quot;, function(e){
 alert(&quot;ok&quot;);
 }, false);
</code></pre><p> 事件名称就不用多说了，相比DOM0，去掉了前边的on而已。</p>
<p>事件回调也很好理解，事件触发了总得通知你吧！回调时和DOM0一样，也会默认传入一个event参数，同时this是指触发该事件的dom节点。</p>
<p>最后一个参数是布尔型，true代表捕获事件，false代表冒泡事件。其实很好理解，先来个示意图：<br><img src="http://images.cnitblog.com/blog/471788/201412/282221104503701.gif" alt="http://images.cnitblog.com/blog/471788/201412/282221104503701.gif"></p>
<p> 意思就是说，某个元素触发了某个事件，最先得到通知的是window，然后是document，依次而入，直到真正触发事件的那个元素(目标元素)为止，这个过程就是捕获。接下来，事件会从目标元素开始起泡，再依次而出，直到window对象为止，这个过程就是冒泡。</p>
<p>为什么要这样设计呢？这貌似是由于深厚的历史渊源，小菜也不怎么了解，就不乱说了。</p>
<p> 由此可以看出，捕获事件要比冒泡事件先触发.</p>
<p>假设有这样的html结构：</p>
<pre><code>&lt;div id=&quot;test&quot; class=&quot;test&quot;&gt;
    &lt;div id=&quot;testInner&quot; class=&quot;test-inner&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre><p>然后我们在外层div上注册两个click事件，分别是捕获事件和冒泡事件，代码如下：</p>
<pre><code>var btn = document.getElementById(&quot;test&quot;);
//捕获事件
btn.addEventListener(&quot;click&quot;, function(e){
alert(&quot;ok1&quot;);
}, true);

//冒泡事件
btn.addEventListener(&quot;click&quot;, function(e){
 alert(&quot;ok&quot;);
 }, false);
</code></pre><p>最后，点击内层的div，先弹出ok1，后弹出ok。结合上边的原理图，外层div相当于图中的body，内层div相当于图中最下边的div，证明了捕获事件先执行，然后执行冒泡事件。</p>
<p>为什么要强调点击内层的div呢？因为真正触发事件的dom元素，必须是内层的，外层dom元素才有机会模拟捕获事件和冒泡事件，从原理图上就看出了。</p>
<p>如果在真正触发事件的dom元素上注册捕获事件和冒泡事件呢？</p>
<p>html结构同上，js代码如下：</p>
<pre><code>var btnInner = document.getElementById(&quot;testInner&quot;);
 3 //冒泡事件
 btnInner.addEventListener(&quot;click&quot;, function(e){
  alert(&quot;ok&quot;);
  }, false);
  //捕获事件
  btnInner.addEventListener(&quot;click&quot;, function(e){
  alert(&quot;ok1&quot;);
  }, true);
</code></pre><p>当然还是点击内层div，结果是先弹出ok，再弹出ok1。理论上应该先触发捕获事件，也就是先弹出ok1，但是这里比较特殊，因为我们是在真正触发事件的dom元素上注册的事件，相当于在图中的div上注册，由图可以看出真正触发事件的dom元素，是捕获事件的终点，是冒泡事件的起点，所以这里就不区分事件了，哪个先注册，就先执行哪个。本例中，冒泡事件先注册，所以先执行。</p>
<p> 这个道理适用于多个同种事件，比如说一下子注册了3个冒泡事件，那么执行顺序就按照注册的顺序来，先注册先执行。例如：</p>
<pre><code>var btnInner = document.getElementById(&quot;testInner&quot;);
btnInner.addEventListener(&quot;click&quot;, function(e){
 alert(&quot;ok&quot;);
}, false);

 btnInner.addEventListener(&quot;click&quot;, function(e){
    alert(&quot;ok1&quot;);
 }, false);

 btnInner.addEventListener(&quot;click&quot;, function(e){
     alert(&quot;ok2&quot;);
 }, false);
</code></pre><p> 结果当然是依次弹出ok、ok1、ok2.</p>
<p>为了进一步理解事件模型，还有一种场景，假如说外层div和内层div同时注册了捕获事件，那么点击内层div时，外层div的事件一定是先触发的，代码如下：</p>
<pre><code>var btn = document.getElementById(&quot;test&quot;);
var btnInner = document.getElementById(&quot;testInner&quot;);

 btnInner.addEventListener(&quot;click&quot;, function(e){
   alert(&quot;ok&quot;);
  }, true);

 btn.addEventListener(&quot;click&quot;, function(e){
     alert(&quot;ok1&quot;);
 }, true);
</code></pre><p>   结果是先弹出ok1。</p>
<p>假如外层div和内层div都是注册的冒泡事件，点击内层div时，一定是内层div事件先执行，原理相同。</p>
<p>细心的读者会发现，对于div嵌套的情况，如果点击内层的div，外层的div也会触发事件，这貌似会有问题！</p>
<p>点击的明明是内层div，但是外层div的事件也触发了，这的确是个问题。</p>
<p>其实，事件触发时，会默认传入一个event对象，前边提过了，这个event对象上有一个方法：stopPropagation，通过此方法，可以阻止冒泡，这样外层div就接收不到事件了。代码如下：</p>
<pre><code>var btn = document.getElementById(&quot;test&quot;);
var btnInner = document.getElementById(&quot;testInner&quot;);

btn.addEventListener(&quot;click&quot;, function(e){
  alert(&quot;ok1&quot;);
  }, false);

 btnInner.addEventListener(&quot;click&quot;, function(e){
   //阻止冒泡
  e.stopPropagation();
    alert(&quot;ok&quot;);
  }, false);
</code></pre><p>终于要说说怎么解除事件了。解除事件语法：btn.removeEventListener(“事件名称”, “事件回调”, “捕获/冒泡”);</p>
<p> 这和绑定事件的参数一样，详细说明下：</p>
<p> ·  事件名称，就是说解除哪个事件呗。</p>
<p> ·  事件回调，是一个函数，这个函数必须和注册事件的函数是同一个。</p>
<p> ·  事件类型，布尔值，这个必须和注册事件时的类型一致。</p>
<p>也就是说，名称、回调、类型，三者共同决定解除哪个事件，缺一不可。举个例子：</p>
<pre><code>var btn = document.getElementById(&quot;test&quot;);
//将回调存储在变量中
var fn = function(e){
 alert(&quot;ok&quot;);
 };
 //绑定
 btn.addEventListener(&quot;click&quot;, fn, false);

 //解除
  btn.removeEventListener(&quot;click&quot;, fn, false);
</code></pre><p>要想注册过的事件能够被解除，必须将回调函数保存起来，否则无法解除。</p>
<p>至此，原生js事件已经讲的差不多了，小菜仅仅知道这些而已，欢迎读者补充其他知识点。</p>
<p> 在实际应用中，真正的行家不会傻傻的真的注册这么多事件，一般情况下，只需在最外层dom元素注册一次事件，然后通过捕获、冒泡机制去找到真正触发事件的dom元素，最后根据触发事件的dom元素提供的信息去调用回调。</p>
<p> 也就是说，行家会自己管理事件，而不依赖浏览器去管理，这样即可以提高效率，又保证了兼容性，JQuery不就是这么做的嘛~</p>
<p>好了，教程到此结束，希望对读者有所帮助！</p>
<p>原文链接：<a href="http://www.cnblogs.com/iyangyuan/p/4190773.html" target="_blank" rel="noopener">http://www.cnblogs.com/iyangyuan/p/4190773.html</a></p>

          
        
      </div>
    

    
      <div class="post-footer">
        

        

        
        
          <div class="post-eof"></div>
        
      </div>
    
  </div>


  
    

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2016/01/28/javascript中常用事件/">
                javascript中常用事件
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          
            Posted on 2016-01-28
          
        </span>

        
          
        

        
          
        
      </div>
    </div>

    
      <div class="post-body">

        
        

        
          
            <p>一 获取事件对象 </p>
<pre><code>document.onmouseover=function(){
console.log(&quot;a&quot;)}
由于火狐的兼容性问题，所以通过传参来解决兼容性问题
document.onclick=function(a){
var ev=a||window.event;
console.log(ev)
}
</code></pre><p>二获取鼠标当前位置clientX\clientY </p>
<pre><code>event.clientX 在可视区中,鼠标点击的x坐标 
event.clientY 在可视区中,鼠标点击的y坐标 
</code></pre><p>三 鼠标按下(onmousedown)和抬起(onmouseup)事件 </p>
<pre><code>demo  :使用鼠标拖拽一个div 

var box=document.getElementById(&apos;box&apos;);
document.onmousedown=function(e){
// 解决火狐兼容性问题
var evs=e||window.event; 
var divx=evs.clientX-box.offsetLeft;
var divy=evs.clientY-box.offsetTop;     
 document.onmousemove=function(b){
 // var evs=b||window.event; // 解决火狐兼容性问题
 var evb=b||window.event; 
 var divxb=evb.clientX-divx;
 var divyb=evb.clientY-divy; 
 box.style.left=divxb+&quot;px&quot;;
 box.style.top=divyb+&quot;px&quot;;
 console.log(divxb)
 }

 document.onmouseup=function(a){
 var eva=a||window.event; // 解决火狐兼容性问题
 document.onmousemove=&quot;null&quot;;
  }
  }
</code></pre><p>四 鼠标双击事件:ondblclick</p>
<p>五  组织默认事件的2中方法：</p>
<p>1  return  false       由于会阻止其他，所以一般放在最后执行</p>
<p>2 preventDefault    对IE6-IE8不兼容</p>
<p>六 键盘事件 keydown    keyup</p>
<p>keydown携带的一个参数是:keyCode,这个参数里的是每个按键的编码,我们可以通 过编码来判断用户按的是哪个按键</p>
<pre><code>demo  使用键盘的上下左右键控制div移动 
&lt;script type=&quot;text/javascript&quot;&gt;
var box=document.getElementById(&apos;box&apos;);
var l=0;
var t=0;
var s=0;
document.onkeydown=function(a){
var ev=a||window.event;
 if (ev.keyCode==37){
 l-=10;
 box.style.left=l+&quot;px&quot;;
 }
 else if(ev.keyCode==39){
 l+=10;
 box.style.left=l+&quot;px&quot;;
 }
else if(ev.keyCode==38){
t-=10;
box.style.top=t+&quot;px&quot;;
}

else if(ev.keyCode==40){
t+=10;
box.style.top=t+&quot;px&quot;;
}

else if(ev.keyCode==13){
s+=10;
box.style.top=s+&quot;px&quot;;
box.style.left=s+&quot;px&quot;;
}
}
</code></pre><p>一些特殊的按键 </p>
<pre><code>ctrlKey 返回boolean值,按下时为true 

shiftKey 返回boolean值,按下时为true 

altKey 返回boolean值,按下时为true 
</code></pre><p>按下以上的按键,并不会返回键盘编码,而是布尔值。我们经常在论坛中发帖,可以 按着control+回车键,就能直接发送蚊子了,我们就可以捕捉这两个按键返回的值来做 对应的处理。 </p>
<pre><code>window.onload = function () {
var oText1 = document.getElementById(&apos;text1&apos;);
var oText2 = document.getElementById(&apos;text2&apos;);
var oBtn = document.getElementById(&apos;btn&apos;);
// oBtn.onclick = function () { 
// oText1.value += oText2.value + &apos;\n&apos;; // 
oText2.value = &apos;&apos;; 
}; 
// control+enter , 
oText2.onkeydown = function (ev) {
var oEvent = ev || event;
// control 
if (oEvent.keyCode == 13 &amp;&amp; oEvent.ctrlKey) { 
// oText1.value += oText2.value + &apos;\n&apos;;
// 
oText2.value = &apos;&apos;;
}; 
} }  
</code></pre><p>七 输入框焦点事件:onfocus 焦点聚集 blur 焦点失去</p>
<p>八 事件冒泡 </p>
<p>子标签发生事件后,向父级发送该事件,一直追溯到document。如:点击一个嵌套在 body中的button,则该button的onclick事件也会传递给body、document中,触发他们 的onclick里触发的函数。<br>事件冒泡只发生在相同事件上。可通过cancelBubble=true取消相同事件冒泡</p>
<p>九 事件绑定</p>
<p>1.非IE浏览器</p>
<pre><code>target. addEventListener(type, listener, useCapture)

target: 文档节点、document、window 或 XMLHttpRequest。

type: 字符串,事件名称,不含“on”,比如“click”、“mouseover”、“keydown”等。 

listener :实现了 EventListener 接口或者是 JavaScript 中的函数。 

useCapture :是否使用捕捉,一般用 false 。
</code></pre><p>2.IE浏览器</p>
<pre><code>target.attachEvent(type,listener)

target :文档节点、document、window 或 XMLHttpRequest。 

type :字符串,事件名称,含“on”,比 如“onclick”、“onmouseover”、“onkeydown”等。

listener :实现了 EventListener 接口或者是 JavaScript 中的函数。 
</code></pre><p>3 <strong>有了绑定事件,自然有移除事件,根据是否是IE浏览器有两种写法:</strong></p>
<p>非IE浏览器 :</p>
<pre><code>target.removeEventListener(type,listener,useCapture);
</code></pre><p>IE浏览器:</p>
<pre><code>target.detachEvent(type, listener);
</code></pre><p>4 通过addEventListener()添加的事件处理程序只能使用removeEventListener()来移除；移除时传入的参数与添加处理程序时使用的参数相同。这也意味着通过addEventListener()添加的匿名函数无法移除，如下面的例子所示:</p>
<pre><code>var btn = document.getElementById(&quot;myBtn&quot;);

btn.addEventListener(&quot;click&quot;, function () {
alert(this.id);
}, false);
btn.removeEventListener(&quot;click&quot;, function () { //无效！
alert(this.id);
}, false);
</code></pre><p>在这个例子中，我使用addEventListener()添加一个事件处理程序。虽然调用removeEventListener(0是看似使用了相同的参数，但实际上，第二个参数与传入addEventListener()中的那一个完全不同的函数。而传入removeEventListener()中的事件处理程序函数必须与传入addEventListener()中的相同，如下面的例子所示：</p>
<pre><code>var btn = document.getElementById(&quot;myBtn&quot;);
var handler = function () {
alert(this.id);
};
btn.addEventListener(&quot;click&quot;, handler, false);
btn.removeEventListener(&quot;click&quot;, handler, false); //有效！
</code></pre><p>重写后的这个例子没有问题，是因为在addEventListener()和removeEventListener()中用来相同的函数。</p>
<p>5两者使用的原理:可对执行的优先级不一样,实例讲解如下: </p>
<p>IE:</p>
<pre><code>ele.attachEvent(&quot;onclick&quot;,method1);

ele.attachEvent(&quot;onclick&quot;,method2);

ele.attachEvent(&quot;onclick&quot;,method3);

执行顺序为method3-&gt;method2-&gt;method1 
</code></pre><p>非IE:</p>
<pre><code>ele.addEventListener(&quot;click&quot;,method1,false);

ele.addEventListener(&quot;click&quot;,method2,false);

ele.addEventListener(&quot;click&quot;,method3,false);

执行顺序为method1-&gt;method2-&gt;method3
</code></pre><p>6 为解决兼容性问题，利用判断</p>
<pre><code>var func = function(){}; 
//例： addEvent(window,&quot;load&quot;,func) 
function addEvent(elem, type, fn) { if (elem.attachEvent) { elem.attachEvent(&apos;on&apos; + type, fn); return;  }   if (elem.addEventListener) { elem.addEventListener(type, fn, false);    }   }   //例： removeEvent(window,&quot;load&quot;,func) 
function removeEvent(elem, type, fn) {  if (elem.detachEvent) { elem.detachEvent(&apos;on&apos; + type, fn); return;  }   if (elem.removeEventListener) { elem.removeEventListener(type, fn, false); }    } 
</code></pre>
          
        
      </div>
    

    
      <div class="post-footer">
        

        

        
        
          <div class="post-eof"></div>
        
      </div>
    
  </div>


  
    

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2016/01/14/Touch事件-1/">
                Touch事件
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          
            Posted on 2016-01-14
          
        </span>

        
          
        

        
          
        
      </div>
    </div>

    
      <div class="post-body">

        
        

        
          
            <p>js的touch事件，一般用于移动端的触屏滑动，例如：</p>
<pre><code>$(function(){document.addEventListener(&quot;touchmove&quot;, _touch,     false);}) function _touch(event){alert(1);}
</code></pre><p>主要认识一下四种事件：</p>
<p>touchstart:当手指触摸屏幕时触发；即使已经有一个手指放在了屏幕上也会触发。</p>
<p>touchend:当手指从屏幕上移开时触发。</p>
<p>touchmove:当手指在屏幕上滑动时连续的触发。在这个事件发生期间，调用</p>
<p>touchcancel:当系统停止跟踪触摸时触发。</p>
<p>preventDefault()可阻止滚动。</p>
<p>以上事件的event对象上面都存在如下属性：</p>
<p>touches:表示当前跟踪的触摸操作的Touch对象的数组。</p>
<p>targetTouches:特定于事件目标的Touch对象的数组。</p>
<p>changeTouches:表示自上次触摸以来发生了什么改变的Touch对象的数组。</p>
<p>每个Touch对象包含下列属性：</p>
<p>clientX:触摸目标在视口中的X坐标。</p>
<p>clientY:触摸目标在视口中的Y坐标。</p>
<p>identifier：表示触摸的唯一ID。</p>
<p>pageX：触摸目标在页面中的x坐标。</p>
<p>pageY：触摸目标在页面中的y坐标。</p>
<p>screenX:触摸目标在屏幕中的x坐标。</p>
<p>screenY:触摸目标在屏幕中的y坐标。</p>
<p>target:触摸的DOM节点坐标</p>
<h3 id="触摸事件"><a href="#触摸事件" class="headerlink" title="触摸事件"></a>触摸事件</h3><ul>
<li>touchstart：手指放在一个DOM元素上。</li>
<li>touchmove：手指拖曳一个DOM元素。</li>
<li>touchend：手指从一个DOM元素上移开。</li>
</ul>
<p>每个触摸事件都包括了三个触摸列表：</p>
<p> touches：当前位于屏幕上的所有手指的一个列表。</p>
<p> targetTouches：位于当前DOM元素上的手指的一个列表。</p>
<p> changedTouches：涉及当前事件的手指的一个列表</p>
<h3 id="可触控应用"><a href="#可触控应用" class="headerlink" title="可触控应用"></a>可触控应用</h3><p>touchstart、touchmove和touchend事件提供了一组足够丰富的功能来支持几乎是任何类型的基于触摸的交互——其中包括常见的多点触摸手势，比如说捏缩放、旋转等待。    下面的这段代码让你使用单指触摸来四处拖曳一个DOM元素：</p>
<pre><code>var obj = document.getElementByIdx_x_x_x_x_x_x(&apos;id&apos;);
 obj.addEventListener(&apos;touchmove&apos;, function(event) 
 { // 如果这个元素的位置内只有一个手指的话
if (event.targetTouches.length == 1) 
 {
  var touch = event.targetTouches[0];
   // 把元素放在手指所在的位置
   obj.style.left = touch.pageX + &apos;px&apos;;
 obj.style.top = touch.pageY + &apos;px&apos;;
  }
}, false);
</code></pre><p>下面是一个示例，该例子显示了屏幕上当前所有的触点，它的作用就是用来感受一下设备的响应性。</p>
<pre><code>canvas.addEventListener(&apos;touchmove&apos;,   
function(event) {
   for (var i = 0; i &lt; event.touches.length; i++) {
var touch = event.touches;
 ctx.beginPath();
   ctx.arc(touch.pageX, touch.pageY, 20, 0, 2*Math.PI, true);
   ctx.fill();
   ctx.stroke();
  }
 }, false);
</code></pre><h3 id="阻止滚动"><a href="#阻止滚动" class="headerlink" title="阻止滚动"></a>阻止滚动</h3><p>一些移动设备有缺省的touchmove行为，比如说经典的iOS overscroll效果，当滚动超出了内容的界限时就引发视图反弹。这种做法在许多多点触控应用中会带来混乱，但要禁用它很容易。</p>
<pre><code>document.body.addEventListener(&apos;touchmove&apos;, function(event) {
 event.preventDefault();
}, false); 
</code></pre><p>如果你正在编写的多点触控应用涉及了复杂的多指手势的话，要小心地考虑如何响应触摸事件，因为一次要处理这么多的事情。考虑一下前面一节中的在屏幕上画出所有触点的例子，你可以在有触摸输入的时候就立刻进行绘制：</p>
<pre><code>canvas.addEventListener(&apos;touchmove&apos;, function(event) {
 renderTouches(event.touches);
},
</code></pre><p>不过这一技术并不是要随着屏幕上的手指个数的增多而扩充，替代做法是，可以跟踪所有的手指，然后在一个循环中做渲染，这样可获得更好的性能：</p>
<pre><code>var touches = []
canvas.addEventListener(&apos;touchmove&apos;, function(event) {
  touches = event.touches;
}, false);
// 设置一个每秒60帧的定时器
timer = setInterval(function() {
 renderTouches(touches);
}, 15);
</code></pre><p>提示：setInterval不太适合于动画，因为它没有考虑到浏览器自己的渲染循环。现代的桌面浏览器提供了requestAnimationFrame这一函数，基于性能和电池工作时间原因，这是一个更好的选择。一但浏览器提供了对该函数的支持，那将是首选的处理事情的方式。<br>使用targetTouches和changedTouches<br>    要记住的一点是，event.touches是与屏幕接触的所有手指的一个数组，而不仅是位于目标DOM元素上的那些。你可能会发现使用 event.targetTouches和event.changedTouches来代替event.touches更有用一些。<br>    最后一点，因为你是在为移动设备做开发，因此你应该要留心移动的最佳做法，这些在Eric Bidelman的文章中有论及，以及要了解这一W3C文档。</p>
<h3 id="设备支持"><a href="#设备支持" class="headerlink" title="设备支持"></a>设备支持</h3><p>遗憾的是，触摸事件的实现在完备性和质量方面的差别很大。我编写了一个诊断脚本来显示一些关于触摸API实现的基本信息，其中包括哪些事件是支持的，以及 touchmove事件触发的解决方案。我在Nexus One和Nexus S硬件上测试了Android2.3.3，在Xoom上测试了Android 3.0.1，以及在iPad和iPhone上测试了iOS 4.2。</p>
<h3 id="简而言之，所有被测试的浏览器都支持touchstart、touchend和touchmove事件。"><a href="#简而言之，所有被测试的浏览器都支持touchstart、touchend和touchmove事件。" class="headerlink" title="简而言之，所有被测试的浏览器都支持touchstart、touchend和touchmove事件。"></a>简而言之，所有被测试的浏览器都支持touchstart、touchend和touchmove事件。</h3><p>规范提供了额外的三个触摸事件，但被测试的浏览器没有支持它们：</p>
<pre><code>1. touchenter：移动的手指进入一个DOM元素。

2. toucheleave：移动手指离开一个DOM元素。

3. touchcancel：触摸被中断（实现规范）。
</code></pre><p> 被测试的浏览器还在每个触摸列表内部都提供了touches、targetTouches和</p>
<p> changedTouches列表。不过，被测试的浏览器没有支持radiusX、radiusY或是<br> rotationAngle属性，这些属性指明触摸屏幕的手指的形状。在一次touchmove期<br> 间，事件大约一秒钟触发60次，所有的被测试设备都是这样。</p>
<p> 转载自：<br> <a href="http://www.jb51.net/article/72823.htm" target="_blank" rel="noopener">脚本之家</a></p>

          
        
      </div>
    

    
      <div class="post-footer">
        

        

        
        
          <div class="post-eof"></div>
        
      </div>
    
  </div>


  

          </div>

          
            <div class="pagination">
              <a class="extend prev" rel="prev" href="/page/3/">&laquo;</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span>
            </div>
          
        </div>

        
<div class="sidebar-toggle">
  <div class="sidebar-toggle-line-wrap">
    <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
  </div>
</div>

<div id="sidebar" class="sidebar">
  <div class="sidebar-inner">

    

    <div class="site-overview">
      <div class="site-author motion-element">
        <img class="site-author-image" src="/images/default_avatar.jpg" alt="魏姣" />
        <p class="site-author-name">魏姣</p>
      </div>
      <p class="site-description motion-element"></p>
      <div class="site-state motion-element">
        <div class="site-state-item site-state-posts">
          <span class="site-state-item-count">35</span>
          <span class="site-state-item-name">posts</span>
        </div>
        <div class="site-state-item site-state-tags">
            <span class="site-state-item-count">0</span>
            <span class="site-state-item-name">tags</span>
        </div>
        <div class="site-state-item site-state-pages">
            <span class="site-state-item-count">0</span>
            <span class="site-state-item-name">pages</span>
        </div>
      </div>

      

      <div class="links-of-author motion-element">
        
      </div>

      
      

    </div>

    

  </div>
</div>


      </div>
    </div>

    <div id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; &nbsp; 
  2021
  <span class="with-love">
    <i class="icon-heart"></i>
  </span>
  <span class="author">魏姣</span>
</div>

<div class="powered-by">
  Powered by <a class="theme-link" href="http://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT
  </a>
</div>



      </div>
    </div>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript">
    $(document).ready(function() {
      $(".fancybox").fancybox();
    });
  </script>

  <script type="text/javascript">
  function hasMobileUA () {
    var nav = window.navigator;
    var ua = nav.userAgent;
    var pa = /iPad|iPhone|Android|Opera Mini|BlackBerry|webOS|UCWEB|Blazer|PSP|IEMobile|Symbian/g;

    return pa.test(ua);
  }

  function isDesktop () {
    return screen.width > 991 && !hasMobileUA();
  }

  function isTablet () {
    return screen.width < 992 && screen.width > 767 && hasMobileUA();
  }

  function isMobile () {
    return screen.width < 767 && hasMobileUA();
  }

  function escapeSelector (selector) {
    return selector.replace(/[!"$%&'()*+,.\/:;<=>?@[\\\]^`{|}~]/g, "\\$&")
  }
</script>

  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" id="motion.global">
  $(document).ready(function () {
    var body = $('body');
    var isSidebarVisible = false;
    var sidebarToggle = $('.sidebar-toggle');
    var sidebarToggleLine1st = $('.sidebar-toggle-line-first')
    var sidebarToggleLine2nd = $('.sidebar-toggle-line-middle');
    var sidebarToggleLine3rd = $('.sidebar-toggle-line-last');
    var sidebar = $('.sidebar');

    var SIDEBAR_WIDTH = '320px';
    var SIDEBAR_DISPLAY_DURATION = 300;

    var sidebarToogleLineStatusInit = {width: '100%', opacity: 1, left: 0, rotateZ: 0, top: 0};

    var sidebarToggleLine1stStatusInit = sidebarToogleLineStatusInit;
    var sidebarToggleLine1stStatusArrow = {width: '50%', rotateZ: '-45deg', top: '2px'};
    var sidebarToogleLine1stStatusClose = {width: '100%', rotateZ: '-45deg', top: '5px'};

    var sidebarToggleLine2ndStatusInit = sidebarToogleLineStatusInit;
    var sidebarToggleLine2ndStatusArrow = {width: '90%'};
    var sidebarToogleLine2ndStatusClose = {opacity: 0};

    var sidebarToggleLine3rdStatusInit = sidebarToogleLineStatusInit;
    var sidebarToggleLine3rdStatusArrow = {width: '50%', rotateZ: '45deg', top: '-2px'};
    var sidebarToogleLine3rdStatusClose = {width: '100%', rotateZ: '45deg', top: '-5px'};

    LogoAndMenuMotion();
    sidebatToggleMotion();
    postsListMotion();
    backToTopMotion();


    $(document)
      .on('sidebar.isShowing', function () {
        isDesktop() && body.velocity(
          {paddingRight: SIDEBAR_WIDTH},
          SIDEBAR_DISPLAY_DURATION
        );
        sidebarContentMotion();
      })
      .on('sidebar.isHiding', function () {});

    function LogoAndMenuMotion() {
      $.Velocity.RunSequence([
        { e: $('.brand'), p: { opacity: 1 }, o: { duration: 100 } },
        { e: $('.logo'), p: { opacity: 1, top: 0 }, o: { duration: 50} },
        
        { e: $('.site-title'), p: { opacity: 1, top: 0 }, o: { duration: 200 } }
      ]);
      $('.menu-item').velocity('transition.slideDownIn', {display: null});
    }


    function backToTopMotion () {
      var b2top = $('.back-to-top');
      b2top.on('click', function () {
        body.velocity('scroll');
      });
    }

    function sidebarShowMotion () {

      sidebarToggleLine1st.velocity(sidebarToogleLine1stStatusClose);
      sidebarToggleLine2nd.velocity(sidebarToogleLine2ndStatusClose);
      sidebarToggleLine3rd.velocity(sidebarToogleLine3rdStatusClose);

      sidebar.velocity({width: SIDEBAR_WIDTH}, {
        display: 'block',
        duration: SIDEBAR_DISPLAY_DURATION,
        complete: function () {
          sidebar.addClass('sidebar-active');
          sidebar.trigger('sidebar.didShow');
        }
      });
      sidebar.trigger('sidebar.isShowing');
    }

    function sidebarHideMotion () {
      isDesktop() && body.velocity({paddingRight: 0});
      sidebar.velocity('reverse');

      sidebarToggleLine1st.velocity(sidebarToggleLine1stStatusInit);
      sidebarToggleLine2nd.velocity(sidebarToggleLine2ndStatusInit);
      sidebarToggleLine3rd.velocity(sidebarToggleLine3rdStatusInit);

      sidebar.removeClass('sidebar-active');
      sidebar.trigger('sidebar.isHiding');
    };

    function sidebarContentMotion () {
      $('.sidebar .motion-element').velocity(
        'transition.slideRightIn',
        {stagger: 50, drag: true}
      );
    }

    function postsListMotion () {
      var postMotionOptions = window.postMotionOptions || {stagger: 300, drag: true};
      $('.post').velocity('transition.slideDownIn', postMotionOptions);
    }

    function sidebatToggleMotion () {
      sidebarToggle.on('click', function () {
        isSidebarVisible ? sidebarHideMotion() : sidebarShowMotion();
        isSidebarVisible = !isSidebarVisible;
      });

      sidebarToggle.hover(function () {
        if (isSidebarVisible) {return}
        sidebarToggleLine1st.velocity('stop').velocity(sidebarToggleLine1stStatusArrow);
        sidebarToggleLine2nd.velocity('stop').velocity(sidebarToggleLine2ndStatusArrow);
        sidebarToggleLine3rd.velocity('stop').velocity(sidebarToggleLine3rdStatusArrow);
      }, function () {
        if (isSidebarVisible) {return}
        sidebarToggleLine1st.velocity('stop').velocity(sidebarToggleLine1stStatusInit);
        sidebarToggleLine2nd.velocity('stop').velocity(sidebarToggleLine2ndStatusInit);
        sidebarToggleLine3rd.velocity('stop').velocity(sidebarToggleLine3rdStatusInit);
      });
    }
  });

</script>





  

  

  
  

  


  
</body>
</html>
